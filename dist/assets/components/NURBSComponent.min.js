/* X_ITE v11.3.1 */
const t=window[Symbol.for("X_ITE.X3D-11.3.1")];(()=>{var e={n:t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},d:(t,i)=>{for(var n in i)e.o(i,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const i=t.Components;var n=e.n(i);const o=t.Fields;var s=e.n(o);const r=t.X3DFieldDefinition;var a=e.n(r);const l=t.FieldDefinitionArray;var h=e.n(l);const u=t.X3DNode;var d=e.n(u);const c=t.X3DConstants;var g=e.n(c);const p=t.X3DCast;var f=e.n(p);const _=t.Namespace;var m=e.n(_);function w(t){d().call(this,t),this.addType(g().Contour2D),this.childNodes=[]}function y(t,e){const i=new Set(e);return t.filter((t=>!i.has(t)))}Object.assign(Object.setPrototypeOf(w.prototype,d().prototype),{initialize(){d().prototype.initialize.call(this),this._addChildren.addInterest("set_addChildren__",this),this._removeChildren.addInterest("set_removeChildren__",this),this._children.addInterest("set_children__",this),this.set_children__()},set_addChildren__(){this._addChildren.setTainted(!0),this._addChildren.assign(y(this._addChildren,this._children));for(const t of this._addChildren)this._children.push(t);this._addChildren.length=0,this._addChildren.setTainted(!1)},set_removeChildren__(){this._removeChildren.setTainted(!0),this._children.assign(y(this._children,this._removeChildren)),this._removeChildren.length=0,this._removeChildren.setTainted(!1)},set_children__(){const t=this.childNodes;for(const e of t)e.removeInterest("addNodeEvent",this);t.length=0;for(const e of this._children){const i=f()(g().NurbsCurve2D,e)??f()(g().ContourPolyline2D,e);i&&t.push(i)}for(const e of t)e.addInterest("addNodeEvent",this)},addTrimmingContour(t,e,i){const n=[];for(const t of this.childNodes)t.tessellate(2,n);if(n.length){for(const i of n)i.subtract(t).divVec(e);i.push(n)}}}),Object.defineProperties(w,{...d().getStaticProperties("Contour2D","NURBS",4,"trimmingContour","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOnly,"addChildren",new(s().MFNode)),new(a())(g().inputOnly,"removeChildren",new(s().MFNode)),new(a())(g().inputOutput,"children",new(s().MFNode))]),enumerable:!0}});const v=w,b=m().add("Contour2D",v);function C(t){d().call(this,t),this.addType(g().X3DNurbsControlCurveNode)}Object.setPrototypeOf(C.prototype,d().prototype),Object.defineProperties(C,d().getStaticProperties("X3DNurbsControlCurveNode","NURBS",1));const O=C,N=m().add("X3DNurbsControlCurveNode",O),S=t.Vector3;var P=e.n(S);function D(t){N.call(this,t),this.addType(g().ContourPolyline2D),this.array=[]}Object.assign(Object.setPrototypeOf(D.prototype,N.prototype),{tessellate(t,e=this.array){const i=this._controlPoint.getValue(),n=2*this._controlPoint.length;switch(t){case 0:e.length=0;for(let t=0;t<n;t+=2)e.push(i[t],i[t+1]);break;case 1:e.length=0;for(let t=0;t<n;t+=2)e.push(i[t],0,i[t+1]);break;case 2:for(let t=0;t<n;t+=2)e.push(new(P())(i[t],i[t+1],0))}return e}}),Object.defineProperties(D,{...d().getStaticProperties("ContourPolyline2D","NURBS",3,"children","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOutput,"controlPoint",new(s().MFVec2d))]),enumerable:!0}});const F=D,T=m().add("ContourPolyline2D",F),V=t.X3DGeometryNode;var j=e.n(V);const x=t.Vector2;var R=e.n(x);const I=t.Vector4;var z=e.n(I);const A={getTessellation:(t,e)=>t>0?t:t<0?-t*e:2*e,getClosed2D(t,e,i,n){const o=n.length;return(!(i.length===o)||i[0]===i[o-1])&&!!n[0].equals(n[o-1])},getClosed:(()=>{const t=new(P()),e=new(P());return function(i,n,o,s){const r=s.getSize();return(!(o.length===r)||o[0]===o[r-1])&&!!s.get1Point(0,t).equals(s.get1Point(r-1,e))}})(),getUClosed:(()=>{const t=new(P()),e=new(P());return function(i,n,o,s,r,a){const l=r.length===a.getSize();for(let i=0;i<o;++i){const o=i*n,s=i*n+n-1;if(l&&r[o]!==r[s])return!1;if(!a.get1Point(o,t).equals(a.get1Point(s,e)))return!1}return!0}})(),getVClosed:(()=>{const t=new(P()),e=new(P());return function(i,n,o,s,r,a){const l=r.length===a.getSize();for(let i=0;i<n;++i){const s=i,h=(o-1)*n+i;if(l&&r[s]!==r[h])return!1;if(!a.get1Point(s,t).equals(a.get1Point(h,e)))return!1}return!0}})(),getKnots(t,e,i,n,o){const s=n+i,r=t??[];for(let t=0,e=o.length;t<e;++t)r[t]=o[t];r.length=o.length;let a=!0;if(r.length===s){a=!1;let t=0;for(let e=1;e<s;++e)r[e]===r[e-1]?++t:t=0,t>i-1&&(a=!0),r[e-1]>r[e]&&(a=!0)}if(a){if(e)for(let t=0;t<s;++t)r[t]=t;else{let t=0,e=1;for(;t<i;++t)r[t]=0;for(const n=s-i;t<n;++t,++e)r[t]=e;for(;t<s;++t)r[t]=e}r.length=s;const t=r.at(-1);for(let e=0;e<s;++e)r[e]/=t}if(e){const t=i-1;for(let e=1;e<t;++e)r.push(r.at(-1)+(r[e]-r[e-1]))}return r},getWeights(t,e,i){if(i.length!==e)return;const n=t??[];for(let t=0;t<e;++t)n[t]=i[t];return n.length=e,n},getUVWeights(t,e,i,n){const o=e*i;if(n.length!==o)return;const s=t??[];for(let t=0,o=0;t<e;++t)for(let t=0;t<i;++t,++o)s[o]=n[o];return s.length=o,s},getControlPoints2D(t,e,i,n,o){const s=t??[],r=o.getValue(),a=o.length,l=!!n,h=l?P():R();s.haveWeights!==l&&(s.haveWeights=l,s.length=0);for(let t=0;t<a;++t){const e=2*t;(s[t]??=new h(0,0,0)).set(r[e+0],r[e+1],l?n[t]:0)}if(s.length=a,e){const t=i-1;for(let e=1;e<t;++e)s.push(s[e])}return s},getControlPoints(t,e,i,n,o){const s=t??[],r=o.getSize(),a=!!n,l=a?z():P();s.haveWeights!==a&&(s.haveWeights=a,s.length=0);for(let t=0;t<r;++t){const e=o.get1Point(t,s[t]??=new l(0,0,0,0));a&&(e.w=n[t])}if(s.length=r,e){const t=i-1;for(let e=1;e<t;++e)s.push(s[e])}return s},getUVControlPoints(t,e,i,n,o,s,r,a,l){const h=t??[],u=!!a,d=u?z():P();h.haveWeights!==u&&(h.haveWeights=u,h.length=0);for(let t=0;t<s;++t){const e=h[t]??=[];for(let i=0;i<r;++i){const n=i*s+t;l.get1Point(n,e[i]??=new d(0,0,0,0)),u&&(e[i].w=a[n])}if(e.length=r,i){const t=o-1;for(let i=1;i<t;++i)e.push(e[i])}}if(h.length=s,e){const t=n-1;for(let e=1;e<t;++e)h.push(h[e])}return h},getTexControlPoints(t,e,i,n,o,s,r,a){const l=t??[];for(let t=0;t<s;++t){const e=l[t]??=[];for(let i=0;i<r;++i){const n=i*s+t;a.get1Point(n,e[i]??=new(z()))}if(e.length=r,i){const t=o-1;for(let i=1;i<t;++i)e.push(e[i])}}if(l.length=s,e){const t=n-1;for(let e=1;e<t;++e)l.push(l[e])}return l}},k=m().add("NURBS",A);function B(t){j().call(this,t),this.addType(g().X3DParametricGeometryNode)}Object.assign(Object.setPrototypeOf(B.prototype,j().prototype),{getKnots:(t,e,i,n,o)=>k.getKnots(t,e,i,n,o)}),Object.defineProperties(B,d().getStaticProperties("X3DParametricGeometryNode","NURBS",1));const E=B,M=m().add("X3DParametricGeometryNode",E),K=t.X3DLineGeometryNode;var U=e.n(K);const G=m().add("is-ndarray",(function(t){return!!t&&(!!t.dtype&&new RegExp("function View[0-9]+d(:?"+t.dtype+")+").test(String(t.constructor)))})),Y=m().add("is-ndarray-like",(function(t){return!!t&&(void 0!==t.data&&Array.isArray(t.shape)&&void 0!==t.offset&&void 0!==t.stride)})),W=m().add("is-array-like",(function(t){return Array.isArray(t)||ArrayBuffer.isView(t)||void 0!==t.length}));function X(t){if(t){if(G(t)||Y(t))return"generic"===t.dtype?X.GENERIC_NDARRAY:X.NDARRAY;if(W(t)){for(var e=t;W(e[0]);e=e[0]);return"x"in e?X.ARRAY_OF_OBJECTS:X.ARRAY_OF_ARRAYS}throw new Error("Unhandled data type. Got type: "+typeof t)}}X.ARRAY_OF_OBJECTS="Obj",X.ARRAY_OF_ARRAYS="Arr",X.NDARRAY="Nd",X.GENERIC_NDARRAY="GenNd",X.PACKED="PackArr";const q=X,L=m().add("infer-type",q);const J=m().add("cache-key",(function(t,e,i,n,o,s){var r,a,l=[],h=!1;for(r=0;r<t.splineDimension;r++){var u=W(t.knots)&&W(t.knots[r]);u&&(h=!0),l.push("Deg"+t.degree[r]+(u?"":"Uniform")+((a=t.boundary[r])[0].toUpperCase()+a.slice(1)))}var d=[[h?"NU":"",t.weights?"RBS":"BS"].join("")+t.dimension+"D",l.join("_")];return n&&d.push(n+"Pts"),o&&d.push(o+"Wts"),s&&d.push(s+"Kts"),e&&d.push("debug"),i&&d.push("chk"),d.join("_")}));var H=function t(e,i){return function(i,n){void 0===i||Array.isArray(i)||(i=[i]);for(var o=[],s=0;s<i.length;s++)o.push(t.sum(i[s]));if(n)for(i=0;i<o.length;i++)void 0!==n[i]&&(o[i]="("+o[i]+" + "+n[i]+") % "+n[i]);return e+o.join("_")}};H.sum=function(t){return 0===(t=(t=Array.isArray(t)?t:[t]).filter((t=>void 0!==t&&0!==t))).length&&t.push(0),t.join(" + ")};const Q=H,Z=m().add("variable",Q);var $=[".x",".y",".z",".w"];function tt(t){return function(e,i){void 0===e||Array.isArray(e)||(e=[e]);for(var n=[],o=0;o<e.length;o++)n.push(Z.sum(e[o]));if(i)for(e=0;e<n.length;e++)void 0!==i[e]&&(n[e]="("+n[e]+" + "+i[e]+") % "+i[e]);return t(n)}}function et(t,e){if(e)switch(L(e)){case L.ARRAY_OF_OBJECTS:return tt((e=>{var i=e.pop();return t+"["+e.join("][")+"]"+$[i]}));case L.ARRAY_OF_ARRAYS:return tt((e=>t+"["+e.join("][")+"]"));case L.GENERIC_NDARRAY:return tt((e=>t+".get("+e.join(",")+")"));case L.NDARRAY:return tt((e=>{for(var i=[t+"Offset"],n=0;n<e.length;n++)i.push(t+"Stride"+n+" * ("+e[n]+")");return t+"["+i.join(" + ")+"]"}));case L.PACKED:default:return}}const it=m().add("create-accessors",(function(t){var e,i={};return(e=et("x",t.points))&&(i.point=e),(e=et("w",t.weights))&&(i.weight=e),(e=et("k",t.knots))&&(i.knot=e),i}));var nt=[],ot=[];const st=m().add("numerical-derivative",(function(t,e,i){if(1!==e)throw new Error("Numerical derivative not implemented for order n = "+e+".");var n,o=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(nt.length=this.splineDimension,n=0;n<this.splineDimension;n++)nt[n+1]=arguments[n+3];var s,r,a,l=this.domain,h=l[i][0],u=l[i][1],d=nt[i+1],c=(u-h)*o;for("closed"===this.boundary[i]?(s=h+(d-h-c+(a=u-h))%a,r=h+(d-h+c+a)%a,c*=2):(s=Math.min(u,Math.max(h,d-c)),c=(r=Math.min(u,Math.max(h,d+c)))-s),nt[i+1]=s,nt[0]=ot,this.evaluate.apply(null,nt),nt[i+1]=r,nt[0]=t,this.evaluate.apply(null,nt),n=0;n<this.dimension;n++)t[n]=(t[n]-ot[n])/c;return t})),rt=m().add("ndloop",(function(t,e){for(var i=1,n=0,o=[];n<t.length;n++)i*=Array.isArray(t[n])?t[n][1]-t[n][0]:t[n],o[n]=Array.isArray(t[n])?t[n][0]:0;for(var s=0;s<i;s++)for(e(o.slice()),n=t.length-1;n>=0;n--){if(o[n]!==(Array.isArray(t[n])?t[n][1]:t[n])-1){o[n]++;break}o[n]=Array.isArray(t[n])?t[n][0]:0}})),at=m().add("accessor-preamble",(function(t,e,i,n){var o=[];switch(L(n)){case L.NDARRAY:o.push("  var "+e+" = "+i+".data;"),o.push("  var "+e+"Offset = "+i+".offset;");for(var s=0;s<n.dimension;s++)o.push("  var "+e+"Stride"+s+" = "+i+".stride["+s+"];");break;case L.ARRAY_OF_OBJECTS:case L.ARRAY_OF_ARRAYS:o.push("  var "+e+" = "+i+";")}return o.join("\n")})),lt=m().add("size-getter",(function(t,e,i){if(t){if(Y(t))return e+".shape["+i+"]";for(var n=e,o=0;o<i;o++)n+="[0]";return n+".length"}return"this.size["+i+"]"}));var ht={},ut={};const dt=m().add("evaluator",(function(t,e,i,n,o,s,r){var a,l,h,u,d,c,g=e.splineDimension,p=e.points,f=e.degree,_=e.weights,m=void 0!==_,w=e.knots,y=e.dimension,v=e.boundary;if(null!=r){Array.isArray(r)||(r=[r]);var b=0;for(a=0;a<g;a++)void 0===r[a]&&(r[a]=0),b+=r[a];if(m&&b>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+b+".")}s&&(t="Basis"+t),r&&(t="Der"+r.join("_")+"_"+t);var C=ht[t];if(n)var O="function"==typeof n?n:console.log;if(C)return n&&O(ut[t]),C.bind(e);var N=[],S="evaluate"+t,P=i.point;s&&(P=function(t,e){for(var i=[],n=0;n<t.length;n++){for(var o=t[n],s=[],r=0;r<o.length;r++)0!==o[r]&&s.push(o[r]);o=s.join(" + "),e[n]&&(o="("+o+" + "+e[n]+") % "+e[n]),i.push(o+" === "+x(n))}return"(("+i.join(" && ")+") ? 1 : 0)"});var D=i.weight,F=i.knot,T=Z("k"),V=Z("x"),j=Z("w"),x=Z("i"),R=Z("t"),I=n?"domain":"d",z=Z(n?"size":"s"),A=Z(n?"knotIndex":"j"),k=!0;for(d=0;d<g;d++)W(w)&&W(w[d])&&(k=!1);function B(t){N.push("  "+(t||""))}function E(t){n&&B(t)}if(s)var M=[];var K=[];for(a=0;a<g;a++)s&&M.push(x([a])),K.push(R([a]));for(N.push("function "+S+" ("+(s?"":"out, ")+K.join(", ")+(s?", "+M.join(", "):"")+") {"),B("var h, m, a, b;"),o&&(B("var "+I+" = this.domain;"),B("for (var i = 0; i < this.splineDimension; i++) {"),B("  a = arguments[i + 1];"),B("  if (a < "+I+"[i][0] || a > "+I+"[i][1] || a === undefined || isNaN(a)) {"),B('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+I+'[i][0]+", "+'+I+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),B("  }"),B("}")),d=0;d<g;d++)B("var "+z(d)+" = "+lt(p,"this.points",d)+";");function U(t,e,i){return"("+t+") ? ("+e+") : ("+i+")"}N.push(at(e,"x","this.points",p)),m&&N.push(at(e,"w","this.weights",_)),k||N.push(at(e,"k","this.knots",w));var G=[];for(d=0;d<g;d++)switch(L(w)){case L.NDARRAY:G[d]=!0;break;case L.ARRAY_OF_ARRAYS:G[d]=W(w[d])}for(d=0;d<g;d++)if(G[d])for(E("\n  // Bisect to locate the knot interval in dimension "+d+"\n"),B("var "+A(d)+" = 0;"),B("h = "+z(d)+";"),B("while(h > "+A(d)+" + 1) {"),B("  m = 0.5 * (h + "+A(d)+") | 0;"),B("  if ("+F([d,"m"])+" > "+R(d)+") h = m;"),B("  else "+A(d)+" = m;"),B("}"),E("\n  // Fetch knots for dimension "+d+"\n"),a=1-f[d];a<=f[d];a++)"closed"===v[d]?B(a<0?"var "+T([d,a+f[d]-1])+" = "+U(A(d)+" < "+-a,F([d,0])+" + "+F([d,[z(d),A(d),a]])+" - "+F([d,[z(d)]]),F([d,[A(d),a]]))+";":a>0?"var "+T([d,a+f[d]-1])+" = "+U(A(d)+" + "+a+" > "+z(d),F([d,z(d)])+" + "+F([d,a+" + "+A(d)+" - "+z(d)])+" - "+F([d,0]),F([d,[A(d),a]]))+";":"var "+T([d,a+f[d]-1])+" = "+F([d,[A(d),a]])+";"):B("var "+T([d,a+f[d]-1])+" = "+F([d,[A(d),a]])+";");else{for(E("\n  // Directly compute knot interval for dimension "+d+"\n"),"closed"===v[d]?B(A(d)+" = ("+R(d)+" | 0) % "+z(d)+";"):(B(A(d)+" = ("+R(d)+" | 0);"),B("if ("+A(d)+" < "+f[d]+") "+A(d)+" = "+f[d]+";"),B("if ("+A(d)+" > "+z(d)+" - 1) "+A(d)+" = "+z(d)+" - 1;")),E("\n  // Compute and clamp knots for dimension "+d+"\n"),a=1-f[d];a<=f[d];a++)B("var "+(c=T([d,a+f[d]-1]))+" = "+A(d)+" + "+a+";");if("clamped"===v[d])for(a=1-f[d];a<=f[d];a++)c=T([d,a+f[d]-1]),a<0&&B("if ("+c+" < "+f[d]+") "+c+" = "+f[d]+";"),a>0&&B("if ("+c+" > "+z(d)+") "+c+" = "+z(d)+";");"closed"===v[d]&&(E("\n  // Wrap the B-Spline parameter for closed boundary"),B(R(d)+" %= "+z(d)+";"))}for(d=0,h=[];d<g;d++)h[d]=f[d]+1;for(m&&(E("\n  // Fetch weights\n"),rt(h,(function(t){for(var e=[],i=[],n=0;n<g;n++)e[n]=[A(n),t[n]-f[n]],"closed"===v[n]&&t[n]-f[n]<0&&(i[n]=z(n));B("var "+j(t)+" = "+D(e,i)+";")}))),n&&B(m?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),rt(h,(function(t){for(var e=[],i=[],n=0;n<g;n++)e[n]=[A(n),t[n]-f[n]],"closed"===v[n]&&t[n]-f[n]<0&&(i[n]=z(n));if(s)B(m?"var "+V(t)+" = "+P(e,i)+" * "+j(t)+";":"var "+V(t)+" = "+P(e,i)+";");else for(n=0;n<y;n++){var o=t.concat(n);e[g]=n,B(m?"var "+V(o)+" = "+P(e,i)+" * "+j(t)+";":"var "+V(o)+" = "+P(e,i)+";")}})),E("\n"),E('// Perform De Boor"s algorithm'),d=h.length-1;d>=0;d--)for(h[d]=[f[d],f[d]+1],a=0;a<f[d];a++)for(E("\n  // Degree "+f[d]+" evaluation in dimension "+d+", step "+(a+1)+"\n"),l=f[d];l>a;l--){var Y=r&&f[d]-a-r[d]<=0;Y?(B("m = 1 / ("+T([d,l-a+f[d]-1])+" - "+T([d,l-1])+");"),m&&(B("a = ("+R(d)+" - "+T([d,l-1])+") * m;"),B("b = 1 - a;"))):(B("a = ("+R(d)+" - "+T([d,l-1])+") / ("+T([d,l-a+f[d]-1])+" - "+T([d,l-1])+");"),B("b = 1 - a;")),m&&rt(h,(function(t){var e=t.slice(),i=t.slice();e[d]=l,i[d]=l-1,Y&&m&&B("h = "+j(e)+";"),B(j(e)+" = b * "+j(i)+" + a * "+j(e)+";")})),rt(h,(function(t){var e,i,n,o=t.slice(),r=t.slice();if(o[d]=l,r[d]=l-1,Y){var h=a+1;if(s)e=m?"h * "+j(r)+" / "+j(o)+" * ":"",i=V(o)+(m?" / h":""),n=V(r)+(m?" / "+j(r):""),B(V(o)+" = "+h+" * "+e+"("+i+" - "+n+") * m;");else{var c=o.slice(),p=r.slice();for(u=0;u<y;u++)c[g]=p[g]=u,e=m?"h * "+j(r)+" / "+j(o)+" * ":"",i=V(c)+(m?" / h":""),n=V(p)+(m?" / "+j(r):""),B(V(c)+" = "+h+" * "+e+"("+i+" - "+n+") * m;")}}else if(s)B(V(o)+" = b * "+V(r)+" + a * "+V(o)+";");else for(u=0;u<y;u++)o[g]=r[g]=u,B(V(o)+" = b * "+V(r)+" + a * "+V(o)+";")})),E("\n")}if(n&&B(m?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),s)B(m?"return "+V(f)+" / "+j(f)+";":"return "+V(f)+";");else for(d=0;d<y;d++)B(m?"out["+d+"] = "+V(f.concat([d]))+" / "+j(f)+";":"out["+d+"] = "+V(f.concat([d]))+";");if(s||B("return out;"),N.push("}"),n){var X=N.join("\n");O(X),ut[t]=X}var q=new Function([N.join("\n"),"; return ",S].join(""))();return ht[t]=q,q.bind(e)}));var ct={};const gt=m().add("transform",(function(t,e,i,n){var o,s,r,a,l,h,u,d,c=ct[t];if(c)return c.bind(e);var g=[],p="transform"+t;g.push("function "+p+"(m) {"),g.push("var i, w;"),g.push(at(e,"x","this.points",e.points));var f=Z(n?"size":"s");for(o=0;o<e.splineDimension;o++)g.push("var "+f(o)+" = "+lt(e.points,"this.points",o)+";");for(a=[],o=0;o<e.splineDimension;o++)r="i"+o,a.push(r),g.push("for ("+r+" = "+f(o)+"- 1; "+r+" >= 0; "+r+"--) {");for(o=0;o<e.dimension;o++)g.push("x"+o+" = "+i.point(a.concat([o])));for(l=[],o=0;o<e.dimension;o++)l.push("m["+((e.dimension+1)*(o+1)-1)+"] * x"+o);for(l.push("m["+((e.dimension+1)*(e.dimension+1)-1)+"]"),g.push("var w = ("+l.join(" + ")+") || 1.0;"),o=0;o<e.dimension;o++){for(l=[],h=e.dimension,s=0;s<h;s++)l.push("m["+(s*(h+1)+o)+"] * x"+s);l.push("m["+(s*(h+1)+o)+"]"),d=i.point(a.concat([o])),u="("+l.join(" + ")+") / w",g.push(d+" = "+u+";")}for(o=e.splineDimension-1;o>=0;o--)g.push("}");g.push("return this;"),g.push("}");var _=new Function([g.join("\n"),"; return ",p].join(""))();return n&&console.log(g.join("\n")),ct[t]=_,_.bind(e)}));var pt={};const ft=m().add("support",(function(t,e,i,n,o){var s=pt[t];if(s)return s.bind(e);var r,a,l,h=e.degree,u=e.knots,d=e.splineDimension,c=e.boundary,g=[],p="support"+t,f=i.knot,_=Z("t"),m=n?"domain":"d",w=Z(n?"size":"s"),y=Z(n?"knotIndex":"i"),v=!0;for(l=0;l<d;l++)W(u)&&W(u[l])&&(v=!1);function b(t){g.push("  "+(t||""))}var C=[];for(r=0;r<d;r++)C.push(_([r]));g.push("function "+p+" (out, "+C.join(", ")+") {");var O=0;function N(t,e){b(void 0===e?"out["+O+++"] = "+t.join(" + ")+";":"out["+O+++"] = ("+t.join(" + ")+" + "+e+") % "+e+";")}for(b("var h, m;"),b("var c = 0;"),o&&(b("var "+m+" = this.domain;"),b("for (var i = 0; i < this.splineDimension; i++) {"),b("  a = arguments[i + 1];"),b("  if (a < "+m+"[i][0] || a > "+m+"[i][1] || a === undefined || isNaN(a)) {"),b('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+m+'[i][0]+", "+'+m+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),b("  }"),b("}")),l=0;l<d;l++)b("var "+w(l)+" = "+lt(e.points,"this.points",l)+";");v||g.push(at(e,"k","this.knots",u));var S=[];for(l=0;l<d;l++)switch(L(u)){case L.NDARRAY:S[l]=!0;break;case L.ARRAY_OF_ARRAYS:S[l]=W(u[l])}for(l=0;l<d;l++)S[l]?(b("var "+y(l)+" = 0;"),b("h = "+w(l)+";"),b("while(h > "+y(l)+" + 1) {"),b("  m = 0.5 * (h + "+y(l)+") | 0;"),b("  if ("+f([l,"m"])+" > "+_(l)+") h = m;"),b("  else "+y(l)+" = m;"),b("}")):"closed"===c[l]?b(y(l)+" = ("+_(l)+" | 0) % "+w(l)+";"):(b(y(l)+" = ("+_(l)+" | 0);"),b("if ("+y(l)+" < "+h[l]+") "+y(l)+" = "+h[l]+";"),b("if ("+y(l)+" > "+w(l)+" - 1) "+y(l)+" = "+w(l)+" - 1;"));for(l=0,a=[];l<d;l++)a[l]=h[l]+1;rt(a,(function(t){for(var e=[],i=[],n=0;n<d;n++)e[n]=[y(n),t[n]-h[n]],"closed"===c[n]&&t[n]-h[n]<0&&(i[n]=w(n));for(n=0;n<d;n++)N(e[n],i[n])})),b("out.length = "+O+";"),b("return out;"),g.push("}"),n&&console.log(g.join("\n"));var P=new Function([g.join("\n"),"; return ",p].join(""))();return pt[t]=P,P.bind(e)})),_t=[],mt=new Map,wt=new Map;function yt(t,e,i,n,o,s,r){for(let a=0;a<i;++a){bt(t+e*a,n,o,s,r)}}function vt(t,e,i,n,o,s,r){for(let i=0;i<e;++i){bt(i+e*t,n,o,s,r)}}function bt(t,e,i,n,o){let s="";for(let n=0;n<e;++n)s+=i[t*e+n],s+=";";n.has(s)?o.set(t,n.get(s)):n.set(s,t)}const Ct=function(t,e,i){const n=t.points??=[],o=t.faces??=[],s=i.haveWeights,r=e.dimension-s,a=i.resolution;switch(e.splineDimension){case 1:{const t=a[0],o=t+1,l=o*r,h=e.domain[0],u=h[1]-h[0],d=i.closed;for(let i=0;i<o;++i){const o=h[0]+u*(d?i%t:i)/t,a=i*r;if(e.evaluate(_t,o),s){const t=_t[r];for(let e=0;e<r;++e)n[a+e]=_t[e]/t}else for(let t=0;t<r;++t)n[a+t]=_t[t]}n.length=l;break}case 2:{const t=a[0],l=a[1],h=t+1,u=l+1,d=h*u*r,c=e.domain,g=c[0],p=c[1],f=g[1]-g[0],_=p[1]-p[0],m=i.closed[0],w=i.closed[1];for(let i=0;i<u;++i){const o=p[0]+_*i/l;for(let a=0;a<h;++a){const l=g[0]+f*a/t,u=(a+h*i)*r;if(e.evaluate(_t,l,o),s){const t=_t[r];for(let e=0;e<r;++e)n[u+e]=_t[e]/t}else for(let t=0;t<r;++t)n[u+t]=_t[t]}}n.length=d,yt(0,h,u,r,n,mt,wt),vt(0,h,u,r,n,mt,wt),m||yt(t,h,u,r,n,mt,wt),w||vt(l,h,u,r,n,mt,wt);let y=0;for(let e=0;e<l;++e){const i=w?(e+1)%l:e+1;for(let n=0;n<t;++n){const s=m?(n+1)%t:n+1;let r=n+h*e,a=s+h*e,l=s+h*i,u=n+h*i;r=wt.get(r)??r,a=wt.get(a)??a,l=wt.get(l)??l,u=wt.get(u)??u,o[y++]=r,o[y++]=a,o[y++]=l,o[y++]=r,o[y++]=l,o[y++]=u}}o.length=y,mt.clear(),wt.clear();break}default:throw new Error("Can only sample contours and surfaces.")}return t},Ot=m().add("sample",Ct);var Nt={open:"open",closed:"closed",clamped:"clamped"};function St(t){return null==t}function Pt(t,e,i,n,o,s){var r,a;!t||W(t)||G(t)?(s=s||{},this.weights=n,this.knots=i,this.degree=e,this.points=t,this.boundary=o,this.debug=s.debug,this.checkBounds=!!s.checkBounds,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0})):(s=t,this.debug=t.debug,this.checkBounds=!!t.checkBounds,this.weights=t.weights,this.knots=t.knots,this.degree=t.degree,this.boundary=t.boundary,this.points=t.points,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0}));var l=L(this.points),h=L(this.weights),u=L(this.knots);if(this.points)switch(l){case L.GENERIC_NDARRAY:case L.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case L.ARRAY_OF_OBJECTS:case L.ARRAY_OF_ARRAYS:var d=0,c=this.size||[];c.length=0;for(var g=this.points;W(g[0]);g=g[0])d++,c.push(g.length);if(0===d)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:d,writable:!1,configurable:!0},dimension:{value:g.length,writable:!1,configurable:!0},size:{get:function(){var t=[];t.length=0;for(var e=0,i=this.points;e<this.splineDimension;e++,i=i[0])t[e]=i.length;return t},set:function(){throw new Error('Cannot assign to read only property "size"')},configurable:!0}});break;case L.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(W(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(W(this.degree)){for(r=0;r<this.splineDimension;r++)if(St(this.degree[r]))throw new Error("Missing degree in dimension "+(r+1))}else{var p=!St(this.degree),f=St(this.degree)?2:this.degree;for(this.degree=[],r=0;r<this.splineDimension;r++)if(this.size[r]<=f){if(p)throw new Error("Expected at least "+(f+1)+" points for degree "+f+" spline in dimension "+(r+1)+" but got only "+this.size[r]);this.degree[r]=this.size[r]-1}else this.degree[r]=f}if(a="string"!=typeof this.boundary?"open":this.boundary,!Nt[a])throw new Error("Boundary type must be one of "+Object.keys(Nt)+". Got "+a);for(this.boundary=W(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,r=0;r<this.splineDimension;r++)if(this.boundary[r]=St(this.boundary[r])?a:this.boundary[r],!Nt[a])throw new Error("Boundary type must be one of "+Object.keys(Nt)+". Got "+a+" for dimension "+(r+1));switch(u){case L.ARRAY_OF_ARRAYS:for(W(this.knots)&&this.knots.length>0&&!W(this.knots[0])&&(this.knots=[this.knots]),r=0;r<this.splineDimension;r++){if(this.size[r]<=this.degree[r])throw new Error("Expected at least "+(this.degree[r]+1)+" points in dimension "+(r+1)+" but got "+this.size[r]+".");if(W(this.knots[r])){if("closed"!==this.boundary[r]&&this.knots[r].length!==this.degree[r]+this.size[r]+1)throw new Error("Expected "+(this.degree[r]+this.size[r]+1)+" knots in dimension "+(r+1)+" but got "+this.knots[r].length+".");if("closed"===this.boundary[r]&&this.knots[r].length!==this.size[r]+1&&!(this.knots[r].length===this.size[r]+this.degree[r]+1))throw new Error("Expected "+(this.size[r]+1)+" knots for closed spline in dimension "+(r+1)+" but got "+this.knots[r].length+".")}}case L.NDARRAY:}var _=J(this,this.debug,this.checkBounds,l,h,u);if(_!==this.__cacheKey){this.__cacheKey=_;var m=it(this);this.evaluate=dt(this.__cacheKey,this,m,this.debug,this.checkBounds,!1),this.transform=gt(this.__cacheKey,this,m,this.debug),this.support=ft(this.__cacheKey,this,m,this.debug,this.checkBounds),this.evaluator=function(t,e){return dt(this.__cacheKey,this,m,this.debug,this.checkBounds,e,t)}}return this.numericalDerivative=st.bind(this),this}function Dt(){var t,e=[],i=this.points;i?Y(i)&&(t=i.shape):t=this.size;for(var n=0;n<this.splineDimension;n++){var o=t?t[n]:i.length,s=this.degree[n],r="closed"===this.boundary[n];if(this.knots&&this.knots[n]){var a=this.knots[n];e[n]=[a[r?0:s],a[o]]}else e[n]=[r?0:s,o];i&&(i=i[0])}return e}function Ft(t,e,i,n,o,s){var r=function(t,e,i,n,o,s){return a(t,e,i,n,o,s),r},a=Pt.bind(r);return Object.defineProperty(r,"domain",{get:Dt}),a(t,e,i,n,o,s),r}Ft.sample=Ot;const Tt=Ft,Vt=m().add("nurbs",Tt);function jt(t){M.call(this,t),U().call(this,t),this.addType(g().NurbsCurve),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]}}Object.assign(Object.setPrototypeOf(jt.prototype,M.prototype),U().prototype,{initialize(){M.prototype.initialize.call(this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode?.removeInterest("requestRebuild",this),this.controlPointNode=f()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode?.addInterest("requestRebuild",this)},getTessellation(t){return k.getTessellation(this._tessellation.getValue(),t)},getClosed(t,e,i,n){return!!this._closed.getValue()&&k.getClosed(t,e,i,n)},getWeights:(t,e,i)=>k.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>k.getControlPoints(t,e,i,n,o),getSurface(){return this.surface},tessellate(){if(this._order.getValue()<2)return[];if(!this.controlPointNode)return[];if(this.controlPointNode.getSize()<this._order.getValue())return[];const t=this.getVertices(),e=t.length,i=[];if(e){for(let n=0;n<e;n+=8)i.push(t[n],t[n+1],t[n+2]);i.push(t[e-4],t[e-3],t[e-2])}return i},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),n=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=(n.at(-1),n[0],this._order.getValue()-1);this.surface=(this.surface??Vt)({boundary:["open"],degree:[o],knots:[n],points:i,debug:!1}),this.sampleOptions.resolution[0]=this.getTessellation(this.controlPointNode.getSize()),this.sampleOptions.closed=t,this.sampleOptions.haveWeights=!!e;const s=Vt.sample(this.mesh,this.surface,this.sampleOptions).points,r=s.length-3,a=this.getVertices();for(let t=0;t<r;t+=3)a.push(s[t+0],s[t+1],s[t+2],1,s[t+3],s[t+4],s[t+5],1)},dispose(){M.prototype.dispose.call(this)}}),Object.defineProperties(jt,{...d().getStaticProperties("NurbsCurve","NURBS",1,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOutput,"tessellation",new(s().SFInt32)),new(a())(g().initializeOnly,"closed",new(s().SFBool)),new(a())(g().initializeOnly,"order",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"knot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"controlPoint",new(s().SFNode))]),enumerable:!0}});const xt=jt,Rt=m().add("NurbsCurve",xt);function It(t){N.call(this,t),this.addType(g().NurbsCurve2D),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]},this.array=[]}Object.assign(Object.setPrototypeOf(It.prototype,N.prototype),{getTessellation(t){return k.getTessellation(this._tessellation.getValue(),t)},getClosed(t,e,i,n){return!!this._closed.getValue()&&k.getClosed2D(t,e,i,n)},getKnots:(t,e,i,n,o)=>k.getKnots(t,e,i,n,o),getWeights:(t,e,i)=>k.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>k.getControlPoints2D(t,e,i,n,o),tessellate(t,e=this.array){if(this._order.getValue()<2)return e;if(this._controlPoint.length<this._order.getValue())return e;const i=this.getClosed(this._order.getValue(),this._knot,this._weight,this._controlPoint),n=this.getWeights(this.weights,this._controlPoint.length,this._weight),o=this.getControlPoints(this.controlPoints,i,this._order.getValue(),n,this._controlPoint),s=this.getKnots(this.knots,i,this._order.getValue(),this._controlPoint.length,this._knot),r=(s.at(-1),s[0],this._order.getValue()-1);this.surface=(this.surface??Vt)({boundary:["open"],degree:[r],knots:[s],points:o,debug:!1}),this.sampleOptions.resolution[0]=this.getTessellation(this._controlPoint.length),this.sampleOptions.closed=i,this.sampleOptions.haveWeights=!!n;const a=Vt.sample(this.mesh,this.surface,this.sampleOptions).points,l=a.length;switch(t){case 0:e.length=0;for(const t of a)e.push(t);break;case 1:e.length=0;for(let t=0;t<l;t+=2)e.push(a[t],0,a[t+1]);break;case 2:for(let t=0;t<l;t+=2)e.push(new(P())(a[t],a[t+1],0))}return e}}),Object.defineProperties(It,{...d().getStaticProperties("NurbsCurve2D","NURBS",3,"children","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOutput,"tessellation",new(s().SFInt32)),new(a())(g().initializeOnly,"closed",new(s().SFBool)),new(a())(g().initializeOnly,"order",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"knot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"controlPoint",new(s().MFVec2d))]),enumerable:!0}});const zt=It,At=m().add("NurbsCurve2D",zt),kt=t.X3DChildNode;var Bt=e.n(kt);const Et=t.Rotation4;var Mt=e.n(Et);const Kt=t.Algorithm;var Ut=e.n(Kt);function Gt(t){Bt().call(this,t),this.addType(g().NurbsOrientationInterpolator),this.geometry=new Rt(t)}Object.assign(Object.setPrototypeOf(Gt.prototype,Bt().prototype),{initialize(){Bt().prototype.initialize.call(this),this._set_fraction.addInterest("set_fraction__",this),this._order.addFieldInterest(this.geometry._order),this._knot.addFieldInterest(this.geometry._knot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._tessellation=1,this.geometry._order=this._order,this.geometry._knot=this._knot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry._rebuild.addInterest("set_geometry__",this),this.geometry.setup(),this.set_geometry__()},set_geometry__(){const t=this.geometry.getSurface();t?(delete this.set_fraction__,this.derivative=t.evaluator(1)):this.set_fraction__=Function.prototype},set_fraction__:(()=>{const t=new(P()),e=new(Mt());return function(){const i=Ut().clamp(this._set_fraction.getValue(),0,1),n=this.geometry.getSurface().domain[0],o=Ut().project(i,0,1,...n);this.derivative(t,o),this._value_changed=e.setFromToVec(P().zAxis,t)}})()}),Object.defineProperties(Gt,{...d().getStaticProperties("NurbsOrientationInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOnly,"set_fraction",new(s().SFFloat)),new(a())(g().inputOutput,"order",new(s().SFInt32)(3)),new(a())(g().inputOutput,"knot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"controlPoint",new(s().SFNode)),new(a())(g().outputOnly,"value_changed",new(s().SFRotation))]),enumerable:!0}});const Yt=Gt,Wt=m().add("NurbsOrientationInterpolator",Yt),Xt=t.Triangle3;var qt=e.n(Xt);function Lt(t){M.call(this,t),this.addType(g().X3DNurbsSurfaceGeometryNode),this.tessellationScale=1,this.uKnots=[],this.vKnots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[],closed:[]},this.textUKnots=[],this.textVKnots=[],this.textWeights=[],this.texControlPoints=[],this.texMesh={}}Object.assign(Object.setPrototypeOf(Lt.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._texCoord.addInterest("set_texCoord__",this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_texCoord__(),this.set_controlPoint__()},set_texCoord__(){this.texCoordNode?.removeInterest("requestRebuild",this),this.nurbsTexCoordNode?.removeInterest("requestRebuild",this),this.texCoordNode=f()(g().X3DTextureCoordinateNode,this._texCoord),this.nurbsTexCoordNode=f()(g().NurbsTextureCoordinate,this._texCoord),this.texCoordNode?.addInterest("requestRebuild",this),this.nurbsTexCoordNode?.addInterest("requestRebuild",this)},set_controlPoint__(){this.controlPointNode?.removeInterest("requestRebuild",this),this.controlPointNode=f()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode?.addInterest("requestRebuild",this)},setTessellationScale(t){this.tessellationScale=t,this.requestRebuild()},getUTessellation(){return Math.floor(k.getTessellation(this._uTessellation.getValue(),this._uDimension.getValue())*this.tessellationScale)},getVTessellation(t){return Math.floor(k.getTessellation(this._vTessellation.getValue(),this._vDimension.getValue())*this.tessellationScale)},getUClosed(t,e,i,n,o,s){return!!this._uClosed.getValue()&&k.getUClosed(t,e,i,n,o,s)},getVClosed(t,e,i,n,o,s){return!!this._vClosed.getValue()&&k.getVClosed(t,e,i,n,o,s)},getUVWeights:(t,e,i,n)=>k.getUVWeights(t,e,i,n),getTexControlPoints:(t,e,i,n,o,s,r,a)=>k.getTexControlPoints(t,e,i,n,o,s,r,a),getUVControlPoints:(t,e,i,n,o,s,r,a,l)=>k.getUVControlPoints(t,e,i,n,o,s,r,a,l),getSurface(){return this.surface},trimSurface(){},build(){if(this._uOrder.getValue()<2)return;if(this._vOrder.getValue()<2)return;if(this._uDimension.getValue()<this._uOrder.getValue())return;if(this._vDimension.getValue()<this._vOrder.getValue())return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._uDimension.getValue()*this._vDimension.getValue())return;const t=this.getUClosed(this._uOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._uKnot,this._weight,this.controlPointNode),e=this.getVClosed(this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._vKnot,this._weight,this.controlPointNode),i=this.getUVWeights(this.weights,this._uDimension.getValue(),this._vDimension.getValue(),this._weight),n=this.getUVControlPoints(this.controlPoints,t,e,this._uOrder.getValue(),this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),i,this.controlPointNode),o=this.getKnots(this.uKnots,t,this._uOrder.getValue(),this._uDimension.getValue(),this._uKnot),s=this.getKnots(this.vKnots,e,this._vOrder.getValue(),this._vDimension.getValue(),this._vKnot),r=(o.at(-1),o[0],s.at(-1),s[0],this._uOrder.getValue()-1),a=this._vOrder.getValue()-1;this.surface=(this.surface??Vt)({boundary:["open","open"],degree:[r,a],knots:[o,s],points:n,debug:!1});const l=this.sampleOptions;l.resolution[0]=this.getUTessellation(),l.resolution[1]=this.getVTessellation(),l.closed[0]=t,l.closed[1]=e,l.haveWeights=!!i;const h=Vt.sample(this.mesh,this.surface,l),u=h.faces,d=h.points,c=this.getVertices();for(const t of u){const e=3*t;c.push(d[e],d[e+1],d[e+2],1)}this.buildNurbsTexCoords(t,e,this._uOrder.getValue(),this._vOrder.getValue(),o,s,this._uDimension.getValue(),this._vDimension.getValue()),this.generateNormals(u,d),this.trimSurface(o,s),this.setSolid(this._solid.getValue()),this.setCCW(!0)},buildNurbsTexCoords(t,e,i,n,o,s,r,a){const l=this.getMultiTexCoords();if(this.texCoordNode){this.texCoordNode.init(l);const h=this.texCoordNode.getTextureCoordinates?.(),u=l.length;for(let d=0;d<u;++d){const u=l[d],c=h?.[d]??this.texCoordNode,g=i-1,p=n-1,f=o,_=s,m=this.getTexControlPoints(this.texControlPoints,t,e,i,n,r,a,c);this.createNurbsTexCoords(g,p,f,_,m,u)}}else if(this.nurbsTexCoordNode?.isValid()){const t=this.nurbsTexCoordNode,e=t._uOrder.getValue()-1,i=t._vOrder.getValue()-1,n=this.getKnots(this.texUKnots,!1,t._uOrder.getValue(),t._uDimension.getValue(),t._uKnot),o=this.getKnots(this.texVKnots,!1,t._vOrder.getValue(),t._vDimension.getValue(),t._vKnot),s=this.getUVWeights(this.texWeights,t._uDimension.getValue(),t._vDimension.getValue(),t._weight),r=t.getControlPoints(s),a=this.getTexCoords();l.push(a),this.createNurbsTexCoords(e,i,n,o,r,a)}else{const t=this.getTexCoords();l.push(t),this.createDefaultNurbsTexCoords(t)}},createDefaultNurbsTexCoords:(()=>{const t=[0,0,5,5],e=[[[0,0,0,1],[0,1,0,1]],[[1,0,0,1],[1,1,0,1]]];return function(i){const n=t,o=t,s=e;return this.createNurbsTexCoords(1,1,n,o,s,i)}})(),createNurbsTexCoords(t,e,i,n,o,s){this.texSurface=(this.texSurface??Vt)({boundary:["open","open"],degree:[t,e],knots:[i,n],points:o});const r=this.sampleOptions;r.closed[0]=!1,r.closed[1]=!1,r.haveWeights=!1;const a=Vt.sample(this.texMesh,this.texSurface,r),l=a.faces,h=a.points;for(const t of l){const e=4*t;s.push(h[e],h[e+1],h[e+2],h[e+3])}return s},generateNormals(t,e){const i=this.createNormals(t,e),n=this.getNormals();for(const{x:t,y:e,z:o}of i)n.push(t,e,o)},createNormals(t,e){const i=new Map,n=this.createFaceNormals(t,e),o=t.length;for(let e=0;e<o;++e){const n=t[e];let o=i.get(n);o||i.set(n,o=[]),o.push(e)}return this.refineNormals(i,n,Ut().radians(85))},createFaceNormals:(()=>{const t=new(P()),e=new(P()),i=new(P());return function(n,o){const s=this.faceNormals??[],r=n.length;for(let a=0;a<r;a+=3){const r=3*n[a],l=3*n[a+1],h=3*n[a+2];t.set(o[r],o[r+1],o[r+2]),e.set(o[l],o[l+1],o[l+2]),i.set(o[h],o[h+1],o[h+2]);const u=qt().normal(t,e,i,s[a]??new(P()));s[a]=u,s[a+1]=u,s[a+2]=u}return s.length=r,s}})()}),Object.defineProperties(Lt,d().getStaticProperties("X3DNurbsSurfaceGeometryNode","NURBS",1));const Jt=Lt,Ht=m().add("X3DNurbsSurfaceGeometryNode",Jt);function Qt(t){Ht.call(this,t),this.addType(g().NurbsPatchSurface)}Object.setPrototypeOf(Qt.prototype,Ht.prototype),Object.defineProperties(Qt,{...d().getStaticProperties("NurbsPatchSurface","NURBS",1,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOutput,"uTessellation",new(s().SFInt32)),new(a())(g().inputOutput,"vTessellation",new(s().SFInt32)),new(a())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(a())(g().initializeOnly,"uClosed",new(s().SFBool)),new(a())(g().initializeOnly,"vClosed",new(s().SFBool)),new(a())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(a())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"texCoord",new(s().SFNode)),new(a())(g().inputOutput,"controlPoint",new(s().SFNode))]),enumerable:!0}});const Zt=Qt,$t=m().add("NurbsPatchSurface",Zt);function te(t){Bt().call(this,t),this.addType(g().NurbsPositionInterpolator),this.geometry=new Rt(t)}Object.assign(Object.setPrototypeOf(te.prototype,Bt().prototype),{initialize(){Bt().prototype.initialize.call(this),this._set_fraction.addInterest("set_fraction__",this),this._order.addFieldInterest(this.geometry._order),this._knot.addFieldInterest(this.geometry._knot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._tessellation=1,this.geometry._order=this._order,this.geometry._knot=this._knot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry._rebuild.addInterest("set_geometry__",this),this.geometry.setup(),this.set_geometry__()},set_geometry__(){this.geometry.getSurface()?delete this.set_fraction__:this.set_fraction__=Function.prototype},set_fraction__:(()=>{const t=new(P());return function(){const e=Ut().clamp(this._set_fraction.getValue(),0,1),i=this.geometry.getSurface(),n=i.domain[0],o=Ut().project(e,0,1,...n);i.evaluate(t,o),this._value_changed=t}})()}),Object.defineProperties(te,{...d().getStaticProperties("NurbsPositionInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOnly,"set_fraction",new(s().SFFloat)),new(a())(g().inputOutput,"order",new(s().SFInt32)(3)),new(a())(g().inputOutput,"knot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"controlPoint",new(s().SFNode)),new(a())(g().outputOnly,"value_changed",new(s().SFVec3f))]),enumerable:!0}});const ee=te,ie=m().add("NurbsPositionInterpolator",ee),ne=t.X3DBoundedObject;var oe=e.n(ne);function se(t){Bt().call(this,t),oe().call(this,t),this.addType(g().NurbsSet),this.geometryNodes=[]}function re(t,e){const i=new Set(e);return t.filter((t=>!i.has(t)))}Object.assign(Object.setPrototypeOf(se.prototype,Bt().prototype),oe().prototype,{initialize(){Bt().prototype.initialize.call(this),oe().prototype.initialize.call(this),this._tessellationScale.addInterest("set_tessellationScale__",this),this._addGeometry.addInterest("set_addGeometry__",this),this._removeGeometry.addInterest("set_removeGeometry__",this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},getBBox(t,e){for(const e of this.geometryNodes)t.add(e.getBBox());return t},set_tessellationScale__(){const t=Math.max(0,this._tessellationScale.getValue());for(const e of this.geometryNodes)e.setTessellationScale(t)},set_addGeometry__(){this._addGeometry.setTainted(!0),this._addGeometry.assign(re(this._addGeometry,this._geometry));for(const t of this._addGeometry)this._geometry.push(t);this._addGeometry.length=0,this._addGeometry.setTainted(!1)},set_removeGeometry__(){this._removeGeometry.setTainted(!0),this._geometry.assign(re(this._geometry,this._removeGeometry)),this._removeGeometry.length=0,this._removeGeometry.setTainted(!1)},set_geometry__(){for(const t of this.geometryNodes)t.setTessellationScale(1);this.geometryNodes.length=0;for(const t of this._geometry){const e=f()(g().X3DNurbsSurfaceGeometryNode,t);e&&this.geometryNodes.push(e)}this.set_tessellationScale__()},dispose(){oe().prototype.dispose.call(this),Bt().prototype.dispose.call(this)}}),Object.defineProperties(se,{...d().getStaticProperties("NurbsSet","NURBS",2,"children","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOutput,"tessellationScale",new(s().SFFloat)(1)),new(a())(g().inputOutput,"visible",new(s().SFBool)(!0)),new(a())(g().inputOutput,"bboxDisplay",new(s().SFBool)),new(a())(g().initializeOnly,"bboxSize",new(s().SFVec3f)(-1,-1,-1)),new(a())(g().initializeOnly,"bboxCenter",new(s().SFVec3f)),new(a())(g().inputOnly,"addGeometry",new(s().MFNode)),new(a())(g().inputOnly,"removeGeometry",new(s().MFNode)),new(a())(g().inputOutput,"geometry",new(s().MFNode))]),enumerable:!0}});const ae=se,le=m().add("NurbsSet",ae);function he(t){Bt().call(this,t),this.addType(g().NurbsSurfaceInterpolator),this.geometry=new $t(t)}Object.assign(Object.setPrototypeOf(he.prototype,Bt().prototype),{initialize(){Bt().prototype.initialize.call(this),this._set_fraction.addInterest("set_fraction__",this),this._uOrder.addFieldInterest(this.geometry._uOrder),this._vOrder.addFieldInterest(this.geometry._vOrder),this._uDimension.addFieldInterest(this.geometry._uDimension),this._vDimension.addFieldInterest(this.geometry._vDimension),this._uKnot.addFieldInterest(this.geometry._uKnot),this._vKnot.addFieldInterest(this.geometry._vKnot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._uTessellation=1,this.geometry._vTessellation=1,this.geometry._uOrder=this._uOrder,this.geometry._vOrder=this._vOrder,this.geometry._uDimension=this._uDimension,this.geometry._vDimension=this._vDimension,this.geometry._uKnot=this._uKnot,this.geometry._vKnot=this._vKnot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry._rebuild.addInterest("set_geometry__",this),this.geometry.setup(),this.set_geometry__()},set_geometry__(){const t=this.geometry.getSurface();t?(delete this.set_fraction__,this.uDerivative=t.evaluator([1,0]),this.vDerivative=t.evaluator([0,1])):this.set_fraction__=Function.prototype},set_fraction__:(()=>{const t=new(P()),e=new(P()),i=new(P());return function(){const n=this._set_fraction.getValue(),o=Ut().clamp(n.x,0,1),s=Ut().clamp(n.y,0,1),r=this.geometry.getSurface(),a=r.domain[0],l=r.domain[1],h=Ut().project(o,0,1,...a),u=Ut().project(s,0,1,...l);this.uDerivative(t,h,u),this.vDerivative(e,h,u),r.evaluate(i,h,u),this._normal_changed=t.cross(e),this._position_changed=i}})()}),Object.defineProperties(he,{...d().getStaticProperties("NurbsSurfaceInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOnly,"set_fraction",new(s().SFVec2f)),new(a())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(a())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"controlPoint",new(s().SFNode)),new(a())(g().outputOnly,"normal_changed",new(s().SFVec3f)),new(a())(g().outputOnly,"position_changed",new(s().SFVec3f))]),enumerable:!0}});const ue=he,de=m().add("NurbsSurfaceInterpolator",ue),ce=t.Extrusion;var ge=e.n(ce);function pe(t){M.call(this,t),this.addType(g().NurbsSweptSurface),this.extrusion=new(ge())(t)}Object.assign(Object.setPrototypeOf(pe.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._crossSectionCurve.addInterest("set_crossSectionCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_crossSectionCurve__(),this.set_trajectoryCurve__()},getTrajectoryCurve(){return this.trajectoryCurveNode},set_crossSectionCurve__(){this.crossSectionCurveNode?.removeInterest("requestRebuild",this),this.crossSectionCurveNode=f()(g().X3DNurbsControlCurveNode,this._crossSectionCurve),this.crossSectionCurveNode?.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode?._rebuild.removeInterest("requestRebuild",this),this.trajectoryCurveNode=f()(g().NurbsCurve,this._trajectoryCurve),this.trajectoryCurveNode?._rebuild.addInterest("requestRebuild",this)},build(){if(!this.crossSectionCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.crossSectionCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(0),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getTangents().assign(t.getTangents()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals(),e=t.length;for(let i=0;i<e;++i)t[i]*=-1}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(pe,{...d().getStaticProperties("NurbsSweptSurface","NURBS",3,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(a())(g().initializeOnly,"ccw",new(s().SFBool)(!0)),new(a())(g().inputOutput,"crossSectionCurve",new(s().SFNode)),new(a())(g().inputOutput,"trajectoryCurve",new(s().SFNode))]),enumerable:!0}});const fe=pe,_e=m().add("NurbsSweptSurface",fe);function me(t){M.call(this,t),this.addType(g().NurbsSwungSurface),this.extrusion=new(ge())(t)}Object.assign(Object.setPrototypeOf(me.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._profileCurve.addInterest("set_profileCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_profileCurve__(),this.set_trajectoryCurve__()},getTrajectoryCurve(){return this.trajectoryCurveNode},set_profileCurve__(){this.profileCurveNode?.removeInterest("requestRebuild",this),this.profileCurveNode=f()(g().X3DNurbsControlCurveNode,this._profileCurve),this.profileCurveNode?.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode?.removeInterest("requestRebuild",this),this.trajectoryCurveNode=f()(g().X3DNurbsControlCurveNode,this._trajectoryCurve),this.trajectoryCurveNode?.addInterest("requestRebuild",this)},build(){if(!this.profileCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.profileCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(1),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getTangents().assign(t.getTangents()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals(),e=t.length;for(let i=0;i<e;++i)t[i]*=-1}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(me,{...d().getStaticProperties("NurbsSwungSurface","NURBS",3,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(a())(g().initializeOnly,"ccw",new(s().SFBool)(!0)),new(a())(g().inputOutput,"profileCurve",new(s().SFNode)),new(a())(g().inputOutput,"trajectoryCurve",new(s().SFNode))]),enumerable:!0}});const we=me,ye=m().add("NurbsSwungSurface",we);function ve(t){d().call(this,t),this.addType(g().NurbsTextureCoordinate),this.array=[]}Object.assign(Object.setPrototypeOf(ve.prototype,d().prototype),{getControlPoints(t){const e=this._uDimension.getValue(),i=this._vDimension.getValue(),n=this._controlPoint.getValue(),o=this.array;for(let s=0;s<e;++s){const r=o[s]??=[];for(let o=0;o<i;++o){const i=o*e+s,a=r[o]??new(z()),l=2*i;r[o]=a.set(n[l],n[l+1],0,t?t[i]:1)}r.length=i}return o.length=e,o},isValid(){return!(this._uOrder.getValue()<2)&&(!(this._vOrder.getValue()<2)&&(!(this._uDimension.getValue()<this._uOrder.getValue())&&(!(this._vDimension.getValue()<this._vOrder.getValue())&&!(this._controlPoint.length<this._uDimension.getValue()*this._vDimension.getValue()))))}}),Object.defineProperties(ve,{...d().getStaticProperties("NurbsTextureCoordinate","NURBS",1,"texCoord","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(a())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"controlPoint",new(s().MFVec2f))]),enumerable:!0}});const be=ve,Ce=m().add("NurbsTextureCoordinate",be),Oe={area:({x:t,y:e},{x:i,y:n},{x:o,y:s})=>Math.abs(t*(n-s)+i*(s-e)+o*(e-n))/2,isPointInTriangle({x:t,y:e},{x:i,y:n},{x:o,y:s},{x:r,y:a}){const l=(s-a)*(i-r)+(r-o)*(n-a);if(0===l)return!1;const h=((s-a)*(t-r)+(r-o)*(e-a))/l;if(h<0||h>1)return!1;const u=((a-n)*(t-r)+(i-r)*(e-a))/l;if(u<0||u>1)return!1;const d=1-h-u;return!(d<0||d>1)},toBarycentric:function(){const t=new(R()),e=new(R()),i=new(R());return function(n,o,s,r,a){t.assign(s).subtract(o),e.assign(r).subtract(o),i.assign(n).subtract(o);const l=t.dot(t),h=t.dot(e),u=e.dot(e),d=i.dot(t),c=i.dot(e),g=l*u-h*h;return a.v=(u*d-h*c)/g,a.t=(l*c-h*d)/g,a.u=1-a.v-a.t,a}}()},Ne=m().add("Triangle2",Oe),Se=t.libtess;var Pe=e.n(Se);function De(t){Ht.call(this,t),this.addType(g().NurbsTrimmedSurface),this.trimmingContourNodes=[],this.trimmingContours=[]}function Fe(t,e){const i=new Set(e);return t.filter((t=>!i.has(t)))}Object.assign(Object.setPrototypeOf(De.prototype,Ht.prototype),{initialize(){Ht.prototype.initialize.call(this),this._addTrimmingContour.addInterest("set_addTrimmingContour__",this),this._removeTrimmingContour.addInterest("set_removeTrimmingContour__",this),this._trimmingContour.addInterest("set_trimmingContour__",this),this.set_trimmingContour__()},set_addTrimmingContour__(){this._addTrimmingContour.setTainted(!0),this._addTrimmingContour.assign(Fe(this._addTrimmingContour,this._trimmingContour),this._addTrimmingContour.length);for(const t of this._addTrimmingContour)this._trimmingContour.push(t);this._addTrimmingContour.length=0,this._addTrimmingContour.setTainted(!1)},set_removeTrimmingContour__(){this._removeTrimmingContour.setTainted(!0),this._trimmingContour.assign(Fe(this._trimmingContour,this._removeTrimmingContour)),this._removeTrimmingContour.length=0,this._removeTrimmingContour.setTainted(!1)},set_trimmingContour__(){const t=this.trimmingContourNodes;for(const e of t)e.removeInterest("requestRebuild",this);t.length=0;for(const e of this._trimmingContour){const i=f()(g().Contour2D,e);i&&t.push(i)}for(const e of t)e.addInterest("requestRebuild",this)},getTrimmingContours(t,e,i){for(const n of this.trimmingContourNodes)n.addTrimmingContour(t,e,i);return i},trimSurface:function(){const t=[new(P())(0,0,0),new(P())(1,0,0),new(P())(1,1,0),new(P())(0,1,0)];return function(e,i){const n=e.at(0),o=i.at(0),s=e.at(-1)-n,r=i.at(-1)-o,a=new(P())(n,o,0),l=new(P())(s,r,1),h=this.createDefaultNurbsTriangles([]),u=h.length,d=this.getTrimmingContours(a,l,[t]),c=this.triangulatePolygon(d,[],!1),g=c.length,p=[];if(1===d.length)return;for(let t=0;t<u;++t)h[t].index=t;for(let t=0;t<u;t+=3)p.push(h.slice(t,t+3));for(let t=0;t<g;t+=3)p.push(c.slice(t,t+3));const f=this.getMultiTexCoords(),_=this.getNormals(),m=this.getVertices(),w=this.triangulatePolygon(p,[],!0),y=w.length,v=f.length,b=f.map((()=>[])),C=[],O=[],N={};let S=0;for(let t=0;t<y;t+=3){const{[t]:e,[t+1]:i,[t+2]:n}=w;Ne.area(e,i,n)<1e-6||(w[S++]=e,w[S++]=i,w[S++]=n)}w.length=S;t:for(let t=0;t<S;++t){const e=w[t];if(e.hasOwnProperty("index")){const t=e.index,i=3*t,n=4*t;for(let t=0;t<v;++t){const e=f[t],i=b[t],{[n]:o,[n+1]:s,[n+2]:r,[n+3]:a}=e;i.push(o,s,r,a)}const{[i]:o,[i+1]:s,[i+2]:r}=_,{[n]:a,[n+1]:l,[n+2]:h}=m;C.push(o,s,r),O.push(a,l,h,1);continue t}for(let t=0;t<u;t+=3){const{[t]:i,[t+1]:n,[t+2]:o}=h,{u:s,v:r,t:a}=Ne.toBarycentric(e,i,n,o,N);if(Math.abs(s-.5)>.50001)continue;if(Math.abs(r-.5)>.50001)continue;if(Math.abs(a-.5)>.50001)continue;const l=3*t,u=4*t;for(let t=0;t<v;++t){const e=f[t];b[t].push(s*e[u+0]+r*e[u+4]+a*e[u+8],s*e[u+1]+r*e[u+5]+a*e[u+9],s*e[u+2]+r*e[u+6]+a*e[u+10],s*e[u+3]+r*e[u+7]+a*e[u+11])}C.push(s*_[l+0]+r*_[l+3]+a*_[l+6],s*_[l+1]+r*_[l+4]+a*_[l+7],s*_[l+2]+r*_[l+5]+a*_[l+8]),O.push(s*m[u+0]+r*m[u+4]+a*m[u+8],s*m[u+1]+r*m[u+5]+a*m[u+9],s*m[u+2]+r*m[u+6]+a*m[u+10],1);continue t}const i=t%3;for(const t of b)t.length-=4*i;C.length-=3*i,O.length-=4*i,t+=2-i}for(let t=0;t<v;++t)f[t].assign(b[t]);_.assign(C),m.assign(O)}}(),createDefaultNurbsTriangles(t){const e=this.createDefaultNurbsTexCoords([]),i=e.length;for(let n=0;n<i;n+=4)t.push(new(P())(e[n],e[n+1],0));return t},triangulatePolygon:(()=>{function t(t,e,i){return new(P())(...t)}function e(t,[e,i,n,o],s){return n||e.x!==i.x||e.y!==i.y?new(P())(...t):e}const i=new(Pe().GluTesselator);return i.gluTessCallback(Pe().gluEnum.GLU_TESS_VERTEX_DATA,(function(t,e){e.push(t)})),i.gluTessCallback(Pe().gluEnum.GLU_TESS_COMBINE,t),i.gluTessProperty(Pe().gluEnum.GLU_TESS_WINDING_RULE,Pe().windingRule.GLU_TESS_WINDING_ODD),i.gluTessNormal(0,0,1),function(n,o,s){i.gluTessCallback(Pe().gluEnum.GLU_TESS_COMBINE,s?e:t),i.gluTessBeginPolygon(o);for(const t of n){i.gluTessBeginContour();for(const e of t)i.gluTessVertex(e,e);i.gluTessEndContour()}return i.gluTessEndPolygon(),o}})()}),Object.defineProperties(De,{...d().getStaticProperties("NurbsTrimmedSurface","NURBS",4,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(a())(g().inputOutput,"metadata",new(s().SFNode)),new(a())(g().inputOutput,"uTessellation",new(s().SFInt32)),new(a())(g().inputOutput,"vTessellation",new(s().SFInt32)),new(a())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(a())(g().initializeOnly,"uClosed",new(s().SFBool)),new(a())(g().initializeOnly,"vClosed",new(s().SFBool)),new(a())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(a())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(a())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(a())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(a())(g().inputOutput,"weight",new(s().MFDouble)),new(a())(g().inputOutput,"texCoord",new(s().SFNode)),new(a())(g().inputOutput,"controlPoint",new(s().SFNode)),new(a())(g().inputOnly,"addTrimmingContour",new(s().MFNode)),new(a())(g().inputOnly,"removeTrimmingContour",new(s().MFNode)),new(a())(g().inputOutput,"trimmingContour",new(s().MFNode))]),enumerable:!0}});const Te=De,Ve=m().add("NurbsTrimmedSurface",Te);n().add({name:"NURBS",concreteNodes:[b,T,Rt,At,Wt,$t,ie,le,de,_e,ye,Ce,Ve],abstractNodes:[N,Ht,M]});m().add("NURBSComponent",undefined)})();