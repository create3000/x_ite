/* X_ITE v12.0.6 */
const t=window[Symbol.for("X_ITE.X3D-12.0.6")];(()=>{var e={n:t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},d:(t,i)=>{for(var n in i)e.o(i,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const i=t.Components;var n=e.n(i);const o=t.Fields;var s=e.n(o);const r=t.X3DFieldDefinition;var l=e.n(r);const a=t.FieldDefinitionArray;var h=e.n(a);const u=t.X3DNode;var d=e.n(u);const c=t.X3DConstants;var g=e.n(c);const p=t.X3DCast;var f=e.n(p);const _=t.Namespace;var m=e.n(_);function w(t){d().call(this,t),this.addType(g().Contour2D),this.childNodes=[]}function y(t,e){const i=new Set(e);return t.filter(t=>!i.has(t))}Object.assign(Object.setPrototypeOf(w.prototype,d().prototype),{initialize(){d().prototype.initialize.call(this),this._addChildren.addInterest("set_addChildren__",this),this._removeChildren.addInterest("set_removeChildren__",this),this._children.addInterest("set_children__",this),this.set_children__()},set_addChildren__(){this._addChildren.setTainted(!0),this._addChildren.assign(y(this._addChildren,this._children));for(const t of this._addChildren)this._children.push(t);this._addChildren.length=0,this._addChildren.setTainted(!1)},set_removeChildren__(){this._removeChildren.setTainted(!0),this._children.assign(y(this._children,this._removeChildren)),this._removeChildren.length=0,this._removeChildren.setTainted(!1)},set_children__(){const t=this.childNodes;for(const e of t)e.removeInterest("addNodeEvent",this);t.length=0;for(const e of this._children){const i=f()(g().NurbsCurve2D,e)??f()(g().ContourPolyline2D,e);i&&t.push(i)}for(const e of t)e.addInterest("addNodeEvent",this)},addTrimmingContour(t,e,i){const n=[];for(const t of this.childNodes)t.tessellate(2,n);if(n.length){for(const i of n)i.subtract(t).divVec(e);i.push(n)}}}),Object.defineProperties(w,{...d().getStaticProperties("Contour2D","NURBS",4,"trimmingContour","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"addChildren",new(s().MFNode)),new(l())(g().inputOnly,"removeChildren",new(s().MFNode)),new(l())(g().inputOutput,"children",new(s().MFNode))]),enumerable:!0}});const b=w,v=m().add("Contour2D",b);function C(t){d().call(this,t),this.addType(g().X3DNurbsControlCurveNode)}Object.setPrototypeOf(C.prototype,d().prototype),Object.defineProperties(C,d().getStaticProperties("X3DNurbsControlCurveNode","NURBS",1));const O=C,N=m().add("X3DNurbsControlCurveNode",O),S=t.Vector3;var P=e.n(S);function D(t){N.call(this,t),this.addType(g().ContourPolyline2D),this.array=[]}Object.assign(Object.setPrototypeOf(D.prototype,N.prototype),{tessellate(t,e=this.array){const i=this._controlPoint.getValue(),n=2*this._controlPoint.length;switch(t){case 0:e.length=0;for(let t=0;t<n;t+=2)e.push(i[t],i[t+1]);break;case 1:e.length=0;for(let t=0;t<n;t+=2)e.push(i[t],0,i[t+1]);break;case 2:for(let t=0;t<n;t+=2)e.push(new(P())(i[t],i[t+1],0))}return e}}),Object.defineProperties(D,{...d().getStaticProperties("ContourPolyline2D","NURBS",3,"children","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"controlPoint",new(s().MFVec2d))]),enumerable:!0}});const F=D,T=m().add("ContourPolyline2D",F),V=t.X3DGeometryNode;var j=e.n(V);const x=t.Vector2;var R=e.n(x);const I=t.Vector4;var z=e.n(I);const A={getTessellation:(t,e)=>t>0?t:t<0?-t*e:2*e,getClosed2D(t,e,i,n){const o=n.length;return(!(i.length===o)||i[0]===i[o-1])&&!!n[0].equals(n[o-1])},getClosed:(()=>{const t=new(P()),e=new(P());return function(i,n,o,s){const r=s.getSize();return(!(o.length===r)||o[0]===o[r-1])&&!!s.get1Point(0,t).equals(s.get1Point(r-1,e))}})(),getUClosed:(()=>{const t=new(P()),e=new(P());return function(i,n,o,s,r,l){const a=r.length===l.getSize();for(let i=0;i<o;++i){const o=i*n,s=i*n+n-1;if(a&&r[o]!==r[s])return!1;if(!l.get1Point(o,t).equals(l.get1Point(s,e)))return!1}return!0}})(),getVClosed:(()=>{const t=new(P()),e=new(P());return function(i,n,o,s,r,l){const a=r.length===l.getSize();for(let i=0;i<n;++i){const s=i,h=(o-1)*n+i;if(a&&r[s]!==r[h])return!1;if(!l.get1Point(s,t).equals(l.get1Point(h,e)))return!1}return!0}})(),getKnots(t,e,i,n,o){const s=n+i,r=t??[];for(let t=0,e=o.length;t<e;++t)r[t]=o[t];r.length=o.length;let l=!0;if(r.length===s){l=!1;let t=0;for(let e=1;e<s;++e)r[e]===r[e-1]?++t:t=0,t>i-1&&(l=!0),r[e-1]>r[e]&&(l=!0)}if(l){if(e)for(let t=0;t<s;++t)r[t]=t;else{let t=0,e=1;for(;t<i;++t)r[t]=0;for(const n=s-i;t<n;++t,++e)r[t]=e;for(;t<s;++t)r[t]=e}r.length=s;const t=r.at(-1);for(let e=0;e<s;++e)r[e]/=t}if(e){const t=i-1;for(let e=1;e<t;++e)r.push(r.at(-1)+(r[e]-r[e-1]))}return r},getWeights(t,e,i){if(i.length!==e)return;const n=t??[];for(let t=0;t<e;++t)n[t]=i[t];return n.length=e,n},getUVWeights(t,e,i,n){const o=e*i;if(n.length!==o)return;const s=t??[];for(let t=0,o=0;t<e;++t)for(let t=0;t<i;++t,++o)s[o]=n[o];return s.length=o,s},getControlPoints2D(t,e,i,n,o){const s=t??[],r=o.getValue(),l=o.length,a=!!n,h=a?P():R();s.haveWeights!==a&&(s.haveWeights=a,s.length=0);for(let t=0;t<l;++t){const e=2*t;(s[t]??=new h(0,0,0)).set(r[e+0],r[e+1],a?n[t]:0)}if(s.length=l,e){const t=i-1;for(let e=1;e<t;++e)s.push(s[e])}return s},getControlPoints(t,e,i,n,o){const s=t??[],r=o.getSize(),l=!!n,a=l?z():P();s.haveWeights!==l&&(s.haveWeights=l,s.length=0);for(let t=0;t<r;++t){const e=o.get1Point(t,s[t]??=new a(0,0,0,0));l&&(e.w=n[t])}if(s.length=r,e){const t=i-1;for(let e=1;e<t;++e)s.push(s[e])}return s},getUVControlPoints(t,e,i,n,o,s,r,l,a){const h=t??[],u=!!l,d=u?z():P();h.haveWeights!==u&&(h.haveWeights=u,h.length=0);for(let t=0;t<s;++t){const e=h[t]??=[];for(let i=0;i<r;++i){const n=i*s+t;a.get1Point(n,e[i]??=new d(0,0,0,0)),u&&(e[i].w=l[n])}if(e.length=r,i){const t=o-1;for(let i=1;i<t;++i)e.push(e[i])}}if(h.length=s,e){const t=n-1;for(let e=1;e<t;++e)h.push(h[e])}return h},getTexControlPoints(t,e,i,n,o,s,r,l){const a=t??[];for(let t=0;t<s;++t){const e=a[t]??=[];for(let i=0;i<r;++i){const n=i*s+t;l.get1Point(n,e[i]??=new(z()))}if(e.length=r,i){const t=o-1;for(let i=1;i<t;++i)e.push(e[i])}}if(a.length=s,e){const t=n-1;for(let e=1;e<t;++e)a.push(a[e])}return a}},k=m().add("NURBS",A);function B(t){j().call(this,t),this.addType(g().X3DParametricGeometryNode)}Object.assign(Object.setPrototypeOf(B.prototype,j().prototype),{getKnots:(t,e,i,n,o)=>k.getKnots(t,e,i,n,o)}),Object.defineProperties(B,d().getStaticProperties("X3DParametricGeometryNode","NURBS",1));const E=B,M=m().add("X3DParametricGeometryNode",E),K=t.X3DLineGeometryNode;var U=e.n(K);const G=m().add("is-ndarray",function(t){if(!t)return!1;if(!t.dtype)return!1;return new RegExp("function View[0-9]+d(:?"+t.dtype+")+").test(String(t.constructor))}),Y=m().add("is-ndarray-like",function(t){return!!t&&(void 0!==t.data&&Array.isArray(t.shape)&&void 0!==t.offset&&void 0!==t.stride)}),W=m().add("is-array-like",function(t){return Array.isArray(t)||ArrayBuffer.isView(t)||void 0!==t.length});function X(t){if(t){if(G(t)||Y(t))return"generic"===t.dtype?X.GENERIC_NDARRAY:X.NDARRAY;if(W(t)){let e=t;for(;W(e[0]);)e=e[0];return"x"in e?X.ARRAY_OF_OBJECTS:X.ARRAY_OF_ARRAYS}throw new Error("Unhandled data type. Got type: "+typeof t)}}X.ARRAY_OF_OBJECTS="Obj",X.ARRAY_OF_ARRAYS="Arr",X.NDARRAY="Nd",X.GENERIC_NDARRAY="GenNd",X.PACKED="PackArr";const q=X,$=m().add("infer-type",q);function L(t){return t[0].toUpperCase()+t.slice(1)}const J=m().add("cache-key",function(t,e,i,n,o,s){const r=[];let l=!1;for(let e=0;e<t.splineDimension;++e){const i=W(t.knots)&&W(t.knots[e]);i&&(l=!0),r.push("Deg"+t.degree[e]+(i?"":"Uniform")+L(t.boundary[e]))}const a=[[l?"NU":"",t.weights?"RBS":"BS"].join("")+t.dimension+"D",r.join("_")];return n&&a.push(n+"Pts"),o&&a.push(o+"Wts"),s&&a.push(s+"Kts"),e&&a.push("debug"),i&&a.push("chk"),a.join("_")}),Z=function t(e,i){return function(i,n){void 0===i||Array.isArray(i)||(i=[i]);const o=[];for(let e=0;e<i.length;++e)o.push(t.sum(i[e]));if(n)for(let t=0;t<o.length;++t)void 0!==n[t]&&(o[t]="("+o[t]+" + "+n[t]+") % "+n[t]);return e+o.join("_")}};Z.sum=function(t){return 0===(t=(t=Array.isArray(t)?t:[t]).filter(t=>void 0!==t&&0!==t)).length&&t.push(0),t.join(" + ")};const H=Z,Q=m().add("variable",H),tt=[".x",".y",".z",".w"];function et(t){return function(e,i){void 0===e||Array.isArray(e)||(e=[e]);const n=[];for(let t=0;t<e.length;++t)n.push(Q.sum(e[t]));if(i)for(let t=0;t<n.length;++t)void 0!==i[t]&&(n[t]="("+n[t]+" + "+i[t]+") % "+i[t]);return t(n)}}function it(t,e){if(e)switch($(e)){case $.ARRAY_OF_OBJECTS:return et(e=>{const i=e.pop();return t+"["+e.join("][")+"]"+tt[i]});case $.ARRAY_OF_ARRAYS:return et(e=>t+"["+e.join("][")+"]");case $.GENERIC_NDARRAY:return et(e=>t+".get("+e.join(",")+")");case $.NDARRAY:return et(e=>{const i=[t+"Offset"];for(let n=0;n<e.length;++n)i.push(t+"Stride"+n+" * ("+e[n]+")");return t+"["+i.join(" + ")+"]"});case $.PACKED:default:return}}const nt=m().add("create-accessors",function(t){const e={};let i=it("x",t.points);return i&&(e.point=i),i=it("w",t.weights),i&&(e.weight=i),i=it("k",t.knots),i&&(e.knot=i),e}),ot=[],st=[],rt=m().add("numerical-derivative",function(t,e,i){if(1!==e)throw new Error("Numerical derivative not implemented for order n = "+e+".");const n=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];ot.length=this.splineDimension;for(let t=0;t<this.splineDimension;++t)ot[t+1]=arguments[t+3];const o=this.domain,s=o[i][0],r=o[i][1],l=ot[i+1];let a,h,u=(r-s)*n;if("closed"===this.boundary[i]){const t=r-s;a=s+(l-s-u+t)%t,h=s+(l-s+u+t)%t,u*=2}else a=Math.min(r,Math.max(s,l-u)),h=Math.min(r,Math.max(s,l+u)),u=h-a;ot[i+1]=a,ot[0]=st,this.evaluate.apply(null,ot),ot[i+1]=h,ot[0]=t,this.evaluate.apply(null,ot);for(let e=0;e<this.dimension;++e)t[e]=(t[e]-st[e])/u;return t}),lt=m().add("ndloop",function(t,e){let i=1,n=[];for(let e=0;e<t.length;++e)i*=Array.isArray(t[e])?t[e][1]-t[e][0]:t[e],n[e]=Array.isArray(t[e])?t[e][0]:0;for(let o=0;o<i;++o){e(n.slice());for(let e=t.length-1;e>=0;--e){if(n[e]!==(Array.isArray(t[e])?t[e][1]:t[e])-1){++n[e];break}n[e]=Array.isArray(t[e])?t[e][0]:0}}}),at=m().add("accessor-preamble",function(t,e,i,n){const o=[];switch($(n)){case $.NDARRAY:o.push(`  var ${e} = ${i}.data;`),o.push(`  var ${e}Offset = ${i}.offset;`);for(let t=0;t<n.dimension;++t)o.push(`  var ${e}Stride${t} = ${i}.stride[${t}];`);break;case $.ARRAY_OF_OBJECTS:case $.ARRAY_OF_ARRAYS:o.push(`  var ${e} = ${i};`)}return o.join("\n")}),ht=m().add("size-getter",function(t,e,i){if(t){if(Y(t))return e+".shape["+i+"]";{let t=e;for(let e=0;e<i;++e)t+="[0]";return t+".length"}}return"this.size["+i+"]"}),ut={},dt={},ct=m().add("evaluator",function(t,e,i,n,o,s,r){const l=e.splineDimension,a=e.points,h=e.degree,u=e.weights,d=void 0!==u,c=e.knots,g=e.dimension,p=e.boundary;if(null!=r){Array.isArray(r)||(r=[r]);let t=0;for(let e=0;e<l;++e)void 0===r[e]&&(r[e]=0),t+=r[e];if(d&&t>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+t+".")}s&&(t="Basis"+t),r&&(t="Der"+r.join("_")+"_"+t);const f=ut[t],_=n?"function"==typeof n?n:console.log:null;if(f)return n&&_(dt[t]),f.bind(e);const m=[],w="evaluate"+t;let y=i.point;s&&(y=function(t,e){const i=[];for(let n=0;n<t.length;++n){const o=[];let s=t[n];for(let t=0;t<s.length;++t)0!==s[t]&&o.push(s[t]);s=o.join(" + "),e[n]&&(s="("+s+" + "+e[n]+") % "+e[n]),i.push(s+" === "+S(n))}return"(("+i.join(" && ")+") ? 1 : 0)"});const b=i.weight,v=i.knot,C=Q("k"),O=Q("x"),N=Q("w"),S=Q("i"),P=Q("t"),D=n?"domain":"d",F=Q(n?"size":"s"),T=Q(n?"knotIndex":"j");let V=!0;for(let t=0;t<l;++t)W(c)&&W(c[t])&&(V=!1);function j(t){m.push("  "+(t||""))}function x(t){n&&j(t)}const R=s?[]:null,I=[];for(let t=0;t<l;++t)s&&R.push(S([t])),I.push(P([t]));m.push("function "+w+" ("+(s?"":"out, ")+I.join(", ")+(s?", "+R.join(", "):"")+") {"),j("var h, m, a, b;"),o&&(j("var "+D+" = this.domain;"),j("for (var i = 0; i < this.splineDimension; ++ i) {"),j("  a = arguments[i + 1];"),j("  if (a < "+D+"[i][0] || a > "+D+"[i][1] || a === undefined || isNaN(a)) {"),j('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+D+'[i][0]+", "+'+D+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),j("  }"),j("}"));for(let t=0;t<l;++t)j("var "+F(t)+" = "+ht(a,"this.points",t)+";");function z(t,e,i){return"("+t+") ? ("+e+") : ("+i+")"}m.push(at(e,"x","this.points",a)),d&&m.push(at(e,"w","this.weights",u)),V||m.push(at(e,"k","this.knots",c));const A=[];for(let t=0;t<l;++t)switch($(c)){case $.NDARRAY:A[t]=!0;break;case $.ARRAY_OF_ARRAYS:A[t]=W(c[t])}for(let t=0;t<l;++t)if(A[t]){x("\n  // Bisect to locate the knot interval in dimension "+t+"\n"),j("var "+T(t)+" = 0;"),j("h = "+F(t)+";"),j("while(h > "+T(t)+" + 1) {"),j("  m = 0.5 * (h + "+T(t)+") | 0;"),j("  if ("+v([t,"m"])+" > "+P(t)+") h = m;"),j("  else "+T(t)+" = m;"),j("}"),x("\n  // Fetch knots for dimension "+t+"\n");for(let e=1-h[t];e<=h[t];++e)"closed"===p[t]?j(e<0?"var "+C([t,e+h[t]-1])+" = "+z(T(t)+" < "+-e,v([t,0])+" + "+v([t,[F(t),T(t),e]])+" - "+v([t,[F(t)]]),v([t,[T(t),e]]))+";":e>0?"var "+C([t,e+h[t]-1])+" = "+z(T(t)+" + "+e+" > "+F(t),v([t,F(t)])+" + "+v([t,e+" + "+T(t)+" - "+F(t)])+" - "+v([t,0]),v([t,[T(t),e]]))+";":"var "+C([t,e+h[t]-1])+" = "+v([t,[T(t),e]])+";"):j("var "+C([t,e+h[t]-1])+" = "+v([t,[T(t),e]])+";")}else{x("\n  // Directly compute knot interval for dimension "+t+"\n"),"closed"===p[t]?j(T(t)+" = ("+P(t)+" | 0) % "+F(t)+";"):(j(T(t)+" = ("+P(t)+" | 0);"),j("if ("+T(t)+" < "+h[t]+") "+T(t)+" = "+h[t]+";"),j("if ("+T(t)+" > "+F(t)+" - 1) "+T(t)+" = "+F(t)+" - 1;")),x("\n  // Compute and clamp knots for dimension "+t+"\n");for(let e=1-h[t];e<=h[t];++e){j("var "+C([t,e+h[t]-1])+" = "+T(t)+" + "+e+";")}if("clamped"===p[t])for(let e=1-h[t];e<=h[t];++e){const i=C([t,e+h[t]-1]);e<0&&j("if ("+i+" < "+h[t]+") "+i+" = "+h[t]+";"),e>0&&j("if ("+i+" > "+F(t)+") "+i+" = "+F(t)+";")}"closed"===p[t]&&(x("\n  // Wrap the B-Spline parameter for closed boundary"),j(P(t)+" %= "+F(t)+";"))}const k=[];for(let t=0;t<l;++t)k[t]=h[t]+1;d&&(x("\n  // Fetch weights\n"),lt(k,function(t){const e=[],i=[];for(let n=0;n<l;++n)e[n]=[T(n),t[n]-h[n]],"closed"===p[n]&&t[n]-h[n]<0&&(i[n]=F(n));j("var "+N(t)+" = "+b(e,i)+";")})),n&&j(d?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),lt(k,function(t){const e=[],i=[];for(let n=0;n<l;++n)e[n]=[T(n),t[n]-h[n]],"closed"===p[n]&&t[n]-h[n]<0&&(i[n]=F(n));if(s)j(d?"var "+O(t)+" = "+y(e,i)+" * "+N(t)+";":"var "+O(t)+" = "+y(e,i)+";");else for(let n=0;n<g;++n){const o=t.concat(n);e[l]=n,j(d?"var "+O(o)+" = "+y(e,i)+" * "+N(t)+";":"var "+O(o)+" = "+y(e,i)+";")}}),x("\n"),x('// Perform De Boor"s algorithm');for(let t=k.length-1;t>=0;--t){k[t]=[h[t],h[t]+1];for(let e=0;e<h[t];++e){x("\n  // Degree "+h[t]+" evaluation in dimension "+t+", step "+(e+1)+"\n");for(let i=h[t];i>e;--i){const n=r&&h[t]-e-r[t]<=0;n?(j("m = 1 / ("+C([t,i-e+h[t]-1])+" - "+C([t,i-1])+");"),d&&(j("a = ("+P(t)+" - "+C([t,i-1])+") * m;"),j("b = 1 - a;"))):(j("a = ("+P(t)+" - "+C([t,i-1])+") / ("+C([t,i-e+h[t]-1])+" - "+C([t,i-1])+");"),j("b = 1 - a;")),d&&lt(k,function(e){const o=e.slice(),s=e.slice();o[t]=i,s[t]=i-1,n&&d&&j("h = "+N(o)+";"),j(N(o)+" = b * "+N(s)+" + a * "+N(o)+";")}),lt(k,function(o){let r,a,h;const u=o.slice(),c=o.slice();if(u[t]=i,c[t]=i-1,n){const t=e+1;if(s)r=d?"h * "+N(c)+" / "+N(u)+" * ":"",a=O(u)+(d?" / h":""),h=O(c)+(d?" / "+N(c):""),j(O(u)+" = "+t+" * "+r+"("+a+" - "+h+") * m;");else{const e=u.slice(),i=c.slice();for(let n=0;n<g;++n)e[l]=i[l]=n,r=d?"h * "+N(c)+" / "+N(u)+" * ":"",a=O(e)+(d?" / h":""),h=O(i)+(d?" / "+N(c):""),j(O(e)+" = "+t+" * "+r+"("+a+" - "+h+") * m;")}}else if(s)j(O(u)+" = b * "+O(c)+" + a * "+O(u)+";");else for(let t=0;t<g;++t)u[l]=c[l]=t,j(O(u)+" = b * "+O(c)+" + a * "+O(u)+";")}),x("\n")}}}if(n&&j(d?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),s)j(d?"return "+O(h)+" / "+N(h)+";":"return "+O(h)+";");else for(let t=0;t<g;++t)j(d?"out["+t+"] = "+O(h.concat([t]))+" / "+N(h)+";":"out["+t+"] = "+O(h.concat([t]))+";");if(s||j("return out;"),m.push("}"),n){const e=m.join("\n");_(e),dt[t]=e}const B=new Function([m.join("\n"),"; return ",w].join(""))();return ut[t]=B,B.bind(e)}),gt={},pt=m().add("transform",function(t,e,i,n){const o=gt[t];if(o)return o.bind(e);const s=[],r="transform"+t;s.push("function "+r+"(m) {"),s.push("var i, w;"),s.push(at(e,"x","this.points",e.points));const l=Q(n?"size":"s");for(let t=0;t<e.splineDimension;++t)s.push("var "+l(t)+" = "+ht(e.points,"this.points",t)+";");const a=[];for(let t=0;t<e.splineDimension;++t){const e="i"+t;a.push(e),s.push("for ("+e+" = "+l(t)+"- 1; "+e+" >= 0; -- "+e+") {")}for(let t=0;t<e.dimension;++t)s.push("x"+t+" = "+i.point(a.concat([t])));const h=[];for(let t=0;t<e.dimension;++t)h.push("m["+((e.dimension+1)*(t+1)-1)+"] * x"+t);h.push("m["+((e.dimension+1)*(e.dimension+1)-1)+"]"),s.push("var w = ("+h.join(" + ")+") || 1.0;");for(let t=0;t<e.dimension;++t){const n=[],o=e.dimension;let r=0;for(;r<o;++r)n.push("m["+(r*(o+1)+t)+"] * x"+r);n.push("m["+(r*(o+1)+t)+"]");const l=i.point(a.concat([t])),h="("+n.join(" + ")+") / w";s.push(l+" = "+h+";")}for(let t=e.splineDimension-1;t>=0;--t)s.push("}");s.push("return this;"),s.push("}");const u=new Function([s.join("\n"),"; return ",r].join(""))();return n&&console.log(s.join("\n")),gt[t]=u,u.bind(e)}),ft={},_t=m().add("support",function(t,e,i,n,o){const s=ft[t];if(s)return s.bind(e);const r=e.degree,l=e.knots,a=e.splineDimension,h=e.boundary,u=[],d="support"+t,c=i.knot,g=Q("t"),p=n?"domain":"d",f=Q(n?"size":"s"),_=Q(n?"knotIndex":"i");let m=!0;for(let t=0;t<a;++t)W(l)&&W(l[t])&&(m=!1);function w(t){u.push("  "+(t||""))}const y=[];for(let t=0;t<a;++t)y.push(g([t]));u.push("function "+d+" (out, "+y.join(", ")+") {");let b=0;function v(t,e){w(void 0===e?"out["+b+++"] = "+t.join(" + ")+";":"out["+b+++"] = ("+t.join(" + ")+" + "+e+") % "+e+";")}w("var h, m;"),w("var c = 0;"),o&&(w("var "+p+" = this.domain;"),w("for (var i = 0; i < this.splineDimension; ++ i) {"),w("  a = arguments[i + 1];"),w("  if (a < "+p+"[i][0] || a > "+p+"[i][1] || a === undefined || isNaN(a)) {"),w('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+p+'[i][0]+", "+'+p+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),w("  }"),w("}"));for(let t=0;t<a;++t)w("var "+f(t)+" = "+ht(e.points,"this.points",t)+";");m||u.push(at(e,"k","this.knots",l));const C=[];for(let t=0;t<a;++t)switch($(l)){case $.NDARRAY:C[t]=!0;break;case $.ARRAY_OF_ARRAYS:C[t]=W(l[t])}for(let t=0;t<a;++t)C[t]?(w("var "+_(t)+" = 0;"),w("h = "+f(t)+";"),w("while(h > "+_(t)+" + 1) {"),w("  m = 0.5 * (h + "+_(t)+") | 0;"),w("  if ("+c([t,"m"])+" > "+g(t)+") h = m;"),w("  else "+_(t)+" = m;"),w("}")):"closed"===h[t]?w(_(t)+" = ("+g(t)+" | 0) % "+f(t)+";"):(w(_(t)+" = ("+g(t)+" | 0);"),w("if ("+_(t)+" < "+r[t]+") "+_(t)+" = "+r[t]+";"),w("if ("+_(t)+" > "+f(t)+" - 1) "+_(t)+" = "+f(t)+" - 1;"));const O=[];for(let t=0;t<a;++t)O[t]=r[t]+1;lt(O,function(t){const e=[],i=[];for(let n=0;n<a;++n)e[n]=[_(n),t[n]-r[n]],"closed"===h[n]&&t[n]-r[n]<0&&(i[n]=f(n));for(let t=0;t<a;++t)v(e[t],i[t])}),w("out.length = "+b+";"),w("return out;"),u.push("}"),n&&console.log(u.join("\n"));const N=new Function([u.join("\n"),"; return ",d].join(""))();return ft[t]=N,N.bind(e)}),mt=[],wt=new Map,yt=new Map;function bt(t,e,i,n,o,s,r){for(let l=0;l<i;++l){Ct(t+e*l,n,o,s,r)}}function vt(t,e,i,n,o,s,r){for(let i=0;i<e;++i){Ct(i+e*t,n,o,s,r)}}function Ct(t,e,i,n,o){let s="";for(let n=0;n<e;++n)s+=i[t*e+n],s+=";";n.has(s)?o.set(t,n.get(s)):n.set(s,t)}const Ot=function(t,e,i){const n=t.points??=[],o=t.faces??=[],s=i.haveWeights,r=e.dimension-s,l=i.resolution;switch(e.splineDimension){case 1:{const t=l[0],o=t+1,a=o*r,h=e.domain[0],u=h[1]-h[0],d=i.closed;for(let i=0;i<o;++i){const o=h[0]+u*(d?i%t:i)/t,l=i*r;if(e.evaluate(mt,o),s){const t=mt[r];for(let e=0;e<r;++e)n[l+e]=mt[e]/t}else for(let t=0;t<r;++t)n[l+t]=mt[t]}n.length=a;break}case 2:{const t=l[0],a=l[1],h=t+1,u=a+1,d=h*u*r,c=e.domain,g=c[0],p=c[1],f=g[1]-g[0],_=p[1]-p[0],m=i.closed[0],w=i.closed[1];for(let i=0;i<u;++i){const o=p[0]+_*i/a;for(let l=0;l<h;++l){const a=g[0]+f*l/t,u=(l+h*i)*r;if(e.evaluate(mt,a,o),s){const t=mt[r];for(let e=0;e<r;++e)n[u+e]=mt[e]/t}else for(let t=0;t<r;++t)n[u+t]=mt[t]}}n.length=d,bt(0,h,u,r,n,wt,yt),vt(0,h,u,r,n,wt,yt),m||bt(t,h,u,r,n,wt,yt),w||vt(a,h,u,r,n,wt,yt);let y=0;for(let e=0;e<a;++e){const i=w?(e+1)%a:e+1;for(let n=0;n<t;++n){const s=m?(n+1)%t:n+1;let r=n+h*e,l=s+h*e,a=s+h*i,u=n+h*i;r=yt.get(r)??r,l=yt.get(l)??l,a=yt.get(a)??a,u=yt.get(u)??u,o[y++]=r,o[y++]=l,o[y++]=a,o[y++]=r,o[y++]=a,o[y++]=u}}o.length=y,wt.clear(),yt.clear();break}default:throw new Error("Can only sample contours and surfaces.")}return t},Nt=m().add("sample",Ot),St={open:"open",closed:"closed",clamped:"clamped"};function Pt(t){return null==t}function Dt(t,e,i,n,o,s){!t||W(t)||G(t)?(s=s||{},this.weights=n,this.knots=i,this.degree=e,this.points=t,this.boundary=o,this.debug=s.debug,this.checkBounds=!!s.checkBounds,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0})):(s=t,this.debug=t.debug,this.checkBounds=!!t.checkBounds,this.weights=t.weights,this.knots=t.knots,this.degree=t.degree,this.boundary=t.boundary,this.points=t.points,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0}));const r=$(this.points),l=$(this.weights),a=$(this.knots);if(this.points)switch(r){case $.GENERIC_NDARRAY:case $.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case $.ARRAY_OF_OBJECTS:case $.ARRAY_OF_ARRAYS:const t=this.size||[];let e=0,i=this.points;for(t.length=0;W(i[0]);i=i[0])++e,t.push(i.length);if(0===e)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:e,writable:!1,configurable:!0},dimension:{value:i.length,writable:!1,configurable:!0},size:{get:function(){const t=[];t.length=0;for(let e=0,i=this.points;e<this.splineDimension;++e,i=i[0])t[e]=i.length;return t},set:function(){throw new Error('Cannot assign to read only property "size"')},configurable:!0}});break;case $.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(W(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(W(this.degree)){for(let t=0;t<this.splineDimension;++t)if(Pt(this.degree[t]))throw new Error("Missing degree in dimension "+(t+1))}else{const t=!Pt(this.degree),e=Pt(this.degree)?2:this.degree;this.degree=[];for(let i=0;i<this.splineDimension;++i)if(this.size[i]<=e){if(t)throw new Error("Expected at least "+(e+1)+" points for degree "+e+" spline in dimension "+(i+1)+" but got only "+this.size[i]);this.degree[i]=this.size[i]-1}else this.degree[i]=e}const h="string"!=typeof this.boundary?"open":this.boundary;if(!St[h])throw new Error("Boundary type must be one of "+Object.keys(St)+". Got "+h);this.boundary=W(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension;for(let t=0;t<this.splineDimension;++t)if(this.boundary[t]=Pt(this.boundary[t])?h:this.boundary[t],!St[h])throw new Error("Boundary type must be one of "+Object.keys(St)+". Got "+h+" for dimension "+(t+1));switch(a){case $.ARRAY_OF_ARRAYS:W(this.knots)&&this.knots.length>0&&!W(this.knots[0])&&(this.knots=[this.knots]);for(let t=0;t<this.splineDimension;++t){if(this.size[t]<=this.degree[t])throw new Error("Expected at least "+(this.degree[t]+1)+" points in dimension "+(t+1)+" but got "+this.size[t]+".");if(W(this.knots[t])){if("closed"!==this.boundary[t]&&this.knots[t].length!==this.degree[t]+this.size[t]+1)throw new Error("Expected "+(this.degree[t]+this.size[t]+1)+" knots in dimension "+(t+1)+" but got "+this.knots[t].length+".");if("closed"===this.boundary[t]&&this.knots[t].length!==this.size[t]+1){if(!(this.knots[t].length===this.size[t]+this.degree[t]+1))throw new Error("Expected "+(this.size[t]+1)+" knots for closed spline in dimension "+(t+1)+" but got "+this.knots[t].length+".")}}}case $.NDARRAY:}const u=J(this,this.debug,this.checkBounds,r,l,a);if(u!==this.__cacheKey){this.__cacheKey=u;const t=nt(this);this.evaluate=ct(this.__cacheKey,this,t,this.debug,this.checkBounds,!1),this.transform=pt(this.__cacheKey,this,t,this.debug),this.support=_t(this.__cacheKey,this,t,this.debug,this.checkBounds),this.evaluator=function(e,i){return ct(this.__cacheKey,this,t,this.debug,this.checkBounds,i,e)}}return this.numericalDerivative=rt.bind(this),this}function Ft(){const t=[];let e,i=this.points;i?Y(i)&&(e=i.shape):e=this.size;for(let n=0;n<this.splineDimension;++n){const o=e?e[n]:i.length,s=this.degree[n],r="closed"===this.boundary[n];if(this.knots&&this.knots[n]){const e=this.knots[n];t[n]=[e[r?0:s],e[o]]}else t[n]=[r?0:s,o];i&&(i=i[0])}return t}function Tt(t,e,i,n,o,s){const r=function(t,e,i,n,o,s){return l(t,e,i,n,o,s),r},l=Dt.bind(r);return Object.defineProperty(r,"domain",{get:Ft}),l(t,e,i,n,o,s),r}Tt.sample=Nt;const Vt=Tt,jt=m().add("nurbs",Vt);function xt(t){M.call(this,t),U().call(this,t),this.addType(g().NurbsCurve),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]}}Object.assign(Object.setPrototypeOf(xt.prototype,M.prototype),U().prototype,{initialize(){M.prototype.initialize.call(this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode?.removeInterest("requestRebuild",this),this.controlPointNode=f()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode?.addInterest("requestRebuild",this)},getTessellation(t){return k.getTessellation(this._tessellation.getValue(),t)},getClosed(t,e,i,n){return!!this._closed.getValue()&&k.getClosed(t,e,i,n)},getWeights:(t,e,i)=>k.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>k.getControlPoints(t,e,i,n,o),getSurface(){return this.surface},tessellate(){if(this._order.getValue()<2)return[];if(!this.controlPointNode)return[];if(this.controlPointNode.getSize()<this._order.getValue())return[];const t=this.getVertices(),e=t.length,i=[];if(e){for(let n=0;n<e;n+=8)i.push(t[n],t[n+1],t[n+2]);i.push(t[e-4],t[e-3],t[e-2])}return i},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),n=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=this._order.getValue()-1;this.surface=(this.surface??jt)({boundary:["open"],degree:[o],knots:[n],points:i,debug:!1}),this.sampleOptions.resolution[0]=this.getTessellation(this.controlPointNode.getSize()),this.sampleOptions.closed=t,this.sampleOptions.haveWeights=!!e;const s=jt.sample(this.mesh,this.surface,this.sampleOptions).points,r=s.length-3,l=this.getVertices();for(let t=0;t<r;t+=3)l.push(s[t+0],s[t+1],s[t+2],1,s[t+3],s[t+4],s[t+5],1)},dispose(){M.prototype.dispose.call(this)}}),Object.defineProperties(xt,{...d().getStaticProperties("NurbsCurve","NURBS",1,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"tessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"closed",new(s().SFBool)),new(l())(g().initializeOnly,"order",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode))]),enumerable:!0}});const Rt=xt,It=m().add("NurbsCurve",Rt);function zt(t){N.call(this,t),this.addType(g().NurbsCurve2D),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]},this.array=[]}Object.assign(Object.setPrototypeOf(zt.prototype,N.prototype),{getTessellation(t){return k.getTessellation(this._tessellation.getValue(),t)},getClosed(t,e,i,n){return!!this._closed.getValue()&&k.getClosed2D(t,e,i,n)},getKnots:(t,e,i,n,o)=>k.getKnots(t,e,i,n,o),getWeights:(t,e,i)=>k.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>k.getControlPoints2D(t,e,i,n,o),tessellate(t,e=this.array){if(this._order.getValue()<2)return e;if(this._controlPoint.length<this._order.getValue())return e;const i=this.getClosed(this._order.getValue(),this._knot,this._weight,this._controlPoint),n=this.getWeights(this.weights,this._controlPoint.length,this._weight),o=this.getControlPoints(this.controlPoints,i,this._order.getValue(),n,this._controlPoint),s=this.getKnots(this.knots,i,this._order.getValue(),this._controlPoint.length,this._knot),r=this._order.getValue()-1;this.surface=(this.surface??jt)({boundary:["open"],degree:[r],knots:[s],points:o,debug:!1}),this.sampleOptions.resolution[0]=this.getTessellation(this._controlPoint.length),this.sampleOptions.closed=i,this.sampleOptions.haveWeights=!!n;const l=jt.sample(this.mesh,this.surface,this.sampleOptions).points,a=l.length;switch(t){case 0:e.length=0;for(const t of l)e.push(t);break;case 1:e.length=0;for(let t=0;t<a;t+=2)e.push(l[t],0,l[t+1]);break;case 2:for(let t=0;t<a;t+=2)e.push(new(P())(l[t],l[t+1],0))}return e}}),Object.defineProperties(zt,{...d().getStaticProperties("NurbsCurve2D","NURBS",3,"children","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"tessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"closed",new(s().SFBool)),new(l())(g().initializeOnly,"order",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().MFVec2d))]),enumerable:!0}});const At=zt,kt=m().add("NurbsCurve2D",At),Bt=t.X3DChildNode;var Et=e.n(Bt);const Mt=t.Rotation4;var Kt=e.n(Mt);const Ut=t.Algorithm;var Gt=e.n(Ut);function Yt(t){Et().call(this,t),this.addType(g().NurbsOrientationInterpolator),this.geometry=new It(t)}Object.assign(Object.setPrototypeOf(Yt.prototype,Et().prototype),{initialize(){Et().prototype.initialize.call(this),this._set_fraction.addInterest("set_fraction__",this),this._order.addFieldInterest(this.geometry._order),this._knot.addFieldInterest(this.geometry._knot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._tessellation=1,this.geometry._order=this._order,this.geometry._knot=this._knot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry._rebuild.addInterest("set_geometry__",this),this.geometry.setup(),this.set_geometry__()},set_geometry__(){const t=this.geometry.getSurface();t?(delete this.set_fraction__,this.derivative=t.evaluator(1)):this.set_fraction__=Function.prototype},set_fraction__:(()=>{const t=new(P()),e=new(Kt());return function(){const i=Gt().clamp(this._set_fraction.getValue(),0,1),n=this.geometry.getSurface().domain[0],o=Gt().project(i,0,1,...n);this.derivative(t,o),this._value_changed=e.setFromToVec(P().Z_AXIS,t)}})()}),Object.defineProperties(Yt,{...d().getStaticProperties("NurbsOrientationInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"set_fraction",new(s().SFFloat)),new(l())(g().inputOutput,"order",new(s().SFInt32)(3)),new(l())(g().inputOutput,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().outputOnly,"value_changed",new(s().SFRotation))]),enumerable:!0}});const Wt=Yt,Xt=m().add("NurbsOrientationInterpolator",Wt),qt=t.Triangle3;var $t=e.n(qt);function Lt(t){M.call(this,t),this.addType(g().X3DNurbsSurfaceGeometryNode),this.tessellationScale=1,this.uKnots=[],this.vKnots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[],closed:[]},this.textUKnots=[],this.textVKnots=[],this.textWeights=[],this.texControlPoints=[],this.texMesh={}}Object.assign(Object.setPrototypeOf(Lt.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._texCoord.addInterest("set_texCoord__",this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_texCoord__(),this.set_controlPoint__()},set_texCoord__(){this.texCoordNode?.removeInterest("requestRebuild",this),this.nurbsTexCoordNode?.removeInterest("requestRebuild",this),this.texCoordNode=f()(g().X3DTextureCoordinateNode,this._texCoord),this.nurbsTexCoordNode=f()(g().NurbsTextureCoordinate,this._texCoord),this.texCoordNode?.addInterest("requestRebuild",this),this.nurbsTexCoordNode?.addInterest("requestRebuild",this)},set_controlPoint__(){this.controlPointNode?.removeInterest("requestRebuild",this),this.controlPointNode=f()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode?.addInterest("requestRebuild",this)},setTessellationScale(t){this.tessellationScale=t,this.requestRebuild()},getUTessellation(){return Math.floor(k.getTessellation(this._uTessellation.getValue(),this._uDimension.getValue())*this.tessellationScale)},getVTessellation(t){return Math.floor(k.getTessellation(this._vTessellation.getValue(),this._vDimension.getValue())*this.tessellationScale)},getUClosed(t,e,i,n,o,s){return!!this._uClosed.getValue()&&k.getUClosed(t,e,i,n,o,s)},getVClosed(t,e,i,n,o,s){return!!this._vClosed.getValue()&&k.getVClosed(t,e,i,n,o,s)},getUVWeights:(t,e,i,n)=>k.getUVWeights(t,e,i,n),getTexControlPoints:(t,e,i,n,o,s,r,l)=>k.getTexControlPoints(t,e,i,n,o,s,r,l),getUVControlPoints:(t,e,i,n,o,s,r,l,a)=>k.getUVControlPoints(t,e,i,n,o,s,r,l,a),getSurface(){return this.surface},trimSurface(){},build(){if(this._uOrder.getValue()<2)return;if(this._vOrder.getValue()<2)return;if(this._uDimension.getValue()<this._uOrder.getValue())return;if(this._vDimension.getValue()<this._vOrder.getValue())return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._uDimension.getValue()*this._vDimension.getValue())return;const t=this.getUClosed(this._uOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._uKnot,this._weight,this.controlPointNode),e=this.getVClosed(this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._vKnot,this._weight,this.controlPointNode),i=this.getUVWeights(this.weights,this._uDimension.getValue(),this._vDimension.getValue(),this._weight),n=this.getUVControlPoints(this.controlPoints,t,e,this._uOrder.getValue(),this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),i,this.controlPointNode),o=this.getKnots(this.uKnots,t,this._uOrder.getValue(),this._uDimension.getValue(),this._uKnot),s=this.getKnots(this.vKnots,e,this._vOrder.getValue(),this._vDimension.getValue(),this._vKnot),r=this._uOrder.getValue()-1,l=this._vOrder.getValue()-1;this.surface=(this.surface??jt)({boundary:["open","open"],degree:[r,l],knots:[o,s],points:n,debug:!1});const a=this.sampleOptions;a.resolution[0]=this.getUTessellation(),a.resolution[1]=this.getVTessellation(),a.closed[0]=t,a.closed[1]=e,a.haveWeights=!!i;const h=jt.sample(this.mesh,this.surface,a),u=h.faces,d=h.points,c=this.getVertices();for(const t of u){const e=3*t;c.push(d[e],d[e+1],d[e+2],1)}this.buildNurbsTexCoords(t,e,this._uOrder.getValue(),this._vOrder.getValue(),o,s,this._uDimension.getValue(),this._vDimension.getValue()),this.generateNormals(u,d),this.trimSurface(o,s),this.setSolid(this._solid.getValue()),this.setCCW(!0)},buildNurbsTexCoords(t,e,i,n,o,s,r,l){const a=this.getMultiTexCoords();if(this.texCoordNode){this.texCoordNode.init(a);const h=this.texCoordNode.getTextureCoordinates?.(),u=a.length;for(let d=0;d<u;++d){const u=a[d],c=h?.[d]??this.texCoordNode,g=i-1,p=n-1,f=o,_=s,m=this.getTexControlPoints(this.texControlPoints,t,e,i,n,r,l,c);this.createNurbsTexCoords(g,p,f,_,m,u)}}else if(this.nurbsTexCoordNode?.isValid()){const t=this.nurbsTexCoordNode,e=t._uOrder.getValue()-1,i=t._vOrder.getValue()-1,n=this.getKnots(this.texUKnots,!1,t._uOrder.getValue(),t._uDimension.getValue(),t._uKnot),o=this.getKnots(this.texVKnots,!1,t._vOrder.getValue(),t._vDimension.getValue(),t._vKnot),s=this.getUVWeights(this.texWeights,t._uDimension.getValue(),t._vDimension.getValue(),t._weight),r=t.getControlPoints(s),l=this.getTexCoords();a.push(l),this.createNurbsTexCoords(e,i,n,o,r,l)}else{const t=this.getTexCoords();a.push(t),this.createDefaultNurbsTexCoords(t)}},createDefaultNurbsTexCoords:(()=>{const t=[0,0,5,5],e=[[[0,0,0,1],[0,1,0,1]],[[1,0,0,1],[1,1,0,1]]];return function(i){const n=t,o=t,s=e;return this.createNurbsTexCoords(1,1,n,o,s,i)}})(),createNurbsTexCoords(t,e,i,n,o,s){this.texSurface=(this.texSurface??jt)({boundary:["open","open"],degree:[t,e],knots:[i,n],points:o});const r=this.sampleOptions;r.closed[0]=!1,r.closed[1]=!1,r.haveWeights=!1;const l=jt.sample(this.texMesh,this.texSurface,r),a=l.faces,h=l.points;for(const t of a){const e=4*t;s.push(h[e],h[e+1],h[e+2],h[e+3])}return s},generateNormals(t,e){const i=this.createNormals(t,e),n=this.getNormals();for(const{x:t,y:e,z:o}of i)n.push(t,e,o)},createNormals(t,e){const i=new Map,n=this.createFaceNormals(t,e),o=t.length;for(let e=0;e<o;++e){const n=t[e];let o=i.get(n);o||i.set(n,o=[]),o.push(e)}return this.refineNormals(i,n,Gt().radians(85))},createFaceNormals:(()=>{const t=new(P()),e=new(P()),i=new(P());return function(n,o){const s=this.faceNormals??[],r=n.length;for(let l=0;l<r;l+=3){const r=3*n[l],a=3*n[l+1],h=3*n[l+2];t.set(o[r],o[r+1],o[r+2]),e.set(o[a],o[a+1],o[a+2]),i.set(o[h],o[h+1],o[h+2]);const u=$t().normal(t,e,i,s[l]??new(P()));s[l]=u,s[l+1]=u,s[l+2]=u}return s.length=r,s}})()}),Object.defineProperties(Lt,d().getStaticProperties("X3DNurbsSurfaceGeometryNode","NURBS",1));const Jt=Lt,Zt=m().add("X3DNurbsSurfaceGeometryNode",Jt);function Ht(t){Zt.call(this,t),this.addType(g().NurbsPatchSurface)}Object.setPrototypeOf(Ht.prototype,Zt.prototype),Object.defineProperties(Ht,{...d().getStaticProperties("NurbsPatchSurface","NURBS",1,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"uTessellation",new(s().SFInt32)),new(l())(g().inputOutput,"vTessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"uClosed",new(s().SFBool)),new(l())(g().initializeOnly,"vClosed",new(s().SFBool)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"texCoord",new(s().SFNode)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode))]),enumerable:!0}});const Qt=Ht,te=m().add("NurbsPatchSurface",Qt);function ee(t){Et().call(this,t),this.addType(g().NurbsPositionInterpolator),this.geometry=new It(t)}Object.assign(Object.setPrototypeOf(ee.prototype,Et().prototype),{initialize(){Et().prototype.initialize.call(this),this._set_fraction.addInterest("set_fraction__",this),this._order.addFieldInterest(this.geometry._order),this._knot.addFieldInterest(this.geometry._knot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._tessellation=1,this.geometry._order=this._order,this.geometry._knot=this._knot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry._rebuild.addInterest("set_geometry__",this),this.geometry.setup(),this.set_geometry__()},set_geometry__(){this.geometry.getSurface()?delete this.set_fraction__:this.set_fraction__=Function.prototype},set_fraction__:(()=>{const t=new(P());return function(){const e=Gt().clamp(this._set_fraction.getValue(),0,1),i=this.geometry.getSurface(),n=i.domain[0],o=Gt().project(e,0,1,...n);i.evaluate(t,o),this._value_changed=t}})()}),Object.defineProperties(ee,{...d().getStaticProperties("NurbsPositionInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"set_fraction",new(s().SFFloat)),new(l())(g().inputOutput,"order",new(s().SFInt32)(3)),new(l())(g().inputOutput,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().outputOnly,"value_changed",new(s().SFVec3f))]),enumerable:!0}});const ie=ee,ne=m().add("NurbsPositionInterpolator",ie),oe=t.X3DBoundedObject;var se=e.n(oe);function re(t){Et().call(this,t),se().call(this,t),this.addType(g().NurbsSet),this.geometryNodes=[]}function le(t,e){const i=new Set(e);return t.filter(t=>!i.has(t))}Object.assign(Object.setPrototypeOf(re.prototype,Et().prototype),se().prototype,{initialize(){Et().prototype.initialize.call(this),se().prototype.initialize.call(this),this._tessellationScale.addInterest("set_tessellationScale__",this),this._addGeometry.addInterest("set_addGeometry__",this),this._removeGeometry.addInterest("set_removeGeometry__",this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},getBBox(t,e){if(this.isDefaultBBoxSize()){for(const e of this.geometryNodes)t.add(e.getBBox());return t}return t.set(this._bboxSize.getValue(),this._bboxCenter.getValue())},set_tessellationScale__(){const t=Math.max(0,this._tessellationScale.getValue());for(const e of this.geometryNodes)e.setTessellationScale(t)},set_addGeometry__(){this._addGeometry.setTainted(!0),this._addGeometry.assign(le(this._addGeometry,this._geometry));for(const t of this._addGeometry)this._geometry.push(t);this._addGeometry.length=0,this._addGeometry.setTainted(!1)},set_removeGeometry__(){this._removeGeometry.setTainted(!0),this._geometry.assign(le(this._geometry,this._removeGeometry)),this._removeGeometry.length=0,this._removeGeometry.setTainted(!1)},set_geometry__(){for(const t of this.geometryNodes)t.setTessellationScale(1);this.geometryNodes.length=0;for(const t of this._geometry){const e=f()(g().X3DNurbsSurfaceGeometryNode,t);e&&this.geometryNodes.push(e)}this.set_tessellationScale__()},dispose(){se().prototype.dispose.call(this),Et().prototype.dispose.call(this)}}),Object.defineProperties(re,{...d().getStaticProperties("NurbsSet","NURBS",2,"children","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"tessellationScale",new(s().SFFloat)(1)),new(l())(g().inputOutput,"visible",new(s().SFBool)(!0)),new(l())(g().inputOutput,"bboxDisplay",new(s().SFBool)),new(l())(g().initializeOnly,"bboxSize",new(s().SFVec3f)(-1,-1,-1)),new(l())(g().initializeOnly,"bboxCenter",new(s().SFVec3f)),new(l())(g().inputOnly,"addGeometry",new(s().MFNode)),new(l())(g().inputOnly,"removeGeometry",new(s().MFNode)),new(l())(g().inputOutput,"geometry",new(s().MFNode))]),enumerable:!0}});const ae=re,he=m().add("NurbsSet",ae);function ue(t){Et().call(this,t),this.addType(g().NurbsSurfaceInterpolator),this.geometry=new te(t)}Object.assign(Object.setPrototypeOf(ue.prototype,Et().prototype),{initialize(){Et().prototype.initialize.call(this),this._set_fraction.addInterest("set_fraction__",this),this._uOrder.addFieldInterest(this.geometry._uOrder),this._vOrder.addFieldInterest(this.geometry._vOrder),this._uDimension.addFieldInterest(this.geometry._uDimension),this._vDimension.addFieldInterest(this.geometry._vDimension),this._uKnot.addFieldInterest(this.geometry._uKnot),this._vKnot.addFieldInterest(this.geometry._vKnot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._uTessellation=1,this.geometry._vTessellation=1,this.geometry._uOrder=this._uOrder,this.geometry._vOrder=this._vOrder,this.geometry._uDimension=this._uDimension,this.geometry._vDimension=this._vDimension,this.geometry._uKnot=this._uKnot,this.geometry._vKnot=this._vKnot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry._rebuild.addInterest("set_geometry__",this),this.geometry.setup(),this.set_geometry__()},set_geometry__(){const t=this.geometry.getSurface();t?(delete this.set_fraction__,this.uDerivative=t.evaluator([1,0]),this.vDerivative=t.evaluator([0,1])):this.set_fraction__=Function.prototype},set_fraction__:(()=>{const t=new(P()),e=new(P()),i=new(P());return function(){const n=this._set_fraction.getValue(),o=Gt().clamp(n.x,0,1),s=Gt().clamp(n.y,0,1),r=this.geometry.getSurface(),l=r.domain[0],a=r.domain[1],h=Gt().project(o,0,1,...l),u=Gt().project(s,0,1,...a);this.uDerivative(t,h,u),this.vDerivative(e,h,u),r.evaluate(i,h,u),this._normal_changed=t.cross(e),this._position_changed=i}})()}),Object.defineProperties(ue,{...d().getStaticProperties("NurbsSurfaceInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"set_fraction",new(s().SFVec2f)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().outputOnly,"normal_changed",new(s().SFVec3f)),new(l())(g().outputOnly,"position_changed",new(s().SFVec3f))]),enumerable:!0}});const de=ue,ce=m().add("NurbsSurfaceInterpolator",de),ge=t.Extrusion;var pe=e.n(ge);function fe(t){M.call(this,t),this.addType(g().NurbsSweptSurface),this.extrusion=new(pe())(t)}Object.assign(Object.setPrototypeOf(fe.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._crossSectionCurve.addInterest("set_crossSectionCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_crossSectionCurve__(),this.set_trajectoryCurve__()},getTrajectoryCurve(){return this.trajectoryCurveNode},set_crossSectionCurve__(){this.crossSectionCurveNode?.removeInterest("requestRebuild",this),this.crossSectionCurveNode=f()(g().X3DNurbsControlCurveNode,this._crossSectionCurve),this.crossSectionCurveNode?.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode?._rebuild.removeInterest("requestRebuild",this),this.trajectoryCurveNode=f()(g().NurbsCurve,this._trajectoryCurve),this.trajectoryCurveNode?._rebuild.addInterest("requestRebuild",this)},build(){if(!this.crossSectionCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.crossSectionCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(0),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getTangents().assign(t.getTangents()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals(),e=t.length;for(let i=0;i<e;++i)t[i]*=-1}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(fe,{...d().getStaticProperties("NurbsSweptSurface","NURBS",3,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"ccw",new(s().SFBool)(!0)),new(l())(g().inputOutput,"crossSectionCurve",new(s().SFNode)),new(l())(g().inputOutput,"trajectoryCurve",new(s().SFNode))]),enumerable:!0}});const _e=fe,me=m().add("NurbsSweptSurface",_e);function we(t){M.call(this,t),this.addType(g().NurbsSwungSurface),this.extrusion=new(pe())(t)}Object.assign(Object.setPrototypeOf(we.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._profileCurve.addInterest("set_profileCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_profileCurve__(),this.set_trajectoryCurve__()},getTrajectoryCurve(){return this.trajectoryCurveNode},set_profileCurve__(){this.profileCurveNode?.removeInterest("requestRebuild",this),this.profileCurveNode=f()(g().X3DNurbsControlCurveNode,this._profileCurve),this.profileCurveNode?.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode?.removeInterest("requestRebuild",this),this.trajectoryCurveNode=f()(g().X3DNurbsControlCurveNode,this._trajectoryCurve),this.trajectoryCurveNode?.addInterest("requestRebuild",this)},build(){if(!this.profileCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.profileCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(1),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getTangents().assign(t.getTangents()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals(),e=t.length;for(let i=0;i<e;++i)t[i]*=-1}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(we,{...d().getStaticProperties("NurbsSwungSurface","NURBS",3,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"ccw",new(s().SFBool)(!0)),new(l())(g().inputOutput,"profileCurve",new(s().SFNode)),new(l())(g().inputOutput,"trajectoryCurve",new(s().SFNode))]),enumerable:!0}});const ye=we,be=m().add("NurbsSwungSurface",ye);function ve(t){d().call(this,t),this.addType(g().NurbsTextureCoordinate),this.array=[]}Object.assign(Object.setPrototypeOf(ve.prototype,d().prototype),{getControlPoints(t){const e=this._uDimension.getValue(),i=this._vDimension.getValue(),n=this._controlPoint.getValue(),o=this.array;for(let s=0;s<e;++s){const r=o[s]??=[];for(let o=0;o<i;++o){const i=o*e+s,l=r[o]??new(z()),a=2*i;r[o]=l.set(n[a],n[a+1],0,t?t[i]:1)}r.length=i}return o.length=e,o},isValid(){return!(this._uOrder.getValue()<2)&&(!(this._vOrder.getValue()<2)&&(!(this._uDimension.getValue()<this._uOrder.getValue())&&(!(this._vDimension.getValue()<this._vOrder.getValue())&&!(this._controlPoint.length<this._uDimension.getValue()*this._vDimension.getValue()))))}}),Object.defineProperties(ve,{...d().getStaticProperties("NurbsTextureCoordinate","NURBS",1,"texCoord","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().MFVec2f))]),enumerable:!0}});const Ce=ve,Oe=m().add("NurbsTextureCoordinate",Ce),Ne={area:({x:t,y:e},{x:i,y:n},{x:o,y:s})=>Math.abs(t*(n-s)+i*(s-e)+o*(e-n))/2,isPointInTriangle({x:t,y:e},{x:i,y:n},{x:o,y:s},{x:r,y:l}){const a=(s-l)*(i-r)+(r-o)*(n-l);if(0===a)return!1;const h=((s-l)*(t-r)+(r-o)*(e-l))/a;if(h<0||h>1)return!1;const u=((l-n)*(t-r)+(i-r)*(e-l))/a;if(u<0||u>1)return!1;const d=1-h-u;return!(d<0||d>1)},toBarycentric:(()=>{const t=new(R()),e=new(R()),i=new(R());return function(n,o,s,r,l={}){t.assign(s).subtract(o),e.assign(r).subtract(o),i.assign(n).subtract(o);const a=t.dot(t),h=t.dot(e),u=e.dot(e),d=i.dot(t),c=i.dot(e),g=a*u-h*h;return l.v=(u*d-h*c)/g,l.t=(a*c-h*d)/g,l.u=1-l.v-l.t,l}})()},Se=m().add("Triangle2",Ne),Pe=t.libtess;var De=e.n(Pe);function Fe(t){Zt.call(this,t),this.addType(g().NurbsTrimmedSurface),this.trimmingContourNodes=[],this.trimmingContours=[]}function Te(t,e){const i=new Set(e);return t.filter(t=>!i.has(t))}Object.assign(Object.setPrototypeOf(Fe.prototype,Zt.prototype),{initialize(){Zt.prototype.initialize.call(this),this._addTrimmingContour.addInterest("set_addTrimmingContour__",this),this._removeTrimmingContour.addInterest("set_removeTrimmingContour__",this),this._trimmingContour.addInterest("set_trimmingContour__",this),this.set_trimmingContour__()},set_addTrimmingContour__(){this._addTrimmingContour.setTainted(!0),this._addTrimmingContour.assign(Te(this._addTrimmingContour,this._trimmingContour),this._addTrimmingContour.length);for(const t of this._addTrimmingContour)this._trimmingContour.push(t);this._addTrimmingContour.length=0,this._addTrimmingContour.setTainted(!1)},set_removeTrimmingContour__(){this._removeTrimmingContour.setTainted(!0),this._trimmingContour.assign(Te(this._trimmingContour,this._removeTrimmingContour)),this._removeTrimmingContour.length=0,this._removeTrimmingContour.setTainted(!1)},set_trimmingContour__(){const t=this.trimmingContourNodes;for(const e of t)e.removeInterest("requestRebuild",this);t.length=0;for(const e of this._trimmingContour){const i=f()(g().Contour2D,e);i&&t.push(i)}for(const e of t)e.addInterest("requestRebuild",this)},getTrimmingContours(t,e,i){for(const n of this.trimmingContourNodes)n.addTrimmingContour(t,e,i);return i},trimSurface:(()=>{const t=[new(P())(0,0,0),new(P())(1,0,0),new(P())(1,1,0),new(P())(0,1,0)];return function(e,i){const n=e.at(0),o=i.at(0),s=e.at(-1)-n,r=i.at(-1)-o,l=new(P())(n,o,0),a=new(P())(s,r,1),h=this.createDefaultNurbsTriangles([]),u=h.length,d=this.getTrimmingContours(l,a,[t]),c=this.triangulatePolygon(d,[],!1),g=c.length,p=[];if(1===d.length)return;for(let t=0;t<u;++t)h[t].index=t;for(let t=0;t<u;t+=3)p.push(h.slice(t,t+3));for(let t=0;t<g;t+=3)p.push(c.slice(t,t+3));const f=this.getMultiTexCoords(),_=this.getNormals(),m=this.getVertices(),w=this.triangulatePolygon(p,[],!0),y=w.length,b=f.length,v=f.map(()=>[]),C=[],O=[],N={};let S=0;for(let t=0;t<y;t+=3){const{[t]:e,[t+1]:i,[t+2]:n}=w;Se.area(e,i,n)<1e-6||(w[S++]=e,w[S++]=i,w[S++]=n)}w.length=S;t:for(let t=0;t<S;++t){const e=w[t];if(e.hasOwnProperty("index")){const t=e.index,i=3*t,n=4*t;for(let t=0;t<b;++t){const e=f[t],i=v[t],{[n]:o,[n+1]:s,[n+2]:r,[n+3]:l}=e;i.push(o,s,r,l)}const{[i]:o,[i+1]:s,[i+2]:r}=_,{[n]:l,[n+1]:a,[n+2]:h}=m;C.push(o,s,r),O.push(l,a,h,1);continue t}for(let t=0;t<u;t+=3){const{[t]:i,[t+1]:n,[t+2]:o}=h,{u:s,v:r,t:l}=Se.toBarycentric(e,i,n,o,N);if(Math.abs(s-.5)>.50001)continue;if(Math.abs(r-.5)>.50001)continue;if(Math.abs(l-.5)>.50001)continue;const a=3*t,u=4*t;for(let t=0;t<b;++t){const e=f[t];v[t].push(s*e[u+0]+r*e[u+4]+l*e[u+8],s*e[u+1]+r*e[u+5]+l*e[u+9],s*e[u+2]+r*e[u+6]+l*e[u+10],s*e[u+3]+r*e[u+7]+l*e[u+11])}C.push(s*_[a+0]+r*_[a+3]+l*_[a+6],s*_[a+1]+r*_[a+4]+l*_[a+7],s*_[a+2]+r*_[a+5]+l*_[a+8]),O.push(s*m[u+0]+r*m[u+4]+l*m[u+8],s*m[u+1]+r*m[u+5]+l*m[u+9],s*m[u+2]+r*m[u+6]+l*m[u+10],1);continue t}const i=t%3;for(const t of v)t.length-=4*i;C.length-=3*i,O.length-=4*i,t+=2-i}for(let t=0;t<b;++t)f[t].assign(v[t]);_.assign(C),m.assign(O)}})(),createDefaultNurbsTriangles(t){const e=this.createDefaultNurbsTexCoords([]),i=e.length;for(let n=0;n<i;n+=4)t.push(new(P())(e[n],e[n+1],0));return t},triangulatePolygon:(()=>{function t(t,e,i){return new(P())(...t)}function e(t,[e,i,n,o],s){return n||e.x!==i.x||e.y!==i.y?new(P())(...t):e}const i=new(De().GluTesselator);return i.gluTessCallback(De().gluEnum.GLU_TESS_VERTEX_DATA,function(t,e){e.push(t)}),i.gluTessCallback(De().gluEnum.GLU_TESS_COMBINE,t),i.gluTessProperty(De().gluEnum.GLU_TESS_WINDING_RULE,De().windingRule.GLU_TESS_WINDING_ODD),i.gluTessNormal(0,0,1),function(n,o,s){i.gluTessCallback(De().gluEnum.GLU_TESS_COMBINE,s?e:t),i.gluTessBeginPolygon(o);for(const t of n){i.gluTessBeginContour();for(const e of t)i.gluTessVertex(e,e);i.gluTessEndContour()}return i.gluTessEndPolygon(),o}})()}),Object.defineProperties(Fe,{...d().getStaticProperties("NurbsTrimmedSurface","NURBS",4,"geometry","3.0"),fieldDefinitions:{value:new(h())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"uTessellation",new(s().SFInt32)),new(l())(g().inputOutput,"vTessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"uClosed",new(s().SFBool)),new(l())(g().initializeOnly,"vClosed",new(s().SFBool)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"texCoord",new(s().SFNode)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().inputOnly,"addTrimmingContour",new(s().MFNode)),new(l())(g().inputOnly,"removeTrimmingContour",new(s().MFNode)),new(l())(g().inputOutput,"trimmingContour",new(s().MFNode))]),enumerable:!0}});const Ve=Fe,je=m().add("NurbsTrimmedSurface",Ve);n().add({name:"NURBS",concreteNodes:[v,T,It,kt,Xt,te,ne,he,ce,me,be,Oe,je],abstractNodes:[N,Zt,M]});m().add("NURBSComponent",undefined)})();