/* X_ITE v10.2.0 */
const t=window[Symbol.for("X_ITE.X3D-10.2.0")];(()=>{var e={n:t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},d:(t,i)=>{for(var n in i)e.o(i,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const i=t.Components;var n=e.n(i);const o=t.Fields;var s=e.n(o);const r=t.X3DFieldDefinition;var l=e.n(r);const h=t.FieldDefinitionArray;var a=e.n(h);const u=t.X3DNode;var d=e.n(u);const c=t.X3DConstants;var g=e.n(c);const p=t.X3DCast;var _=e.n(p);const f=t.Namespace;var m=e.n(f);function w(t){d().call(this,t),this.addType(g().Contour2D),this.childNodes=[]}function v(t,e){const i=new Set(e);return t.filter((t=>!i.has(t)))}Object.assign(Object.setPrototypeOf(w.prototype,d().prototype),{initialize(){d().prototype.initialize.call(this),this._addChildren.addInterest("set_addChildren__",this),this._removeChildren.addInterest("set_removeChildren__",this),this._children.addInterest("set_children__",this),this.set_children__()},set_addChildren__(){this._addChildren.setTainted(!0),this._addChildren.assign(v(this._addChildren,this._children));for(const t of this._addChildren)this._children.push(t);this._addChildren.length=0,this._addChildren.setTainted(!1)},set_removeChildren__(){this._removeChildren.setTainted(!0),this._children.assign(v(this._children,this._removeChildren)),this._removeChildren.length=0,this._removeChildren.setTainted(!1)},set_children__(){const t=this.childNodes;t.length=0;for(const e of this._children){const i=_()(g().NurbsCurve2D,e);if(i)t.push(i);else{const i=_()(g().ContourPolyline2D,e);if(i){t.push(i);continue}}}},addTrimmingContour(t){for(const e of this.childNodes)t.push(e.tessellate(2))}}),Object.defineProperties(w,{...d().getStaticProperties("Contour2D","NURBS",4,"trimmingContour","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"addChildren",new(s().MFNode)),new(l())(g().inputOnly,"removeChildren",new(s().MFNode)),new(l())(g().inputOutput,"children",new(s().MFNode))]),enumerable:!0}});const y=w,b=m().add("Contour2D",y);function C(t){d().call(this,t),this.addType(g().X3DNurbsControlCurveNode)}Object.setPrototypeOf(C.prototype,d().prototype),Object.defineProperties(C,d().getStaticProperties("X3DNurbsControlCurveNode","NURBS",1));const O=C,N=m().add("X3DNurbsControlCurveNode",O),P=t.Vector3;var S=e.n(P);function D(t){N.call(this,t),this.addType(g().ContourPolyline2D),this.controlPoints=[]}Object.assign(Object.setPrototypeOf(D.prototype,N.prototype),{tessellate(t){switch(t){case 0:{const t=this._controlPoint.getValue(),e=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n;e[i+0]=t[i+0],e[i+1]=t[i+1]}return e.length=2*i,e}case 1:{const t=this._controlPoint.getValue(),e=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n,o=3*n;e[o+0]=t[i+0],e[o+1]=0,e[o+2]=t[i+1]}return e.length=3*i,e}case 3:{const t=this._controlPoint.getValue(),e=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n;e[n]=new(S())(t[i+0],t[i+1],0)}return e.length=i,e}}}}),Object.defineProperties(D,{...d().getStaticProperties("ContourPolyline2D","NURBS",3,"children","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"controlPoint",new(s().MFVec2d))]),enumerable:!0}});const F=D,V=m().add("ContourPolyline2D",F),R=t.X3DGeometryNode;var T=e.n(R);const z=t.Vector2;var j=e.n(z);const I=t.Vector4;var x=e.n(I);const k={getTessellation:(t,e)=>t>0?t+1:t<0?-t*e+1:2*e+1,getClosed2D(t,e,i,n){const o=n.length;return(!(i.length===o)||i[0]===i[o-1])&&(!!n[0].equals(n[o-1])&&!!this.isPeriodic(t,o,e))},getClosed:(()=>{const t=new(S()),e=new(S());return function(i,n,o,s){const r=s.getSize();return(!(o.length===r)||o[0]===o[r-1])&&(!!s.get1Point(0,t).equals(s.get1Point(r-1,e))&&!!this.isPeriodic(i,r,n))}})(),getUClosed:(()=>{const t=new(S()),e=new(S());return function(i,n,o,s,r,l){const h=r.length===l.getSize();for(let i=0,s=o;i<s;++i){const o=i*n,s=i*n+n-1;if(h&&r[o]!==r[s])return!1;if(!l.get1Point(o,t).equals(l.get1Point(s,e)))return!1}return!!this.isPeriodic(i,n,s)}})(),getVClosed:(()=>{const t=new(S()),e=new(S());return function(i,n,o,s,r,l){const h=r.length===l.getSize();for(let i=0,s=n;i<s;++i){const s=i,a=(o-1)*n+i;if(h&&r[s]!==r[a])return!1;if(!l.get1Point(s,t).equals(l.get1Point(a,e)))return!1}return!!this.isPeriodic(i,o,s)}})(),isPeriodic(t,e,i){if(i.length===e+t){{let e=1;for(let n=1,o=t;n<o;++n)e+=i[n]===i[0];if(e===t)return!1}{let e=1;for(let n=i.length-t,o=i.length-1;n<o;++n)e+=i[n]===i[o];if(e===t)return!1}}return!0},getKnots(t,e,i,n,o){const s=t||[];for(let t=0,e=o.length;t<e;++t)s[t]=o[t];s.length=o.length;let r=!0;if(s.length===n+i){r=!1;let t=0;for(let e=1,n=s.length;e<n;++e)s[e]==s[e-1]?++t:t=0,t>i-1&&(r=!0),s[e-1]>s[e]&&(r=!0)}if(r)for(let t=0,e=n+i;t<e;++t)s[t]=t/(e-1);if(e)for(let t=1,e=i-1;t<e;++t)s.push(s.at(-1)+(s[t]-s[t-1]));return s},getWeights(t,e,i){if(i.length!==e)return;const n=t||[];for(let t=0;t<e;++t)n[t]=i[t];return n.length=e,n},getUVWeights(t,e,i,n){const o=e*i;if(n.length!==o)return;const s=t||[];for(let t=0,o=0;t<e;++t)for(let t=0;t<i;++t,++o)s[o]=n[o];return s.length=o,s},getControlPoints2D(t,e,i,n,o){const s=t||[],r=o.getValue(),l=o.length,h=!!n,a=h?S():j();s.haveWeights!==h&&(s.haveWeights=h,s.length=0);for(let t=0;t<l;++t){const e=2*t,i=s[t]||new a(0,0,0);s[t]=i.set(r[e+0],r[e+1],h?n[t]:0)}if(s.length=l,e)for(let t=1,e=i-1;t<e;++t)s.push(s[t]);return s},getControlPoints(t,e,i,n,o){const s=t||[],r=o.getSize(),l=!!n,h=l?x():S();s.haveWeights!==l&&(s.haveWeights=l,s.length=0);for(let t=0;t<r;++t){const e=s[t]=o.get1Point(t,s[t]||new h(0,0,0,0));l&&(e.w=n[t])}if(s.length=r,e)for(let t=1,e=i-1;t<e;++t)s.push(s[t]);return s},getUVControlPoints(t,e,i,n,o,s,r,l,h){const a=t||[],u=!!l,d=u?x():S();a.haveWeights!==u&&(a.haveWeights=u,a.length=0);for(let t=0;t<s;++t){let e=a[t];e||(e=a[t]=[]);for(let i=0;i<r;++i){const n=i*s+t;e[i]=h.get1Point(n,e[i]||new d(0,0,0,0)),u&&(e[i].w=l[n])}if(e.length=r,i)for(let t=1,i=o-1;t<i;++t)e.push(e[t])}if(a.length=s,e)for(let t=1,e=n-1;t<e;++t)a.push(a[t]);return a},getTexControlPoints(t,e,i,n,o,s,r,l){const h=t||[];for(let t=0;t<s;++t){let e=h[t];e||(e=h[t]=[]);for(let i=0;i<r;++i){const n=i*s+t;e[i]=l.get1Point(n,e[i]||new(x()))}if(e.length=r,i)for(let t=1,i=o-1;t<i;++t)e.push(e[t])}if(h.length=s,e)for(let t=1,e=n-1;t<e;++t)h.push(h[t]);return h}},A=m().add("NURBS",k);function B(t){T().call(this,t),this.addType(g().X3DParametricGeometryNode)}Object.assign(Object.setPrototypeOf(B.prototype,T().prototype),{getKnots:(t,e,i,n,o)=>A.getKnots(t,e,i,n,o)}),Object.defineProperties(B,d().getStaticProperties("X3DParametricGeometryNode","NURBS",1));const K=B,M=m().add("X3DParametricGeometryNode",K),E=t.X3DLineGeometryNode;var U=e.n(E);const W=m().add("is-ndarray",(function(t){return!!t&&(!!t.dtype&&new RegExp("function View[0-9]+d(:?"+t.dtype+")+").test(String(t.constructor)))})),q=m().add("is-ndarray-like",(function(t){return!!t&&(void 0!==t.data&&Array.isArray(t.shape)&&void 0!==t.offset&&void 0!==t.stride)})),G=m().add("is-array-like",(function(t){return Array.isArray(t)||ArrayBuffer.isView(t)||void 0!==t.length}));function Y(t){if(t){if(W(t)||q(t))return"generic"===t.dtype?Y.GENERIC_NDARRAY:Y.NDARRAY;if(G(t)){for(var e=t;G(e[0]);e=e[0]);return"x"in e?Y.ARRAY_OF_OBJECTS:Y.ARRAY_OF_ARRAYS}throw new Error("Unhandled data type. Got type: "+typeof t)}}Y.ARRAY_OF_OBJECTS="Obj",Y.ARRAY_OF_ARRAYS="Arr",Y.NDARRAY="Nd",Y.GENERIC_NDARRAY="GenNd",Y.PACKED="PackArr";const X=Y,J=m().add("infer-type",X);const L=m().add("cache-key",(function(t,e,i,n,o,s){var r,l,h=[],a=!1;for(r=0;r<t.splineDimension;r++){var u=G(t.knots)&&G(t.knots[r]);u&&(a=!0),h.push("Deg"+t.degree[r]+(u?"":"Uniform")+((l=t.boundary[r])[0].toUpperCase()+l.slice(1)))}var d=[[a?"NU":"",t.weights?"RBS":"BS"].join("")+t.dimension+"D",h.join("_")];return n&&d.push(n+"Pts"),o&&d.push(o+"Wts"),s&&d.push(s+"Kts"),e&&d.push("debug"),i&&d.push("chk"),d.join("_")}));var Z=function t(e,i){return function(i,n){void 0===i||Array.isArray(i)||(i=[i]);for(var o=[],s=0;s<i.length;s++)o.push(t.sum(i[s]));if(n)for(i=0;i<o.length;i++)void 0!==n[i]&&(o[i]="("+o[i]+" + "+n[i]+") % "+n[i]);return e+o.join("_")}};Z.sum=function(t){return 0===(t=(t=Array.isArray(t)?t:[t]).filter((t=>void 0!==t&&0!==t))).length&&t.push(0),t.join(" + ")};const H=Z,Q=m().add("variable",H);var $=[".x",".y",".z",".w"];function tt(t){return function(e,i){void 0===e||Array.isArray(e)||(e=[e]);for(var n=[],o=0;o<e.length;o++)n.push(Q.sum(e[o]));if(i)for(e=0;e<n.length;e++)void 0!==i[e]&&(n[e]="("+n[e]+" + "+i[e]+") % "+i[e]);return t(n)}}function et(t,e){if(e)switch(J(e)){case J.ARRAY_OF_OBJECTS:return tt((e=>{var i=e.pop();return t+"["+e.join("][")+"]"+$[i]}));case J.ARRAY_OF_ARRAYS:return tt((e=>t+"["+e.join("][")+"]"));case J.GENERIC_NDARRAY:return tt((e=>t+".get("+e.join(",")+")"));case J.NDARRAY:return tt((e=>{for(var i=[t+"Offset"],n=0;n<e.length;n++)i.push(t+"Stride"+n+" * ("+e[n]+")");return t+"["+i.join(" + ")+"]"}));case J.PACKED:default:return}}const it=m().add("create-accessors",(function(t){var e,i={};return(e=et("x",t.points))&&(i.point=e),(e=et("w",t.weights))&&(i.weight=e),(e=et("k",t.knots))&&(i.knot=e),i}));var nt=[],ot=[];const st=m().add("numerical-derivative",(function(t,e,i){if(1!==e)throw new Error("Numerical derivative not implemented for order n = "+e+".");var n,o=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(nt.length=this.splineDimension,n=0;n<this.splineDimension;n++)nt[n+1]=arguments[n+3];var s,r,l,h=this.domain,a=h[i][0],u=h[i][1],d=nt[i+1],c=(u-a)*o;for("closed"===this.boundary[i]?(s=a+(d-a-c+(l=u-a))%l,r=a+(d-a+c+l)%l,c*=2):(s=Math.min(u,Math.max(a,d-c)),c=(r=Math.min(u,Math.max(a,d+c)))-s),nt[i+1]=s,nt[0]=ot,this.evaluate.apply(null,nt),nt[i+1]=r,nt[0]=t,this.evaluate.apply(null,nt),n=0;n<this.dimension;n++)t[n]=(t[n]-ot[n])/c;return t})),rt=m().add("ndloop",(function(t,e){for(var i=1,n=0,o=[];n<t.length;n++)i*=Array.isArray(t[n])?t[n][1]-t[n][0]:t[n],o[n]=Array.isArray(t[n])?t[n][0]:0;for(var s=0;s<i;s++)for(e(o.slice()),n=t.length-1;n>=0;n--){if(o[n]!==(Array.isArray(t[n])?t[n][1]:t[n])-1){o[n]++;break}o[n]=Array.isArray(t[n])?t[n][0]:0}})),lt=m().add("accessor-preamble",(function(t,e,i,n){var o=[];switch(J(n)){case J.NDARRAY:o.push("  var "+e+" = "+i+".data;"),o.push("  var "+e+"Offset = "+i+".offset;");for(var s=0;s<n.dimension;s++)o.push("  var "+e+"Stride"+s+" = "+i+".stride["+s+"];");break;case J.ARRAY_OF_OBJECTS:case J.ARRAY_OF_ARRAYS:o.push("  var "+e+" = "+i+";")}return o.join("\n")})),ht=m().add("size-getter",(function(t,e,i){if(t){if(q(t))return e+".shape["+i+"]";for(var n=e,o=0;o<i;o++)n+="[0]";return n+".length"}return"this.size["+i+"]"}));var at={},ut={};const dt=m().add("evaluator",(function(t,e,i,n,o,s,r){var l,h,a,u,d,c,g=e.splineDimension,p=e.points,_=e.degree,f=e.weights,m=void 0!==f,w=e.knots,v=e.dimension,y=e.boundary;if(null!=r){Array.isArray(r)||(r=[r]);var b=0;for(l=0;l<g;l++)void 0===r[l]&&(r[l]=0),b+=r[l];if(m&&b>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+b+".")}s&&(t="Basis"+t),r&&(t="Der"+r.join("_")+"_"+t);var C=at[t];if(n)var O="function"==typeof n?n:console.log;if(C)return n&&O(ut[t]),C.bind(e);var N=[],P="evaluate"+t,S=i.point;s&&(S=function(t,e){for(var i=[],n=0;n<t.length;n++){for(var o=t[n],s=[],r=0;r<o.length;r++)0!==o[r]&&s.push(o[r]);o=s.join(" + "),e[n]&&(o="("+o+" + "+e[n]+") % "+e[n]),i.push(o+" === "+z(n))}return"(("+i.join(" && ")+") ? 1 : 0)"});var D=i.weight,F=i.knot,V=Q("k"),R=Q("x"),T=Q("w"),z=Q("i"),j=Q("t"),I=n?"domain":"d",x=Q(n?"size":"s"),k=Q(n?"knotIndex":"j"),A=!0;for(d=0;d<g;d++)G(w)&&G(w[d])&&(A=!1);function B(t){N.push("  "+(t||""))}function K(t){n&&B(t)}if(s)var M=[];var E=[];for(l=0;l<g;l++)s&&M.push(z([l])),E.push(j([l]));for(N.push("function "+P+" ("+(s?"":"out, ")+E.join(", ")+(s?", "+M.join(", "):"")+") {"),B("var h, m, a, b;"),o&&(B("var "+I+" = this.domain;"),B("for (var i = 0; i < this.splineDimension; i++) {"),B("  a = arguments[i + 1];"),B("  if (a < "+I+"[i][0] || a > "+I+"[i][1] || a === undefined || isNaN(a)) {"),B('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+I+'[i][0]+", "+'+I+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),B("  }"),B("}")),d=0;d<g;d++)B("var "+x(d)+" = "+ht(p,"this.points",d)+";");function U(t,e,i){return"("+t+") ? ("+e+") : ("+i+")"}N.push(lt(e,"x","this.points",p)),m&&N.push(lt(e,"w","this.weights",f)),A||N.push(lt(e,"k","this.knots",w));var W=[];for(d=0;d<g;d++)switch(J(w)){case J.NDARRAY:W[d]=!0;break;case J.ARRAY_OF_ARRAYS:W[d]=G(w[d])}for(d=0;d<g;d++)if(W[d])for(K("\n  // Bisect to locate the knot interval in dimension "+d+"\n"),B("var "+k(d)+" = 0;"),B("h = "+x(d)+";"),B("while(h > "+k(d)+" + 1) {"),B("  m = 0.5 * (h + "+k(d)+") | 0;"),B("  if ("+F([d,"m"])+" > "+j(d)+") h = m;"),B("  else "+k(d)+" = m;"),B("}"),K("\n  // Fetch knots for dimension "+d+"\n"),l=1-_[d];l<=_[d];l++)"closed"===y[d]?B(l<0?"var "+V([d,l+_[d]-1])+" = "+U(k(d)+" < "+-l,F([d,0])+" + "+F([d,[x(d),k(d),l]])+" - "+F([d,[x(d)]]),F([d,[k(d),l]]))+";":l>0?"var "+V([d,l+_[d]-1])+" = "+U(k(d)+" + "+l+" > "+x(d),F([d,x(d)])+" + "+F([d,l+" + "+k(d)+" - "+x(d)])+" - "+F([d,0]),F([d,[k(d),l]]))+";":"var "+V([d,l+_[d]-1])+" = "+F([d,[k(d),l]])+";"):B("var "+V([d,l+_[d]-1])+" = "+F([d,[k(d),l]])+";");else{for(K("\n  // Directly compute knot interval for dimension "+d+"\n"),"closed"===y[d]?B(k(d)+" = ("+j(d)+" | 0) % "+x(d)+";"):(B(k(d)+" = ("+j(d)+" | 0);"),B("if ("+k(d)+" < "+_[d]+") "+k(d)+" = "+_[d]+";"),B("if ("+k(d)+" > "+x(d)+" - 1) "+k(d)+" = "+x(d)+" - 1;")),K("\n  // Compute and clamp knots for dimension "+d+"\n"),l=1-_[d];l<=_[d];l++)B("var "+(c=V([d,l+_[d]-1]))+" = "+k(d)+" + "+l+";");if("clamped"===y[d])for(l=1-_[d];l<=_[d];l++)c=V([d,l+_[d]-1]),l<0&&B("if ("+c+" < "+_[d]+") "+c+" = "+_[d]+";"),l>0&&B("if ("+c+" > "+x(d)+") "+c+" = "+x(d)+";");"closed"===y[d]&&(K("\n  // Wrap the B-Spline parameter for closed boundary"),B(j(d)+" %= "+x(d)+";"))}for(d=0,a=[];d<g;d++)a[d]=_[d]+1;for(m&&(K("\n  // Fetch weights\n"),rt(a,(function(t){for(var e=[],i=[],n=0;n<g;n++)e[n]=[k(n),t[n]-_[n]],"closed"===y[n]&&t[n]-_[n]<0&&(i[n]=x(n));B("var "+T(t)+" = "+D(e,i)+";")}))),n&&B(m?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),rt(a,(function(t){for(var e=[],i=[],n=0;n<g;n++)e[n]=[k(n),t[n]-_[n]],"closed"===y[n]&&t[n]-_[n]<0&&(i[n]=x(n));if(s)B(m?"var "+R(t)+" = "+S(e,i)+" * "+T(t)+";":"var "+R(t)+" = "+S(e,i)+";");else for(n=0;n<v;n++){var o=t.concat(n);e[g]=n,B(m?"var "+R(o)+" = "+S(e,i)+" * "+T(t)+";":"var "+R(o)+" = "+S(e,i)+";")}})),K("\n"),K('// Perform De Boor"s algorithm'),d=a.length-1;d>=0;d--)for(a[d]=[_[d],_[d]+1],l=0;l<_[d];l++)for(K("\n  // Degree "+_[d]+" evaluation in dimension "+d+", step "+(l+1)+"\n"),h=_[d];h>l;h--){var q=r&&_[d]-l-r[d]<=0;q?(B("m = 1 / ("+V([d,h-l+_[d]-1])+" - "+V([d,h-1])+");"),m&&(B("a = ("+j(d)+" - "+V([d,h-1])+") * m;"),B("b = 1 - a;"))):(B("a = ("+j(d)+" - "+V([d,h-1])+") / ("+V([d,h-l+_[d]-1])+" - "+V([d,h-1])+");"),B("b = 1 - a;")),m&&rt(a,(function(t){var e=t.slice(),i=t.slice();e[d]=h,i[d]=h-1,q&&m&&B("h = "+T(e)+";"),B(T(e)+" = b * "+T(i)+" + a * "+T(e)+";")})),rt(a,(function(t){var e,i,n,o=t.slice(),r=t.slice();if(o[d]=h,r[d]=h-1,q){var a=l+1;if(s)e=m?"h * "+T(r)+" / "+T(o)+" * ":"",i=R(o)+(m?" / h":""),n=R(r)+(m?" / "+T(r):""),B(R(o)+" = "+a+" * "+e+"("+i+" - "+n+") * m;");else{var c=o.slice(),p=r.slice();for(u=0;u<v;u++)c[g]=p[g]=u,e=m?"h * "+T(r)+" / "+T(o)+" * ":"",i=R(c)+(m?" / h":""),n=R(p)+(m?" / "+T(r):""),B(R(c)+" = "+a+" * "+e+"("+i+" - "+n+") * m;")}}else if(s)B(R(o)+" = b * "+R(r)+" + a * "+R(o)+";");else for(u=0;u<v;u++)o[g]=r[g]=u,B(R(o)+" = b * "+R(r)+" + a * "+R(o)+";")})),K("\n")}if(n&&B(m?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),s)B(m?"return "+R(_)+" / "+T(_)+";":"return "+R(_)+";");else for(d=0;d<v;d++)B(m?"out["+d+"] = "+R(_.concat([d]))+" / "+T(_)+";":"out["+d+"] = "+R(_.concat([d]))+";");if(s||B("return out;"),N.push("}"),n){var Y=N.join("\n");O(Y),ut[t]=Y}var X=new Function([N.join("\n"),"; return ",P].join(""))();return at[t]=X,X.bind(e)}));var ct={};const gt=m().add("transform",(function(t,e,i,n){var o,s,r,l,h,a,u,d,c=ct[t];if(c)return c.bind(e);var g=[],p="transform"+t;g.push("function "+p+"(m) {"),g.push("var i, w;"),g.push(lt(e,"x","this.points",e.points));var _=Q(n?"size":"s");for(o=0;o<e.splineDimension;o++)g.push("var "+_(o)+" = "+ht(e.points,"this.points",o)+";");for(l=[],o=0;o<e.splineDimension;o++)r="i"+o,l.push(r),g.push("for ("+r+" = "+_(o)+"- 1; "+r+" >= 0; "+r+"--) {");for(o=0;o<e.dimension;o++)g.push("x"+o+" = "+i.point(l.concat([o])));for(h=[],o=0;o<e.dimension;o++)h.push("m["+((e.dimension+1)*(o+1)-1)+"] * x"+o);for(h.push("m["+((e.dimension+1)*(e.dimension+1)-1)+"]"),g.push("var w = ("+h.join(" + ")+") || 1.0;"),o=0;o<e.dimension;o++){for(h=[],a=e.dimension,s=0;s<a;s++)h.push("m["+(s*(a+1)+o)+"] * x"+s);h.push("m["+(s*(a+1)+o)+"]"),d=i.point(l.concat([o])),u="("+h.join(" + ")+") / w",g.push(d+" = "+u+";")}for(o=e.splineDimension-1;o>=0;o--)g.push("}");g.push("return this;"),g.push("}");var f=new Function([g.join("\n"),"; return ",p].join(""))();return n&&console.log(g.join("\n")),ct[t]=f,f.bind(e)}));var pt={};const _t=m().add("support",(function(t,e,i,n,o){var s=pt[t];if(s)return s.bind(e);var r,l,h,a=e.degree,u=e.knots,d=e.splineDimension,c=e.boundary,g=[],p="support"+t,_=i.knot,f=Q("t"),m=n?"domain":"d",w=Q(n?"size":"s"),v=Q(n?"knotIndex":"i"),y=!0;for(h=0;h<d;h++)G(u)&&G(u[h])&&(y=!1);function b(t){g.push("  "+(t||""))}var C=[];for(r=0;r<d;r++)C.push(f([r]));g.push("function "+p+" (out, "+C.join(", ")+") {");var O=0;function N(t,e){b(void 0===e?"out["+O+++"] = "+t.join(" + ")+";":"out["+O+++"] = ("+t.join(" + ")+" + "+e+") % "+e+";")}for(b("var h, m;"),b("var c = 0;"),o&&(b("var "+m+" = this.domain;"),b("for (var i = 0; i < this.splineDimension; i++) {"),b("  a = arguments[i + 1];"),b("  if (a < "+m+"[i][0] || a > "+m+"[i][1] || a === undefined || isNaN(a)) {"),b('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+m+'[i][0]+", "+'+m+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),b("  }"),b("}")),h=0;h<d;h++)b("var "+w(h)+" = "+ht(e.points,"this.points",h)+";");y||g.push(lt(e,"k","this.knots",u));var P=[];for(h=0;h<d;h++)switch(J(u)){case J.NDARRAY:P[h]=!0;break;case J.ARRAY_OF_ARRAYS:P[h]=G(u[h])}for(h=0;h<d;h++)P[h]?(b("var "+v(h)+" = 0;"),b("h = "+w(h)+";"),b("while(h > "+v(h)+" + 1) {"),b("  m = 0.5 * (h + "+v(h)+") | 0;"),b("  if ("+_([h,"m"])+" > "+f(h)+") h = m;"),b("  else "+v(h)+" = m;"),b("}")):"closed"===c[h]?b(v(h)+" = ("+f(h)+" | 0) % "+w(h)+";"):(b(v(h)+" = ("+f(h)+" | 0);"),b("if ("+v(h)+" < "+a[h]+") "+v(h)+" = "+a[h]+";"),b("if ("+v(h)+" > "+w(h)+" - 1) "+v(h)+" = "+w(h)+" - 1;"));for(h=0,l=[];h<d;h++)l[h]=a[h]+1;rt(l,(function(t){for(var e=[],i=[],n=0;n<d;n++)e[n]=[v(n),t[n]-a[n]],"closed"===c[n]&&t[n]-a[n]<0&&(i[n]=w(n));for(n=0;n<d;n++)N(e[n],i[n])})),b("out.length = "+O+";"),b("return out;"),g.push("}"),n&&console.log(g.join("\n"));var S=new Function([g.join("\n"),"; return ",p].join(""))();return pt[t]=S,S.bind(e)}));var ft=[];const mt=m().add("sample",(function(t,e,i){i=i||{};var n=(t=t||{}).points=t.points||[],o=t.faces=t.faces||[],s=i.haveWeights,r=e.dimension-s;if(Array.isArray(i.resolution))var l=i.resolution;else{var h=void 0===i.resolution?31:i.resolution;l=new Array(e.splineDimension).fill(h)}switch(e.splineDimension){case 1:for(var a=(f=(w=l[0])+!(y="closed"===e.boundary[0]))*r,u=(C=(m=i.domain||e.domain)[0])[1]-C[0],d=0;d<f;++d){var c=C[0]+u*d/w,g=d*r;if(e.evaluate(ft,c),s)for(var p=ft[r],_=0;_<r;++_)n[g+_]=ft[_]/p;else for(_=0;_<r;++_)n[g+_]=ft[_]}n.length=a;break;case 2:var f,m,w=l[0],v=l[1],y="closed"===e.boundary[0],b=v+!(D="closed"===e.boundary[1]),C=(a=(f=w+!y)*b*r,(m=i.domain||e.domain)[0]),O=m[1],N=(u=C[1]-C[0],O[1]-O[0]);for(d=0;d<f;++d){c=C[0]+u*d/w;for(var P=0;P<b;++P){var S=O[0]+N*P/v;g=(d+f*P)*r;if(e.evaluate(ft,c,S),s)for(p=ft[r],_=0;_<r;++_)n[g+_]=ft[_]/p;else for(_=0;_<r;++_)n[g+_]=ft[_]}}n.length=a;y=i.closed[0];var D=i.closed[1],F=0;for(d=0;d<w;++d){var V=d,R=d+1;y&&(R%=w);for(P=0;P<v;++P){var T=P,z=P+1;D&&(z%=v),o[F++]=V+f*T,o[F++]=R+f*T,o[F++]=R+f*z,o[F++]=V+f*T,o[F++]=R+f*z,o[F++]=V+f*z}}o.length=F;break;default:throw new Error("Can only sample contours and surfaces")}return t}));var wt={open:"open",closed:"closed",clamped:"clamped"};function vt(t){return null==t}function yt(t,e,i,n,o,s){var r,l;!t||G(t)||W(t)?(s=s||{},this.weights=n,this.knots=i,this.degree=e,this.points=t,this.boundary=o,this.debug=s.debug,this.checkBounds=!!s.checkBounds,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0})):(s=t,this.debug=t.debug,this.checkBounds=!!t.checkBounds,this.weights=t.weights,this.knots=t.knots,this.degree=t.degree,this.boundary=t.boundary,this.points=t.points,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0}));var h=J(this.points),a=J(this.weights),u=J(this.knots);if(this.points)switch(h){case J.GENERIC_NDARRAY:case J.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case J.ARRAY_OF_OBJECTS:case J.ARRAY_OF_ARRAYS:var d=0,c=this.size||[];c.length=0;for(var g=this.points;G(g[0]);g=g[0])d++,c.push(g.length);if(0===d)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:d,writable:!1,configurable:!0},dimension:{value:g.length,writable:!1,configurable:!0},size:{get:function(){var t=[];t.length=0;for(var e=0,i=this.points;e<this.splineDimension;e++,i=i[0])t[e]=i.length;return t},set:function(){throw new Error('Cannot assign to read only property "size"')},configurable:!0}});break;case J.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(G(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(G(this.degree)){for(r=0;r<this.splineDimension;r++)if(vt(this.degree[r]))throw new Error("Missing degree in dimension "+(r+1))}else{var p=!vt(this.degree),_=vt(this.degree)?2:this.degree;for(this.degree=[],r=0;r<this.splineDimension;r++)if(this.size[r]<=_){if(p)throw new Error("Expected at least "+(_+1)+" points for degree "+_+" spline in dimension "+(r+1)+" but got only "+this.size[r]);this.degree[r]=this.size[r]-1}else this.degree[r]=_}if(l="string"!=typeof this.boundary?"open":this.boundary,!wt[l])throw new Error("Boundary type must be one of "+Object.keys(wt)+". Got "+l);for(this.boundary=G(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,r=0;r<this.splineDimension;r++)if(this.boundary[r]=vt(this.boundary[r])?l:this.boundary[r],!wt[l])throw new Error("Boundary type must be one of "+Object.keys(wt)+". Got "+l+" for dimension "+(r+1));switch(u){case J.ARRAY_OF_ARRAYS:for(G(this.knots)&&this.knots.length>0&&!G(this.knots[0])&&(this.knots=[this.knots]),r=0;r<this.splineDimension;r++){if(this.size[r]<=this.degree[r])throw new Error("Expected at least "+(this.degree[r]+1)+" points in dimension "+(r+1)+" but got "+this.size[r]+".");if(G(this.knots[r])){if("closed"!==this.boundary[r]&&this.knots[r].length!==this.degree[r]+this.size[r]+1)throw new Error("Expected "+(this.degree[r]+this.size[r]+1)+" knots in dimension "+(r+1)+" but got "+this.knots[r].length+".");if("closed"===this.boundary[r]&&this.knots[r].length!==this.size[r]+1&&!(this.knots[r].length===this.size[r]+this.degree[r]+1))throw new Error("Expected "+(this.size[r]+1)+" knots for closed spline in dimension "+(r+1)+" but got "+this.knots[r].length+".")}}case J.NDARRAY:}var f=L(this,this.debug,this.checkBounds,h,a,u);if(f!==this.__cacheKey){this.__cacheKey=f;var m=it(this);this.evaluate=dt(this.__cacheKey,this,m,this.debug,this.checkBounds,!1),this.transform=gt(this.__cacheKey,this,m,this.debug),this.support=_t(this.__cacheKey,this,m,this.debug,this.checkBounds),this.evaluator=function(t,e){return dt(this.__cacheKey,this,m,this.debug,this.checkBounds,e,t)}}return this.numericalDerivative=st.bind(this),this}function bt(){var t,e=[],i=this.points;i?q(i)&&(t=i.shape):t=this.size;for(var n=0;n<this.splineDimension;n++){var o=t?t[n]:i.length,s=this.degree[n],r="closed"===this.boundary[n];if(this.knots&&this.knots[n]){var l=this.knots[n];e[n]=[l[r?0:s],l[o]]}else e[n]=[r?0:s,o];i&&(i=i[0])}return e}function Ct(t,e,i,n,o,s){var r=function(t,e,i,n,o,s){return l(t,e,i,n,o,s),r},l=yt.bind(r);return Object.defineProperty(r,"domain",{get:bt}),l(t,e,i,n,o,s),r}Ct.sample=mt;const Ot=Ct,Nt=m().add("nurbs",Ot);function Pt(t){M.call(this,t),U().call(this,t),this.addType(g().NurbsCurve),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]}}Object.assign(Object.setPrototypeOf(Pt.prototype,M.prototype),U().prototype,{initialize(){M.prototype.initialize.call(this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},getTessellation(t){return A.getTessellation(this._tessellation.getValue(),t-this._order.getValue())},getClosed(t,e,i,n){return!!this._closed.getValue()&&A.getClosed(t,e,i,n)},getWeights:(t,e,i)=>A.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>A.getControlPoints(t,e,i,n,o),tessellate(){if(this._order.getValue()<2)return[];if(!this.controlPointNode)return[];if(this.controlPointNode.getSize()<this._order.getValue())return[];const t=this.getVertices(),e=[];if(t.length){const i=t.length;for(let n=0;n<i;n+=8)e.push(t[n],t[n+1],t[n+2]);e.push(t[i-4],t[i-3],t[i-2])}return e},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),n=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=(n.at(-1),n[0],this._order.getValue()-1),s=this.surface=(this.surface||Nt)({boundary:["open"],degree:[o],knots:[n],points:i,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(n.length),this.sampleOptions.haveWeights=!!e;const r=Nt.sample(this.mesh,s,this.sampleOptions).points,l=this.getVertices();for(let t=3,e=r.length;t<e;t+=3){const e=t-3;l.push(r[e],r[e+1],r[e+2],1),l.push(r[t],r[t+1],r[t+2],1)}},dispose(){M.prototype.dispose.call(this)}}),Object.defineProperties(Pt,{...d().getStaticProperties("NurbsCurve","NURBS",1,"geometry","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"tessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"closed",new(s().SFBool)),new(l())(g().initializeOnly,"order",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode))]),enumerable:!0}});const St=Pt,Dt=m().add("NurbsCurve",St);function Ft(t){N.call(this,t),this.addType(g().NurbsCurve2D),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]},this.array=[]}Object.assign(Object.setPrototypeOf(Ft.prototype,N.prototype),{getTessellation(t){return A.getTessellation(this._tessellation.getValue(),t-this._order.getValue())},getClosed(t,e,i,n){return!!this._closed.getValue()&&A.getClosed2D(t,e,i,n)},getKnots:(t,e,i,n,o)=>A.getKnots(t,e,i,n,o),getWeights:(t,e,i)=>A.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>A.getControlPoints2D(t,e,i,n,o),tessellate(t){const e=this.array;if(e.length=0,this._order.getValue()<2)return e;if(this._controlPoint.length<this._order.getValue())return e;const i=this.getClosed(this._order.getValue(),this._knot,this._weight,this._controlPoint),n=this.getWeights(this.weights,this._controlPoint.length,this._weight),o=this.getControlPoints(this.controlPoints,i,this._order.getValue(),n,this._controlPoint),s=this.getKnots(this.knots,i,this._order.getValue(),this._controlPoint.length,this._knot),r=(s.at(-1),s[0],this._order.getValue()-1),l=this.surface=(this.surface||Nt)({boundary:["open"],degree:[r],knots:[s],points:o,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(s.length),this.sampleOptions.haveWeights=!!n;const h=Nt.sample(this.mesh,l,this.sampleOptions).points;switch(t){case 0:for(let t=0,i=h.length;t<i;t+=2)e.push(h[t],h[t+1]);break;case 1:for(let t=0,i=h.length;t<i;t+=2)e.push(h[t],0,h[t+1]);break;case 2:for(let t=0,i=h.length;t<i;t+=2)e.push(new(S())(h[t],h[t+1],0))}return e}}),Object.defineProperties(Ft,{...d().getStaticProperties("NurbsCurve2D","NURBS",3,"children","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"tessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"closed",new(s().SFBool)),new(l())(g().initializeOnly,"order",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().MFVec2d))]),enumerable:!0}});const Vt=Ft,Rt=m().add("NurbsCurve2D",Vt),Tt=t.X3DChildNode;var zt=e.n(Tt);const jt=t.OrientationInterpolator;var It=e.n(jt);const xt=t.Rotation4;var kt=e.n(xt);function At(t){zt().call(this,t),this.addType(g().NurbsOrientationInterpolator),this.addChildObjects(g().inputOutput,"rebuild",new(s().SFTime)),this.interpolator=new(It())(t),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}Object.assign(Object.setPrototypeOf(At.prototype,zt().prototype),{initialize(){zt().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:(t,e,i,n)=>!1,getKnots:(t,e,i,n,o)=>A.getKnots(t,e,i,n,o),getWeights:(t,e,i)=>A.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>A.getControlPoints(t,e,i,n,o),requestRebuild(){this._rebuild.addEvent()},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),n=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=n.at(-1)-n[0],s=this._order.getValue()-1,r=this.surface=(this.surface||Nt)({boundary:["open"],degree:[s],knots:[n],points:i,debug:!1});this.sampleOptions.haveWeights=!!e;const l=Nt.sample(this.mesh,r,this.sampleOptions).points,h=this.interpolator;h._key.length=0,h._keyValue.length=0;for(let e=0,i=l.length-3;e<i;e+=3){const s=new(S())(l[e+3]-l[e+0],l[e+4]-l[e+1],l[e+5]-l[e+2]);h._key.push(n[0]+e/(i-3+3*t)*o),h._keyValue.push(new(kt())(S().zAxis,s))}t&&(h._key.push(n[0]+o),h._keyValue.push(h._keyValue[0]))}}),Object.defineProperties(At,{...d().getStaticProperties("NurbsOrientationInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"set_fraction",new(s().SFFloat)),new(l())(g().inputOutput,"order",new(s().SFInt32)(3)),new(l())(g().inputOutput,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().outputOnly,"value_changed",new(s().SFRotation))]),enumerable:!0}});const Bt=At,Kt=m().add("NurbsOrientationInterpolator",Bt),Mt=t.Algorithm;var Et=e.n(Mt);const Ut=t.Triangle3;var Wt=e.n(Ut);function qt(t){M.call(this,t),this.addType(g().X3DNurbsSurfaceGeometryNode),this.tessellationScale=1,this.uKnots=[],this.vKnots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[],closed:[]},this.textUKnots=[],this.textVKnots=[],this.textWeights=[],this.texControlPoints=[],this.texMesh={}}Object.assign(Object.setPrototypeOf(qt.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._texCoord.addInterest("set_texCoord__",this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_texCoord__(),this.set_controlPoint__()},set_texCoord__(){this.texCoordNode?.removeInterest("requestRebuild",this),this.nurbsTexCoordNode?.removeInterest("requestRebuild",this),this.texCoordNode=_()(g().X3DTextureCoordinateNode,this._texCoord),this.nurbsTexCoordNode=_()(g().NurbsTextureCoordinate,this._texCoord),this.texCoordNode?.addInterest("requestRebuild",this),this.nurbsTexCoordNode?.addInterest("requestRebuild",this)},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},setTessellationScale(t){this.tessellationScale=t,this.requestRebuild()},getUTessellation(t){return Math.floor(A.getTessellation(this._uTessellation.getValue(),t-this._uOrder.getValue())*this.tessellationScale)},getVTessellation(t){return Math.floor(A.getTessellation(this._vTessellation.getValue(),t-this._vOrder.getValue())*this.tessellationScale)},getUClosed(t,e,i,n,o,s){return!!this._uClosed.getValue()&&A.getUClosed(t,e,i,n,o,s)},getVClosed(t,e,i,n,o,s){return!!this._vClosed.getValue()&&A.getVClosed(t,e,i,n,o,s)},getUVWeights:(t,e,i,n)=>A.getUVWeights(t,e,i,n),getTexControlPoints:(t,e,i,n,o,s,r,l)=>A.getTexControlPoints(t,e,i,n,o,s,r,l),getUVControlPoints:(t,e,i,n,o,s,r,l,h)=>A.getUVControlPoints(t,e,i,n,o,s,r,l,h),getTrimmingContours(){},build(){if(this._uOrder.getValue()<2)return;if(this._vOrder.getValue()<2)return;if(this._uDimension.getValue()<this._uOrder.getValue())return;if(this._vDimension.getValue()<this._vOrder.getValue())return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()!==this._uDimension.getValue()*this._vDimension.getValue())return;const t=this.getUClosed(this._uOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._uKnot,this._weight,this.controlPointNode),e=this.getVClosed(this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._vKnot,this._weight,this.controlPointNode),i=this.getUVWeights(this.weights,this._uDimension.getValue(),this._vDimension.getValue(),this._weight),n=this.getUVControlPoints(this.controlPoints,t,e,this._uOrder.getValue(),this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),i,this.controlPointNode),o=this.getKnots(this.uKnots,t,this._uOrder.getValue(),this._uDimension.getValue(),this._uKnot),s=this.getKnots(this.vKnots,e,this._vOrder.getValue(),this._vDimension.getValue(),this._vKnot),r=(o.at(-1),o[0],s.at(-1),s[0],this._uOrder.getValue()-1),l=this._vOrder.getValue()-1,h=this.surface=(this.surface||Nt)({boundary:["open","open"],degree:[r,l],knots:[o,s],points:n,debug:!1}),a=this.sampleOptions;a.resolution[0]=this.getUTessellation(o.length),a.resolution[1]=this.getVTessellation(s.length),a.closed[0]=t,a.closed[1]=e,a.domain=void 0,a.haveWeights=!!i,a.trimmingContours=this.getTrimmingContours();const u=Nt.sample(this.mesh,h,a),d=u.faces,c=u.points,g=this.getVertices();for(let t=0,e=d.length;t<e;++t){const e=3*d[t];g.push(c[e],c[e+1],c[e+2],1)}this.buildNurbsTexCoords(t,e,this._uOrder.getValue(),this._vOrder.getValue(),o,s,this._uDimension.getValue(),this._vDimension.getValue(),h.domain),this.generateNormals(d,c),this.setSolid(this._solid.getValue()),this.setCCW(!0)},buildNurbsTexCoords:(()=>{const t=[],e=[],i=[[[0,0,0,1],[0,1,0,1]],[[1,0,0,1],[1,1,0,1]]];function n(t,e){return t[0]=t[1]=e[0],t[2]=t[3]=e.at(-1),t}return function(o,s,r,l,h,a,u,d,c){const g=this.sampleOptions;if(this.texCoordNode&&this.texCoordNode.getSize()===u*d)var p=r-1,_=l-1,f=h,m=a,w=this.getTexControlPoints(this.texControlPoints,o,s,r,l,u,d,this.texCoordNode);else if(this.nurbsTexCoordNode&&this.nurbsTexCoordNode.isValid()){var v=this.nurbsTexCoordNode,y=(p=v._uOrder.getValue()-1,_=v._vOrder.getValue()-1,f=this.getKnots(this.texUKnots,!1,v._uOrder.getValue(),v._uDimension.getValue(),v._uKnot),m=this.getKnots(this.texVKnots,!1,v._vOrder.getValue(),v._vDimension.getValue(),v._vKnot),this.getUVWeights(this.texWeights,v._uDimension.getValue(),v._vDimension.getValue(),v._weight));w=v.getControlPoints(y)}else{p=1,_=1,f=n(t,h),m=n(e,a),w=i;g.domain=c}const b=this.texSurface=(this.texSurface||Nt)({boundary:["open","open"],degree:[p,_],knots:[f,m],points:w});g.closed[0]=!1,g.closed[1]=!1,g.haveWeights=!1;const C=Nt.sample(this.texMesh,b,g),O=C.faces,N=C.points,P=this.getTexCoords();for(let t=0,e=O.length;t<e;++t){const e=4*O[t];P.push(N[e],N[e+1],N[e+2],N[e+3])}this.getMultiTexCoords().push(this.getTexCoords())}})(),generateNormals(t,e){const i=this.createNormals(t,e),n=this.getNormals();for(const t of i)n.push(t.x,t.y,t.z)},createNormals(t,e){const i=new Map,n=this.createFaceNormals(t,e),o=t.length;for(let e=0;e<o;++e){const n=t[e];let o=i.get(n);o||i.set(n,o=[]),o.push(e)}return this.refineNormals(i,n,Et().radians(85))},createFaceNormals:(()=>{const t=new(S()),e=new(S()),i=new(S());return function(n,o){const s=this.faceNormals||[],r=n.length;for(let l=0;l<r;l+=3){const r=3*n[l],h=3*n[l+1],a=3*n[l+2];t.set(o[r],o[r+1],o[r+2]),e.set(o[h],o[h+1],o[h+2]),i.set(o[a],o[a+1],o[a+2]);const u=Wt().normal(t,e,i,s[l]||new(S()));s[l]=u,s[l+1]=u,s[l+2]=u}return s.length=r,s}})()}),Object.defineProperties(qt,d().getStaticProperties("X3DNurbsSurfaceGeometryNode","NURBS",1));const Gt=qt,Yt=m().add("X3DNurbsSurfaceGeometryNode",Gt);function Xt(t){Yt.call(this,t),this.addType(g().NurbsPatchSurface)}Object.setPrototypeOf(Xt.prototype,Yt.prototype),Object.defineProperties(Xt,{...d().getStaticProperties("NurbsPatchSurface","NURBS",1,"geometry","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"uTessellation",new(s().SFInt32)),new(l())(g().inputOutput,"vTessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"uClosed",new(s().SFBool)),new(l())(g().initializeOnly,"vClosed",new(s().SFBool)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"texCoord",new(s().SFNode)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode))]),enumerable:!0}});const Jt=Xt,Lt=m().add("NurbsPatchSurface",Jt),Zt=t.PositionInterpolator;var Ht=e.n(Zt);function Qt(t){zt().call(this,t),this.addType(g().NurbsPositionInterpolator),this.addChildObjects(g().inputOutput,"rebuild",new(s().SFTime)),this.interpolator=new(Ht())(t),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}Object.assign(Object.setPrototypeOf(Qt.prototype,zt().prototype),{initialize(){zt().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(g().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:(t,e,i,n)=>!1,getKnots:(t,e,i,n,o)=>A.getKnots(t,e,i,n,o),getWeights:(t,e,i)=>A.getWeights(t,e,i),getControlPoints:(t,e,i,n,o)=>A.getControlPoints(t,e,i,n,o),requestRebuild(){this._rebuild.addEvent()},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const t=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),e=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,t,this._order.getValue(),e,this.controlPointNode),n=this.getKnots(this.knots,t,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=n.at(-1)-n[0],r=this._order.getValue()-1,l=this.surface=(this.surface||Nt)({boundary:["open"],degree:[r],knots:[n],points:i,debug:!1});this.sampleOptions.haveWeights=!!e;const h=Nt.sample(this.mesh,l,this.sampleOptions).points,a=this.interpolator;a._key.length=0,a._keyValue.length=0;for(let t=0,e=h.length;t<e;t+=3)a._key.push(n[0]+t/(e-3)*o),a._keyValue.push(new(s().SFVec3f)(h[t],h[t+1],h[t+2]))}}),Object.defineProperties(Qt,{...d().getStaticProperties("NurbsPositionInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"set_fraction",new(s().SFFloat)),new(l())(g().inputOutput,"order",new(s().SFInt32)(3)),new(l())(g().inputOutput,"knot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().outputOnly,"value_changed",new(s().SFVec3f))]),enumerable:!0}});const $t=Qt,te=m().add("NurbsPositionInterpolator",$t),ee=t.X3DBoundedObject;var ie=e.n(ee);function ne(t){zt().call(this,t),ie().call(this,t),this.addType(g().NurbsSet),this.geometryNodes=[]}function oe(t,e){const i=new Set(e);return t.filter((t=>!i.has(t)))}Object.assign(Object.setPrototypeOf(ne.prototype,zt().prototype),ie().prototype,{initialize(){zt().prototype.initialize.call(this),ie().prototype.initialize.call(this),this._tessellationScale.addInterest("set_tessellationScale__",this),this._addGeometry.addInterest("set_addGeometry__",this),this._removeGeometry.addInterest("set_removeGeometry__",this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},getBBox(t,e){for(const e of this.geometryNodes)t.add(e.getBBox());return t},set_tessellationScale__(){const t=Math.max(0,this._tessellationScale.getValue());for(const e of this.geometryNodes)e.setTessellationScale(t)},set_addGeometry__(){this._addGeometry.setTainted(!0),this._addGeometry.assign(oe(this._addGeometry,this._geometry));for(const t of this._addGeometry)this._geometry.push(t);this._addGeometry.length=0,this._addGeometry.setTainted(!1)},set_removeGeometry__(){this._removeGeometry.setTainted(!0),this._geometry.assign(oe(this._geometry,this._removeGeometry)),this._removeGeometry.length=0,this._removeGeometry.setTainted(!1)},set_geometry__(){for(const t of this.geometryNodes)t.setTessellationScale(1);this.geometryNodes.length=0;for(const t of this._geometry){const e=_()(g().X3DNurbsSurfaceGeometryNode,t);e&&this.geometryNodes.push(e)}this.set_tessellationScale__()},dispose(){ie().prototype.dispose.call(this),zt().prototype.dispose.call(this)}}),Object.defineProperties(ne,{...d().getStaticProperties("NurbsSet","NURBS",2,"children","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"tessellationScale",new(s().SFFloat)(1)),new(l())(g().inputOutput,"visible",new(s().SFBool)(!0)),new(l())(g().inputOutput,"bboxDisplay",new(s().SFBool)),new(l())(g().initializeOnly,"bboxSize",new(s().SFVec3f)(-1,-1,-1)),new(l())(g().initializeOnly,"bboxCenter",new(s().SFVec3f)),new(l())(g().inputOnly,"addGeometry",new(s().MFNode)),new(l())(g().inputOnly,"removeGeometry",new(s().MFNode)),new(l())(g().inputOutput,"geometry",new(s().MFNode))]),enumerable:!0}});const se=ne,re=m().add("NurbsSet",se),le=t.Line3;var he=e.n(le);const ae={isPointInTriangle(t,e,i,n){const o=(e.y-i.y)*(t.x-i.x)+(i.x-e.x)*(t.y-i.y);if(0==o)return!1;const s=((e.y-i.y)*(n.x-i.x)+(i.x-e.x)*(n.y-i.y))/o;if(s<0||s>1)return!1;const r=((i.y-t.y)*(n.x-i.x)+(t.x-i.x)*(n.y-i.y))/o;if(r<0||r>1)return!1;const l=1-s-r;return!(l<0||l>1)}},ue=m().add("Triangle2",ae);function de(t){zt().call(this,t),this.addType(g().NurbsSurfaceInterpolator),this.geometry=new Lt(t)}Object.assign(Object.setPrototypeOf(de.prototype,zt().prototype),{initialize(){this._set_fraction.addInterest("set_fraction__",this),this._uOrder.addFieldInterest(this.geometry._uOrder),this._vOrder.addFieldInterest(this.geometry._vOrder),this._uDimension.addFieldInterest(this.geometry._uDimension),this._vDimension.addFieldInterest(this.geometry._vDimension),this._uKnot.addFieldInterest(this.geometry._uKnot),this._vKnot.addFieldInterest(this.geometry._vKnot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._uTessellation=128,this.geometry._vTessellation=128,this.geometry._uOrder=this._uOrder,this.geometry._vOrder=this._vOrder,this.geometry._uDimension=this._uDimension,this.geometry._vDimension=this._vDimension,this.geometry._uKnot=this._uKnot,this.geometry._vKnot=this._vKnot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry.setup()},set_fraction__:(()=>{const t=new(S()),e=new(S()),i=new(S()),n=new(S()),o=new(he())(S().Zero,S().zAxis),s={};return function(){const r=this._set_fraction.getValue(),l=this.geometry.getTexCoords(),h=this.geometry.getNormals(),a=this.geometry.getVertices();for(let u=0,d=0,c=l.length;u<c;u+=12,d+=9)if(t.set(l[u+0],l[u+1],0),e.set(l[u+4],l[u+5],0),i.set(l[u+7],l[u+9],0),ue.isPointInTriangle(t,e,i,r)&&(o.set(n.set(r.x,r.y,0),S().zAxis),o.intersectsTriangle(t,e,i,s))){const t=s.u,e=s.v,i=s.t,n=new(S())(i*h[d+0]+t*h[d+3]+e*h[d+6],i*h[d+1]+t*h[d+4]+e*h[d+7],i*h[d+2]+t*h[d+5]+e*h[d+8]),o=new(S())(i*a[u+0]+t*a[u+4]+e*a[u+8],i*a[u+1]+t*a[u+5]+e*a[u+9],i*a[u+2]+t*a[u+6]+e*a[u+10]);this._normal_changed=n,this._position_changed=o}}})()}),Object.defineProperties(de,{...d().getStaticProperties("NurbsSurfaceInterpolator","NURBS",1,"children","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOnly,"set_fraction",new(s().SFVec2f)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().outputOnly,"normal_changed",new(s().SFVec3f)),new(l())(g().outputOnly,"position_changed",new(s().SFVec3f))]),enumerable:!0}});const ce=de,ge=m().add("NurbsSurfaceInterpolator",ce),pe=t.Extrusion;var _e=e.n(pe);function fe(t){M.call(this,t),this.addType(g().NurbsSweptSurface),this.extrusion=new(_e())(t)}Object.assign(Object.setPrototypeOf(fe.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._crossSectionCurve.addInterest("set_crossSectionCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_crossSectionCurve__(),this.set_trajectoryCurve__()},set_crossSectionCurve__(){this.crossSectionCurveNode&&this.crossSectionCurveNode.removeInterest("requestRebuild",this),this.crossSectionCurveNode=_()(g().X3DNurbsControlCurveNode,this._crossSectionCurve),this.crossSectionCurveNode&&this.crossSectionCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode?._rebuild.removeInterest("requestRebuild",this),this.trajectoryCurveNode=_()(g().NurbsCurve,this._trajectoryCurve),this.trajectoryCurveNode?._rebuild.addInterest("requestRebuild",this)},build(){if(!this.crossSectionCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.crossSectionCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(0),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals();for(let e=0,i=t.length;e<i;++e)t[e]=-t[e]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(fe,{...d().getStaticProperties("NurbsSweptSurface","NURBS",3,"geometry","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"ccw",new(s().SFBool)(!0)),new(l())(g().inputOutput,"crossSectionCurve",new(s().SFNode)),new(l())(g().inputOutput,"trajectoryCurve",new(s().SFNode))]),enumerable:!0}});const me=fe,we=m().add("NurbsSweptSurface",me);function ve(t){M.call(this,t),this.addType(g().NurbsSwungSurface),this.extrusion=new(_e())(t)}Object.assign(Object.setPrototypeOf(ve.prototype,M.prototype),{initialize(){M.prototype.initialize.call(this),this._profileCurve.addInterest("set_profileCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const t=this.extrusion;t._beginCap=!1,t._endCap=!1,t._solid=!0,t._ccw=!0,t._convex=!0,t._creaseAngle=Math.PI,t.setup(),t._crossSection.setTainted(!0),t._spine.setTainted(!0),this.set_profileCurve__(),this.set_trajectoryCurve__()},set_profileCurve__(){this.profileCurveNode&&this.profileCurveNode.removeInterest("requestRebuild",this),this.profileCurveNode=_()(g().X3DNurbsControlCurveNode,this._profileCurve),this.profileCurveNode&&this.profileCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode&&this.trajectoryCurveNode.removeInterest("requestRebuild",this),this.trajectoryCurveNode=_()(g().X3DNurbsControlCurveNode,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode.addInterest("requestRebuild",this)},build(){if(!this.profileCurveNode)return;if(!this.trajectoryCurveNode)return;const t=this.extrusion;if(t._crossSection=this.profileCurveNode.tessellate(0),t._spine=this.trajectoryCurveNode.tessellate(1),t.rebuild(),this.getColors().assign(t.getColors()),this.getTexCoords().assign(t.getTexCoords()),this.getNormals().assign(t.getNormals()),this.getVertices().assign(t.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const t=this.getNormals();for(let e=0,i=t.length;e<i;++e)t[e]=-t[e]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(ve,{...d().getStaticProperties("NurbsSwungSurface","NURBS",3,"geometry","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"ccw",new(s().SFBool)(!0)),new(l())(g().inputOutput,"profileCurve",new(s().SFNode)),new(l())(g().inputOutput,"trajectoryCurve",new(s().SFNode))]),enumerable:!0}});const ye=ve,be=m().add("NurbsSwungSurface",ye);function Ce(t){d().call(this,t),this.addType(g().NurbsTextureCoordinate),this.controlPoints=[]}Object.assign(Object.setPrototypeOf(Ce.prototype,d().prototype),{initialize(){d().prototype.initialize.call(this)},getControlPoints(t){const e=this._controlPoint.getValue(),i=this.controlPoints;for(let n=0,o=this._uDimension.getValue();n<o;++n){let s=i[n];s||(s=i[n]=[]);for(let i=0,r=this._vDimension.getValue();i<r;++i){const r=i*o+n,l=s[i]||new(x()),h=2*r;s[i]=l.set(e[h],e[h+1],0,t?t[r]:1)}}return i},isValid(){return!(this._uOrder.getValue()<2)&&(!(this._vOrder.getValue()<2)&&(!(this._uDimension.getValue()<this._uOrder.getValue())&&(!(this._vDimension.getValue()<this._vOrder.getValue())&&this._controlPoint.length===this._uDimension.getValue()*this._vDimension.getValue())))}}),Object.defineProperties(Ce,{...d().getStaticProperties("NurbsTextureCoordinate","NURBS",1,"texCoord","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"controlPoint",new(s().MFVec2f))]),enumerable:!0}});const Oe=Ce,Ne=m().add("NurbsTextureCoordinate",Oe);function Pe(t){Yt.call(this,t),this.addType(g().NurbsTrimmedSurface),this.trimmingContourNodes=[]}function Se(t,e){const i=new Set(e);return t.filter((t=>!i.has(t)))}Object.assign(Object.setPrototypeOf(Pe.prototype,Yt.prototype),{initialize(){Yt.prototype.initialize.call(this),this._addTrimmingContour.addInterest("set_addTrimmingContour__",this),this._removeTrimmingContour.addInterest("set_removeTrimmingContour__",this),this._trimmingContour.addInterest("set_trimmingContour__",this),this.set_trimmingContour__()},set_addTrimmingContour__(){this._addTrimmingContour.setTainted(!0),this._addTrimmingContour.assign(Se(this._addTrimmingContour,this._trimmingContour),this._addTrimmingContour.length);for(const t of this._addTrimmingContour)this._trimmingContour.push(t);this._addTrimmingContour.length=0,this._addTrimmingContour.setTainted(!1)},set_removeTrimmingContour__(){this._removeTrimmingContour.setTainted(!0),this._trimmingContour.assign(Se(this._trimmingContour,this._removeTrimmingContour)),this._removeTrimmingContour.length=0,this._removeTrimmingContour.setTainted(!1)},set_trimmingContour__(){const t=this.trimmingContourNodes;t.length=0;for(const e of this._trimmingContour){const i=_()(g().Contour2D,e);i&&t.push(i)}},getTrimmingContours(){const t=this.trimmingContourNodes,e=[];for(const i of t)i.addTrimmingContour(e);return e}}),Object.defineProperties(Pe,{...d().getStaticProperties("NurbsTrimmedSurface","NURBS",4,"geometry","3.0"),fieldDefinitions:{value:new(a())([new(l())(g().inputOutput,"metadata",new(s().SFNode)),new(l())(g().inputOutput,"uTessellation",new(s().SFInt32)),new(l())(g().inputOutput,"vTessellation",new(s().SFInt32)),new(l())(g().initializeOnly,"solid",new(s().SFBool)(!0)),new(l())(g().initializeOnly,"uClosed",new(s().SFBool)),new(l())(g().initializeOnly,"vClosed",new(s().SFBool)),new(l())(g().initializeOnly,"uOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"vOrder",new(s().SFInt32)(3)),new(l())(g().initializeOnly,"uDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"vDimension",new(s().SFInt32)),new(l())(g().initializeOnly,"uKnot",new(s().MFDouble)),new(l())(g().initializeOnly,"vKnot",new(s().MFDouble)),new(l())(g().inputOutput,"weight",new(s().MFDouble)),new(l())(g().inputOutput,"texCoord",new(s().SFNode)),new(l())(g().inputOutput,"controlPoint",new(s().SFNode)),new(l())(g().inputOnly,"addTrimmingContour",new(s().MFNode)),new(l())(g().inputOnly,"removeTrimmingContour",new(s().MFNode)),new(l())(g().inputOutput,"trimmingContour",new(s().MFNode))]),enumerable:!0}});const De=Pe,Fe=m().add("NurbsTrimmedSurface",De);n().add({name:"NURBS",concreteNodes:[b,V,Dt,Rt,Kt,Lt,te,re,ge,we,be,Ne,Fe],abstractNodes:[N,Yt,M]});m().add("NURBSComponent",undefined)})();