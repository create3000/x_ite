/* X_ITE v14.0.3 */
const t=window[Symbol.for("X_ITE.X3D-14.0.3")];(()=>{var e={n:t=>{var s=t&&t.__esModule?()=>t.default:()=>t;return e.d(s,{a:s}),s},d:(t,s)=>{for(var i in s)e.o(s,i)&&!e.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:s[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)};const s=t.Components;var i=e.n(s);const n=t.Fields;var o=e.n(n);const a=t.X3DFieldDefinition;var l=e.n(a);const r=t.FieldDefinitionArray;var h=e.n(r);const g=t.X3DNode;var u=e.n(g);const c=t.X3DGeometryNode;var d=e.n(c);const p=t.X3DConstants;var w=e.n(p);const _=t.Vector3;var f=e.n(_);const V=t.Namespace;var m=e.n(V);function y(t){d().call(this,t),this.addType(w().Box),this._size.setUnit("length")}Object.assign(Object.setPrototypeOf(y.prototype,d().prototype),{build:(()=>{const t=new(f())(2);return function(){const e=this.getBrowser().getBoxOptions().getGeometry(),s=this._size.getValue(),i=this.getVertices();if(this.getMultiTexCoords().push(...e.getMultiTexCoords()),this.getTangents().assign(e.getTangents()),this.getNormals().assign(e.getNormals()),s.equals(t))i.assign(e.getVertices()),this.getMin().assign(e.getMin()),this.getMax().assign(e.getMax());else{const t=Math.abs(s.x/2),n=Math.abs(s.y/2),o=Math.abs(s.z/2),a=e.getVertices();for(let e=0,s=a.length;e<s;e+=4)i.push(t*a[e],n*a[e+1],o*a[e+2],1);this.getMin().set(-t,-n,-o),this.getMax().set(t,n,o)}this.setSolid(this._solid.getValue())}})()}),Object.defineProperties(y,{...u().getStaticProperties("Box","Geometry3D",1,"geometry","2.0"),fieldDefinitions:{value:new(h())([new(l())(w().inputOutput,"metadata",new(o().SFNode)),new(l())(w().initializeOnly,"size",new(o().SFVec3f)(2,2,2)),new(l())(w().initializeOnly,"solid",new(o().SFBool)(!0))]),enumerable:!0}});const O=y,b=m().add("Box",O),x=t.Rotation4;var S=e.n(x);function F(t){d().call(this,t),this.addType(w().Cone),this._height.setUnit("length"),this._bottomRadius.setUnit("length")}Object.assign(Object.setPrototypeOf(F.prototype,d().prototype),{set_live__(){this.connectOptions(this.getBrowser().getConeOptions())},build(){const t=this.getBrowser().getConeOptions(),e=Math.abs(this._height.getValue()),s=e/2,i=Math.abs(this._bottomRadius.getValue()),n=this.getTexCoords(),o=this.getNormals(),a=this.getVertices();if(this.getMultiTexCoords().push(n),this._side.getValue()){const l=t.getSideGeometry(),r=l.getNormals(),h=l.getVertices(),g=new(f()),u=new(S())(1,0,0,-Math.atan(i/e)),c=new(S());for(const t of l.getMultiTexCoords()[0])n.push(t);for(let t=0,e=r.length;t<e;t+=3)g.set(r[t],0,r[t+2]),c.setFromToVec(f().Z_AXIS,g).multLeft(u).multVecRot(g.set(0,0,1)),o.push(...g);for(let t=0,e=h.length;t<e;t+=4)a.push(i*h[t],s*h[t+1],i*h[t+2],1)}if(this._bottom.getValue()){const e=t.getBottomGeometry(),l=e.getVertices();for(const t of e.getMultiTexCoords()[0])n.push(t);for(const t of e.getNormals())o.push(t);for(let t=0,e=l.length;t<e;t+=4)a.push(i*l[t],s*l[t+1],i*l[t+2],1)}this.setSolid(this._solid.getValue()),this.setExtents()},setExtents(){const t=this._bottomRadius.getValue(),e=this._height.getValue()/2,s=-e;this._side.getValue()||this._bottom.getValue()?this._side.getValue()?(this.getMin().set(-t,s,-t),this.getMax().set(t,e,t)):(this.getMin().set(-t,s,-t),this.getMax().set(t,s,t)):(this.getMin().set(0),this.getMax().set(0))}}),Object.defineProperties(F,{...u().getStaticProperties("Cone","Geometry3D",1,"geometry","2.0"),fieldDefinitions:{value:new(h())([new(l())(w().inputOutput,"metadata",new(o().SFNode)),new(l())(w().inputOutput,"side",new(o().SFBool)(!0)),new(l())(w().inputOutput,"bottom",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"height",new(o().SFFloat)(2)),new(l())(w().initializeOnly,"bottomRadius",new(o().SFFloat)(1)),new(l())(w().initializeOnly,"solid",new(o().SFBool)(!0))]),enumerable:!0}});const C=F,M=m().add("Cone",C);function z(t){d().call(this,t),this.addType(w().Cylinder),this._height.setUnit("length"),this._radius.setUnit("length")}Object.assign(Object.setPrototypeOf(z.prototype,d().prototype),{set_live__(){this.connectOptions(this.getBrowser().getCylinderOptions())},build(){const t=this.getBrowser().getCylinderOptions(),e=Math.abs(this._height.getValue())/2,s=Math.abs(this._radius.getValue()),i=this.getTexCoords(),n=this.getTangents(),o=this.getNormals(),a=this.getVertices();if(this.getMultiTexCoords().push(i),this._side.getValue()){const l=t.getSideGeometry(),r=l.getVertices();for(const t of l.getMultiTexCoords()[0])i.push(t);for(const t of l.getTangents())n.push(t);for(const t of l.getNormals())o.push(t);for(let t=0,i=r.length;t<i;t+=4)a.push(s*r[t],e*r[t+1],s*r[t+2],1)}if(this._top.getValue()){const l=t.getTopGeometry(),r=l.getVertices();for(const t of l.getMultiTexCoords()[0])i.push(t);for(const t of l.getTangents())n.push(t);for(const t of l.getNormals())o.push(t);for(let t=0,i=r.length;t<i;t+=4)a.push(s*r[t],e*r[t+1],s*r[t+2],1)}if(this._bottom.getValue()){const l=t.getBottomGeometry(),r=l.getVertices();for(const t of l.getMultiTexCoords()[0])i.push(t);for(const t of l.getTangents())n.push(t);for(const t of l.getNormals())o.push(t);for(let t=0,i=r.length;t<i;t+=4)a.push(s*r[t],e*r[t+1],s*r[t+2],1)}this.setSolid(this._solid.getValue()),this.setExtents()},setExtents(){const t=this._radius.getValue(),e=this._height.getValue()/2,s=-e;this._top.getValue()||this._side.getValue()||this._bottom.getValue()?this._top.getValue()||this._side.getValue()?this._bottom.getValue()||this._side.getValue()?(this.getMin().set(-t,s,-t),this.getMax().set(t,e,t)):(this.getMin().set(-t,e,-t),this.getMax().set(t,e,t)):(this.getMin().set(-t,s,-t),this.getMax().set(t,s,t)):(this.getMin().set(0),this.getMax().set(0))}}),Object.defineProperties(z,{...u().getStaticProperties("Cylinder","Geometry3D",1,"geometry","2.0"),fieldDefinitions:{value:new(h())([new(l())(w().inputOutput,"metadata",new(o().SFNode)),new(l())(w().inputOutput,"top",new(o().SFBool)(!0)),new(l())(w().inputOutput,"side",new(o().SFBool)(!0)),new(l())(w().inputOutput,"bottom",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"height",new(o().SFFloat)(2)),new(l())(w().initializeOnly,"radius",new(o().SFFloat)(1)),new(l())(w().initializeOnly,"solid",new(o().SFBool)(!0))]),enumerable:!0}});const T=z,v=m().add("Cylinder",T),N=t.Triangle3;var P=e.n(N);const D=t.Vector2;var B=e.n(D);function I(t){d().call(this,t),this.addType(w().ElevationGrid),this._set_height.setUnit("length"),this._xSpacing.setUnit("length"),this._zSpacing.setUnit("length"),this._creaseAngle.setUnit("angle"),this._height.setUnit("length")}Object.assign(Object.setPrototypeOf(I.prototype,d().prototype),{initialize(){d().prototype.initialize.call(this),this._set_height.addFieldInterest(this._height),this._attrib.addInterest("set_attrib__",this),this._fogCoord.addInterest("set_fogCoord__",this),this._color.addInterest("set_color__",this),this._texCoord.addInterest("set_texCoord__",this),this._tangent.addInterest("set_tangent__",this),this._normal.addInterest("set_normal__",this),this.set_attrib__(),this.set_fogCoord__(),this.set_color__(),this.set_texCoord__(),this.set_tangent__(),this.set_normal__()},getHeight(t){return t<this._height.length?this._height[t]:0},createTexCoords(){const t=[],e=this._xDimension.getValue(),s=this._zDimension.getValue(),i=e-1,n=s-1;for(let o=0;o<s;++o)for(let s=0;s<e;++s)t.push(new(B())(s/i,o/n));return t},createNormals(t,e,s){const i=!this._ccw.getValue(),n=new Map,o=[];for(let e=0,s=t.length;e<s;++e)n.set(e,[]);for(let s=0,a=e.length;s<a;s+=3){const a=e[s],l=e[s+1],r=e[s+2];n.get(a).push(o.length),n.get(l).push(o.length+1),n.get(r).push(o.length+2);const h=P().normal(t[a],t[l],t[r],new(f()));i&&h.negate(),o.push(h),o.push(h),o.push(h)}return this._normalPerVertex.getValue()?this.refineNormals(n,o,s??this._creaseAngle.getValue()):o},createCoordIndex(){const t=[],e=this._xDimension.getValue(),s=e-1,i=this._zDimension.getValue()-1;for(let n=0;n<i;++n)for(let i=0;i<s;++i){const s=n*e+i,o=(n+1)*e+i,a=(n+1)*e+(i+1),l=n*e+(i+1);t.push(s),t.push(o),t.push(a),t.push(s),t.push(a),t.push(l)}return t},createPoints(){const t=[],e=this._xDimension.getValue(),s=this._zDimension.getValue(),i=this._xSpacing.getValue(),n=this._zSpacing.getValue();for(let o=0;o<s;++o)for(let s=0;s<e;++s)t.push(new(f())(i*s,this.getHeight(s+o*e),n*o));return t},build(){if(this._xDimension.getValue()<2||this._zDimension.getValue()<2)return;const t=this._colorPerVertex.getValue(),e=this._normalPerVertex.getValue(),s=this.createCoordIndex(),i=this.getCoordIndices(),n=this.getAttrib(),o=n.length,a=this.getAttribs(),l=this.getFogCoord(),r=this.getColor(),h=this.getTexCoord(),g=this.getTangent(),u=this.getNormal(),c=this.createPoints(),d=this.getFogDepths(),p=this.getColors(),w=this.getMultiTexCoords(),_=this.getTangents(),f=this.getNormals(),V=this.getVertices(),m=s.length;let y,O;h?h.init(w):(y=this.createTexCoords(),O=this.getTexCoords(),w.push(O));let b=0;for(let x=0;x<m;++b)for(let m=0;m<6;++m,++x){const m=s[x],{x:S,y:F,z:C}=c[m];i.push(m);for(let t=0;t<o;++t)n[t].addValue(m,a[t]);if(l?.addDepth(m,d),r?.addColor(t?m:b,p),h)h.addPoint(m,w);else{const{x:t,y:e}=y[m];O.push(t,e,0,1)}g?.addVector(e?m:b,_),u?.addVector(e?m:b,f),V.push(S,F,C,1)}if(!u){const t=this.createNormals(c,s);for(const{x:e,y:s,z:i}of t)f.push(e,s,i)}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(I,{...u().getStaticProperties("ElevationGrid","Geometry3D",3,"geometry","2.0"),fieldDefinitions:{value:new(h())([new(l())(w().inputOutput,"metadata",new(o().SFNode)),new(l())(w().inputOnly,"set_height",new(o().MFFloat)),new(l())(w().initializeOnly,"xDimension",new(o().SFInt32)),new(l())(w().initializeOnly,"zDimension",new(o().SFInt32)),new(l())(w().initializeOnly,"xSpacing",new(o().SFFloat)(1)),new(l())(w().initializeOnly,"zSpacing",new(o().SFFloat)(1)),new(l())(w().initializeOnly,"solid",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"ccw",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"creaseAngle",new(o().SFFloat)),new(l())(w().initializeOnly,"colorPerVertex",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"normalPerVertex",new(o().SFBool)(!0)),new(l())(w().inputOutput,"attrib",new(o().MFNode)),new(l())(w().inputOutput,"fogCoord",new(o().SFNode)),new(l())(w().inputOutput,"color",new(o().SFNode)),new(l())(w().inputOutput,"texCoord",new(o().SFNode)),new(l())(w().inputOutput,"tangent",new(o().SFNode)),new(l())(w().inputOutput,"normal",new(o().SFNode)),new(l())(w().initializeOnly,"height",new(o().MFFloat))]),enumerable:!0}});const E=I,R=m().add("ElevationGrid",E),j=t.Matrix4;var G=e.n(j);function U(t){d().call(this,t),this.addType(w().Extrusion),this._creaseAngle.setUnit("angle"),this._crossSection.setUnit("length"),this._spine.setUnit("length")}Object.assign(Object.setPrototypeOf(U.prototype,d().prototype),{initialize(){d().prototype.initialize.call(this),this._set_crossSection.addFieldInterest(this._crossSection),this._set_orientation.addFieldInterest(this._orientation),this._set_scale.addFieldInterest(this._scale),this._set_spine.addFieldInterest(this._spine)},getClosed(t){if(!t.length)return!0;const e=t.at(0).getValue(),s=t.at(-1).getValue();return e.equals(s)},createPoints:(()=>{const t=new(f())(1);return function(){const e=this._crossSection,s=this._orientation,i=this._scale,n=this._spine,o=e.length,a=s.length,l=i.length,r=n.length,h=[],g=this.createRotations();for(let n=0;n<r;++n){const r=g[n];if(a&&r.rotate(s[Math.min(n,a-1)].getValue()),l){const e=i[Math.min(n,l-1)].getValue();r.scale(t.set(e.x,1,e.y))}for(let t=0;t<o;++t){const s=e[t].getValue();h.push(r.multVecMatrix(new(f())(s.x,0,s.y)))}}return h}})(),createRotations:(()=>{const t=[],e=new(f()),s=new(f()),i=new(f()),n=new(f()),o=new(f()),a=new(f()),l=new(S());return function(){const r=this._spine,h=r.length,g=this.getClosed(r);for(let e=t.length;e<h;++e)t[e]=new(G());if(t.length=h,e.set(0),s.set(0),i.set(0),g){const t=r.at(0).getValue();for(let e=1,i=h-2;e<i&&(s.assign(r[e].getValue()).subtract(t).normalize().subtract(a.assign(r[i].getValue()).subtract(t).normalize()).normalize(),s.equals(f().ZERO));++e);for(let t=0,e=h-2;t<e&&(i.assign(r[t+1].getValue()).subtract(r[t].getValue()).cross(a.assign(r[e].getValue()).subtract(r[t].getValue())).normalize(),i.equals(f().ZERO));++t);}else{for(let t=0,e=h-1;t<e&&(s.assign(r[t+1].getValue()).subtract(r[t].getValue()).normalize(),s.equals(f().ZERO));++t);for(let t=1,e=h-1;t<e&&(i.assign(r[t+1].getValue()).subtract(r[t].getValue()).cross(a.assign(r[t-1].getValue()).subtract(r[t].getValue())).normalize(),i.equals(f().ZERO));++t);}s.equals(f().ZERO)&&s.set(0,1,0),i.equals(f().ZERO)&&l.setFromToVec(f().Y_AXIS,s).multVecRot(i.assign(f().Z_AXIS)),e.assign(s).cross(i);const u=r.at(0).getValue();t[0].set(...e,0,...s,0,...i,0,...u,1),n.assign(s),o.assign(i);for(let l=1,g=h-1;l<g;++l){const h=r[l].getValue();s.assign(r[l+1].getValue()).subtract(h).normalize().subtract(a.assign(r[l-1].getValue()).subtract(h).normalize()).normalize(),i.assign(r[l+1].getValue()).subtract(h).cross(a.assign(r[l-1].getValue()).subtract(h)).normalize(),n.dot(s)<0&&s.negate(),o.dot(i)<0&&i.negate(),s.equals(f().ZERO)?s.assign(n):n.assign(s),i.equals(f().ZERO)?i.assign(o):o.assign(i),e.assign(s).cross(i),t[l].set(...e,0,...s,0,...i,0,...h,1)}if(g)t[h-1].assign(t[0]);else{const l=r.at(-1).getValue();s.assign(l).subtract(r.at(-2).getValue()).normalize(),h>2&&i.assign(l).subtract(r.at(-2).getValue()).cross(a.assign(r.at(-3).getValue()).subtract(r.at(-2).getValue())).normalize(),n.dot(s)<0&&s.negate(),o.dot(i)<0&&i.negate(),s.equals(f().ZERO)&&s.assign(n),i.equals(f().ZERO)&&i.assign(o),e.assign(s).cross(i),t[h-1].set(...e,0,...s,0,...i,0,...l,1)}return t}})(),build:(()=>{const t=new(B()),e=new(B()),s=new(B());return function(){const i=!this._ccw.getValue(),n=this._crossSection,o=this._spine,a=n.length,l=o.length,r=this.getCoordIndices(),h=this.getTexCoords();if(l<2||a<2)return;this.getMultiTexCoords().push(h);const g=(t,e)=>t*a+e,u=this.getClosed(o)&&this.getClosed(this._orientation)&&this.getClosed(this._scale),c=this.getClosed(n);t.assign(n[0].getValue()),e.assign(n[0].getValue());for(let s=1;s<a;++s)t.min(n[s].getValue()),e.max(n[s].getValue());const d=s.assign(e).subtract(t),p=Math.max(d.x,d.y),w=c?a-1:a,_=new Map,V=[],m=this.createPoints(),y=m.length;for(let t=0;t<y;++t)_.set(t,[]);const O=this.getNormals(),b=this.getVertices(),x=a-1,S=l-1;let F=g(0,0),C=g(0,c?0:x);for(let t=0;t<S;++t)for(let e=0;e<x;++e){const s=u&&t===l-2?0:t+1,n=c&&e===a-2?0:e+1;let o=g(t,e),d=g(t,n),p=g(s,n),w=g(s,e),y=m[o],O=m[d],M=m[p],z=m[w],T=O.distance(M)>=1e-7,v=z.distance(y)>=1e-7;const N=P().normal(y,O,M,new(f())),D=P().normal(y,M,z,new(f()));if(i&&(N.negate(),D.negate()),0===e&&(v?F=o:(o=F,y=m[o])),e===a-2&&(T?C=d:(p=C,M=m[p])),T){if(r.push(o,d,p),v)h.push(e/x,t/S,0,1);else{const s=(t/S+(t+1)/S)/2;h.push(e/x,s,0,1)}_.get(o).push(V.length),V.push(N),b.push(...y,1),h.push((e+1)/x,t/S,0,1),_.get(d).push(V.length),V.push(N),b.push(...O,1),h.push((e+1)/x,(t+1)/S,0,1),_.get(p).push(V.length),V.push(N),b.push(...M,1)}if(v){if(r.push(o,p,w),h.push(e/x,t/S,0,1),_.get(o).push(V.length),V.push(D),b.push(...y,1),T)h.push((e+1)/x,(t+1)/S,0,1);else{const s=((t+1)/S+t/S)/2;h.push((e+1)/x,s,0,1)}_.get(p).push(V.length),V.push(D),b.push(...M,1),h.push(e/x,(t+1)/S,0,1),_.get(w).push(V.length),V.push(D),b.push(...z,1)}}const M=this.refineNormals(_,V,this._creaseAngle.getValue());for(const{x:t,y:e,z:s}of M)O.push(t,e,s);if(p&&w>2){if(this._beginCap.getValue()){const e=0,s=this._convex.getValue(),o={},a=[],l=[];for(let i=0;i<w;++i){const l=g(e,w-1-i),r=m[l].copy();r.index=l,o[l]=n[w-1-i].getValue().copy().subtract(t).divide(p),a.push(s?l:r)}if(s?P().triangulateConvexPolygon(a,l):P().triangulatePolygon(a,l),l.length>=3){const t=P().normal(m[l[0]],m[l[1]],m[l[2]],new(f()));i&&t.negate(),this.addCap(h,o,t,m,l)}}if(this._endCap.getValue()){const e=l-1,s=this._convex.getValue(),o={},a=[],r=[];for(let i=0;i<w;++i){const l=g(e,i),r=m[l].copy();r.index=l,o[l]=n[i].getValue().copy().subtract(t).divide(p),a.push(s?l:r)}if(s?P().triangulateConvexPolygon(a,r):P().triangulatePolygon(a,r),r.length>=3){const t=P().normal(m[r[0]],m[r[1]],m[r[2]],new(f()));i&&t.negate(),this.addCap(h,o,t,m,r)}}}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}})(),addCap(t,e,s,i,n){const o=this.getCoordIndices(),a=this.getNormals(),l=this.getVertices(),r=n.length;for(let h=0;h<r;h+=3){const r=n[h],g=n[h+1],u=n[h+2],c=i[r],d=i[g],p=i[u],w=e[r],_=e[g],f=e[u];o.push(r,g,u),t.push(...w,0,1,..._,0,1,...f,0,1),a.push(...s,...s,...s),l.push(...c,1,...d,1,...p,1)}}}),Object.defineProperties(U,{...u().getStaticProperties("Extrusion","Geometry3D",4,"geometry","2.0"),fieldDefinitions:{value:new(h())([new(l())(w().inputOutput,"metadata",new(o().SFNode)),new(l())(w().inputOnly,"set_crossSection",new(o().MFVec2f)),new(l())(w().inputOnly,"set_orientation",new(o().MFRotation)),new(l())(w().inputOnly,"set_scale",new(o().MFVec2f)),new(l())(w().inputOnly,"set_spine",new(o().MFVec3f)),new(l())(w().initializeOnly,"beginCap",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"endCap",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"solid",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"ccw",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"convex",new(o().SFBool)(!0)),new(l())(w().initializeOnly,"creaseAngle",new(o().SFFloat)),new(l())(w().initializeOnly,"crossSection",new(o().MFVec2f)(new(B())(1),new(B())(1,-1),new(B())(-1,-1),new(B())(-1,1),new(B())(1))),new(l())(w().initializeOnly,"orientation",new(o().MFRotation)(new(S()))),new(l())(w().initializeOnly,"scale",new(o().MFVec2f)(new(B())(1))),new(l())(w().initializeOnly,"spine",new(o().MFVec3f)(new(f()),new(f())(0,1,0)))]),enumerable:!0}});const q=U,A=m().add("Extrusion",q),Z=t.IndexedFaceSet;var X=e.n(Z);function H(t){d().call(this,t),this.addType(w().Sphere),this._radius.setUnit("length")}Object.assign(Object.setPrototypeOf(H.prototype,d().prototype),{set_live__(){this.connectOptions(this.getBrowser().getSphereOptions())},build(){const t=this.getBrowser().getSphereOptions().getGeometry(),e=Math.abs(this._radius.getValue()),s=this.getVertices();if(this.getMultiTexCoords().push(...t.getMultiTexCoords()),this.getTangents().assign(t.getTangents()),this.getNormals().assign(t.getNormals()),1===e)s.assign(t.getVertices());else{const i=t.getVertices();for(let t=0,n=i.length;t<n;t+=4)s.push(e*i[t],e*i[t+1],e*i[t+2],1)}this.getMin().set(-e,-e,-e),this.getMax().set(e,e,e),this.setSolid(this._solid.getValue())}}),Object.defineProperties(H,{...u().getStaticProperties("Sphere","Geometry3D",1,"geometry","2.0"),fieldDefinitions:{value:new(h())([new(l())(w().inputOutput,"metadata",new(o().SFNode)),new(l())(w().initializeOnly,"radius",new(o().SFFloat)(1)),new(l())(w().initializeOnly,"solid",new(o().SFBool)(!0))]),enumerable:!0}});const W=H,L=m().add("Sphere",W);i().add({name:"Geometry3D",concreteNodes:[b,M,v,R,A,X(),L],abstractNodes:[]});m().add("Geometry3DComponent",void 0)})();