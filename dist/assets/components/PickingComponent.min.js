/* X_ITE v11.3.1 */
const e=window[Symbol.for("X_ITE.X3D-11.3.1")];(()=>{var t={n:e=>{var i=e&&e.__esModule?()=>e.default:()=>e;return t.d(i,{a:i}),i},d:(e,i)=>{for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const i=e.Components;var n=t.n(i);const s=e.Fields;var o=t.n(s);const r=e.X3DFieldDefinition;var c=t.n(r);const a=e.FieldDefinitionArray;var h=t.n(a);const p=e.X3DNode;var l=t.n(p);const d=e.X3DSensorNode;var g=t.n(d);const u=e.TraverseType;var y=t.n(u);const m=e.X3DConstants;var _=t.n(m);const w=e.Namespace;var k=t.n(w);let S=0;const O={MATCH_ANY:S++,MATCH_EVERY:S++,MATCH_ONLY_ONE:S++},f=k().add("MatchCriterion",O);let b=0;const T={BOUNDS:b++,GEOMETRY:b++},N=k().add("IntersectionType",T);let C=0;const P={ANY:C++,CLOSEST:C++,ALL:C++,ALL_SORTED:C++},G=k().add("SortOrder",P),M=e.Matrix4;var v=t.n(M);const B=e.QuickSort;var x=t.n(B);const j=e.ObjectCache;const A=t.n(j)()(v());function F(e,t){return e.distance<t.distance}function L(e){g().call(this,e),this.addType(_().X3DPickSensorNode),this.objectType=new Set,this.intersectionType=N.BOUNDS,this.sortOrder=G.CLOSEST,this.pickTargetNodes=new Set,this.modelMatrices=[],this.targets=[],this.targets.size=0,this.pickedTargets=[],this.pickedTargetsSorter=new(x())(this.pickedTargets,F),this.pickedGeometries=new(o().MFNode)}Object.assign(Object.setPrototypeOf(L.prototype,g().prototype),{initialize(){this.getLive().addInterest("set_live__",this),this._enabled.addInterest("set_live__",this),this._objectType.addInterest("set_objectType__",this),this._matchCriterion.addInterest("set_matchCriterion__",this),this._intersectionType.addInterest("set_intersectionType__",this),this._sortOrder.addInterest("set_sortOrder__",this),this._pickTarget.addInterest("set_pickTarget__",this),this.set_objectType__(),this.set_matchCriterion__(),this.set_intersectionType__(),this.set_sortOrder__(),this.set_pickTarget__()},getObjectType(){return this.objectType},getMatchCriterion(){return this.matchCriterion},getIntersectionType(){return this.intersectionType},getSortOrder(){return this.sortOrder},getModelMatrices(){return this.modelMatrices},getTargets(){return this.targets},getPickShape:(()=>{const e=new WeakMap;return function(t){const i=e.get(t);if(void 0!==i)return i;const n=this.getBrowser().getPrivateScene(),s=n.createNode("Shape",!1),o=n.createNode("CollidableShape",!1);return s.setPrivate(!0),o.setPrivate(!0),o.setConvex(!0),s._geometry=t,o._shape=s,s.setup(),o.setup(),e.set(t,o),o}})(),getPickedGeometries(){const e=this.targets,t=e.size,i=this.pickedTargets,n=this.pickedGeometries;i.length=0;for(let n=0;n<t;++n){const t=e[n];t.intersected&&i.push(t)}if(0===i.length)return n.length=0,n;switch(this.sortOrder){case G.ANY:i.length=1,n[0]=this.getPickedGeometry(i[0]),n.length=1;break;case G.CLOSEST:this.pickedTargetsSorter.sort(0,i.length),i.length=1,n[0]=this.getPickedGeometry(i[0]),n.length=1;break;case G.ALL:for(var s=0,o=i.length;s<o;++s)n[s]=this.getPickedGeometry(i[s]);n.length=o;break;case G.ALL_SORTED:this.pickedTargetsSorter.sort(0,i.length);for(s=0,o=i.length;s<o;++s)n[s]=this.getPickedGeometry(i[s]);n.length=o}return n},getPickedGeometry(e){const t=this.getExecutionContext(),i=e.geometryNode;if(i.getExecutionContext()===t)return i;const n=i.getExecutionContext();if(n.getType().includes(_().X3DPrototypeInstance)&&n.getExecutionContext()===t)return n;const s=e.pickingHierarchy;for(let e=s.length-1;e>=0;--e){const i=s[e];if(i.getExecutionContext()===t)return i;const n=i.getExecutionContext();if(n.getType().includes(_().X3DPrototypeInstance)&&n.getExecutionContext()===t)return n}return null},getPickedTargets(){return this.pickedTargets},set_live__(){this.getLive().getValue()&&this._enabled.getValue()&&!this.objectType.has("NONE")?(this.getBrowser().addPickSensor(this),this.setPickableObject(!0)):(this.getBrowser().removePickSensor(this),this.setPickableObject(!1))},set_objectType__(){this.objectType.clear();for(let e=0,t=this._objectType.length;e<t;++e)this.objectType.add(this._objectType[e]);this.set_live__()},set_matchCriterion__:(()=>{const e=new Map([["MATCH_ANY",f.MATCH_ANY],["MATCH_EVERY",f.MATCH_EVERY],["MATCH_ONLY_ONE",f.MATCH_ONLY_ONE]]);return function(){this.matchCriterion=e.get(this._matchCriterion.getValue()),void 0===this.matchCriterion&&(this.matchCriterion=MatchCriterionType.MATCH_ANY)}})(),set_intersectionType__:(()=>{const e=new Map([["BOUNDS",N.BOUNDS],["GEOMETRY",N.GEOMETRY]]);return function(){this.intersectionType=e.get(this._intersectionType.getValue()),void 0===this.intersectionType&&(this.intersectionType=N.BOUNDS)}})(),set_sortOrder__:(()=>{const e=new Map([["ANY",G.ANY],["CLOSEST",G.CLOSEST],["ALL",G.ALL],["ALL_SORTED",G.ALL_SORTED]]);return function(){this.sortOrder=e.get(this._sortOrder.getValue()),void 0===this.sortOrder&&(this.sortOrder=G.CLOSEST)}})(),set_pickTarget__(){this.pickTargetNodes.clear();for(let e=0,t=this._pickTarget.length;e<t;++e)try{const t=this._pickTarget[e].getValue().getInnerNode(),i=t.getType();for(let e=i.length-1;e>=0;--e)switch(i[e]){case _().Inline:case _().Shape:case _().X3DGroupingNode:this.pickTargetNodes.add(t);break;default:continue}}catch{}},traverse(e,t){e===y().PICKING&&this.isPickableObject()&&this.modelMatrices.push(A.pop().assign(t.getModelViewMatrix().get()))},collect(e,t,i){const n=this.pickTargetNodes;if(i.some((e=>n.has(e)))){const n=this.targets;if(n.size<n.length)var s=n[n.size];else{s={modelMatrix:new(v()),pickingHierarchy:[],pickedPoint:[],intersections:[]};n.push(s)}++n.size,s.intersected=!1,s.geometryNode=e,s.pickedPoint.length=0,s.intersections.length=0,s.modelMatrix.assign(t);const o=s.pickingHierarchy;for(let e=0,t=i.length;e<t;++e)o[e]=i[e];o.length=length}},process(){const e=this.modelMatrices;for(let t=0,i=e.length;t<i;++t)A.push(e[t]);this.modelMatrices.length=0,this.targets.size=0}}),Object.defineProperties(L,l().getStaticProperties("X3DPickSensorNode","Picking",1));const V=L,D=k().add("X3DPickSensorNode",V),E=e.Vector3;var z=t.n(E);const I=e.Box3;var R=t.n(I);const Y=e.Line3;var H=t.n(Y);function X(e){D.call(this,e),this.addType(_().LinePickSensor)}Object.assign(Object.setPrototypeOf(X.prototype,D.prototype),{initialize(){D.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode=null;try{const e=this._pickingGeometry.getValue().getInnerNode(),t=e.getType();for(let i=t.length-1;i>=0;--i)switch(t[i]){case _().IndexedLineSet:case _().LineSet:this.pickingGeometryNode=e;break;default:continue}}catch{}},process:(()=>{const e=new(R()),t=new(R()),i=new(z()),n=new(z()),s=new(v()),r=new(z()),c=new(z()),a=new(H()),h=new(z()),p=new(z()),l=[],d=[],g=new(z()),u=new(o().MFVec3f),y=new(o().MFVec3f),m=new(o().MFVec3f);return function(){if(this.pickingGeometryNode){const o=this.getModelMatrices(),_=this.getTargets();switch(this.getIntersectionType()){case N.BOUNDS:{for(let s=0,r=o.length;s<r;++s){const r=o[s];e.assign(this.pickingGeometryNode.getBBox()).multRight(r);for(let s=0,o=_.size;s<o;++s){const o=_[s];t.assign(o.geometryNode.getBBox()).multRight(o.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),o.intersected=!0,o.distance=i.distance(n))}}const s=this.getPickedGeometries(),r=!!s.length;s.assign(s.filter((e=>e))),r!==this._isActive.getValue()&&(this._isActive=r),this._pickedGeometry.equals(s)||(this._pickedGeometry=s);break}case N.GEOMETRY:{for(let g=0,u=o.length;g<u;++g){const u=o[g];e.assign(this.pickingGeometryNode.getBBox()).multRight(u);for(let o=0,g=_.size;o<g;++o){const g=_[o],y=g.geometryNode,m=this.pickingGeometryNode.getVertices();t.assign(y.getBBox()).multRight(g.modelMatrix),s.assign(g.modelMatrix).inverse().multLeft(u);for(let e=0,t=m.length;e<t;e+=8)if(s.multVecMatrix(r.set(m[e+0],m[e+1],m[e+2])),s.multVecMatrix(c.set(m[e+4],m[e+5],m[e+6])),a.setPoints(r,c),d.length=0,y.intersectsLine(a,g.modelMatrix,l,d))for(let e=0,t=d.length;e<t;++e){const t=d[e];h.assign(t.point).subtract(r),p.assign(t.point).subtract(c);h.add(p).magnitude()<=r.distance(c)&&g.intersections.push(t)}g.intersections.length&&(i.assign(e.center),n.assign(t.center),g.intersected=!0,g.distance=i.distance(n))}}const w=this.getPickedGeometries(),k=!!w.length;w.assign(w.filter((e=>e))),k!==this._isActive.getValue()&&(this._isActive=k),this._pickedGeometry.equals(w)||(this._pickedGeometry=w);const S=this.getPickedTargets();u.length=0,y.length=0,m.length=0;for(let e=0,t=S.length;e<t;++e){const t=S[e].intersections;for(let e=0,i=t.length;e<i;++e){const i=t[e],n=i.texCoord;g.set(n.x,n.y,n.z),u.push(g),y.push(i.normal),m.push(i.point)}}this._pickedTextureCoordinate.equals(u)||(this._pickedTextureCoordinate=u),this._pickedNormal.equals(y)||(this._pickedNormal=y),this._pickedPoint.equals(m)||(this._pickedPoint=m);break}}}D.prototype.process.call(this)}})()}),Object.defineProperties(X,{...l().getStaticProperties("LinePickSensor","Picking",1,"children","3.2"),fieldDefinitions:{value:new(h())([new(c())(_().inputOutput,"metadata",new(o().SFNode)),new(c())(_().inputOutput,"description",new(o().SFString)),new(c())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(_().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(_().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(_().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(_().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(_().outputOnly,"isActive",new(o().SFBool)),new(c())(_().outputOnly,"pickedTextureCoordinate",new(o().MFVec3f)),new(c())(_().outputOnly,"pickedNormal",new(o().MFVec3f)),new(c())(_().outputOnly,"pickedPoint",new(o().MFVec3f)),new(c())(_().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(_().inputOutput,"pickTarget",new(o().MFNode)),new(c())(_().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}});const U=X,q=k().add("LinePickSensor",U),W=e.X3DGroupingNode;var K=t.n(W);function Q(e){this.addType(_().X3DPickableObject),this.objectType=new Set}Object.assign(Q.prototype,{initialize(){this._objectType.addInterest("set_objectType__",this),this.set_objectType__()},getObjectType(){return this.objectType},set_objectType__(){this.objectType.clear();for(var e=0,t=this._objectType.length;e<t;++e)this.objectType.add(this._objectType[e])},dispose(){}}),Object.defineProperties(Q,l().getStaticProperties("X3DPickableObject","Picking",1));const J=Q,Z=k().add("X3DPickableObject",J);function $(e){K().call(this,e),Z.call(this,e),this.addType(_().PickableGroup),this.pickSensorNodes=new Set}Object.assign(Object.setPrototypeOf($.prototype,K().prototype),Z.prototype,{initialize(){K().prototype.initialize.call(this),Z.prototype.initialize.call(this),this._pickable.addInterest("set_pickable__",this),this.set_pickable__()},set_pickableObjects__(){this.set_pickable__()},set_pickable__(){this.setPickableObject(this._pickable.getValue()||this.getTransformSensors().size)},traverse(e,t){if(e===y().PICKING){if(this._pickable.getValue()){if(this.getObjectType().has("NONE"))return;const i=this.getBrowser(),n=i.getPickable();if(this.getObjectType().has("ALL"))n.push(!0),K().prototype.traverse.call(this,e,t),n.pop();else{const s=this.pickSensorNodes,o=i.getPickSensors();for(const e of o.at(-1)){if(!e.getObjectType().has("ALL")){let t=0;for(const i of this.getObjectType())if(e.getObjectType().has(i)){++t;break}switch(e.getMatchCriterion()){case f.MATCH_ANY:if(0===t)continue;break;case f.MATCH_EVERY:if(t!==pickSensor.getObjectType().size)continue;break;case f.MATCH_ONLY_ONE:if(1!==t)continue}}s.add(e)}n.push(!0),o.push(s),K().prototype.traverse.call(this,e,t),o.pop(),n.pop(),s.clear()}}}else K().prototype.traverse.call(this,e,t)},dispose(){Z.prototype.dispose.call(this),K().prototype.dispose.call(this)}}),Object.defineProperties($,{...l().getStaticProperties("PickableGroup","Picking",1,"children","3.2"),fieldDefinitions:{value:new(h())([new(c())(_().inputOutput,"metadata",new(o().SFNode)),new(c())(_().inputOutput,"description",new(o().SFString)),new(c())(_().inputOutput,"pickable",new(o().SFBool)(!0)),new(c())(_().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(_().inputOutput,"visible",new(o().SFBool)(!0)),new(c())(_().inputOutput,"bboxDisplay",new(o().SFBool)),new(c())(_().initializeOnly,"bboxSize",new(o().SFVec3f)(-1,-1,-1)),new(c())(_().initializeOnly,"bboxCenter",new(o().SFVec3f)),new(c())(_().inputOnly,"addChildren",new(o().MFNode)),new(c())(_().inputOnly,"removeChildren",new(o().MFNode)),new(c())(_().inputOutput,"children",new(o().MFNode))]),enumerable:!0}});const ee=$,te=k().add("PickableGroup",ee),ie=e.X3DCast;var ne=t.n(ie);const se=e.Rotation4;var oe=t.n(se);const re=e.AmmoClass;var ce=t.n(re);function ae(){this.broadphase=new(ce().btDbvtBroadphase),this.collisionConfiguration=new(ce().btDefaultCollisionConfiguration),this.dispatcher=new(ce().btCollisionDispatcher)(this.collisionConfiguration),this.collisionWorld=new(ce().btCollisionWorld)(this.dispatcher,this.broadphase,this.collisionConfiguration),this.compoundShape1=new(ce().btCompoundShape),this.motionState1=new(ce().btDefaultMotionState),this.constructionInfo1=new(ce().btRigidBodyConstructionInfo)(0,this.motionState1,this.compoundShape1),this.rigidBody1=new(ce().btRigidBody)(this.constructionInfo1),this.compoundShape2=new(ce().btCompoundShape),this.motionState2=new(ce().btDefaultMotionState),this.constructionInfo2=new(ce().btRigidBodyConstructionInfo)(0,this.motionState2,this.compoundShape2),this.rigidBody2=new(ce().btRigidBody)(this.constructionInfo2),this.collisionWorld.addCollisionObject(this.rigidBody1),this.collisionWorld.addCollisionObject(this.rigidBody2)}Object.assign(ae.prototype,{constuctor:ae,setChildShape1(e,t){this.setChildShape(this.compoundShape1,e,t)},setChildShape2(e,t){this.setChildShape(this.compoundShape2,e,t)},setChildShape1Components(e,t,i){this.setChildShapeComponents(this.compoundShape1,e,t,i)},setChildShape2Components(e,t,i){this.setChildShapeComponents(this.compoundShape2,e,t,i)},setChildShape:(()=>{const e=new(z()),t=new(oe()),i=new(z())(1,1,1),n=new(ce().btVector3)(0,0,0);return function(s,o,r){s.getNumChildShapes()&&s.removeChildShapeByIndex(0),r.getNumChildShapes()&&(o.get(e,t,i),n.setValue(i.x,i.y,i.z),r.setLocalScaling(n),s.addChildShape(this.getTransform(e,t),r))}})(),setChildShapeComponents(e,t,i,n){e.getNumChildShapes()&&e.removeChildShapeByIndex(0),n.getNumChildShapes()&&(n.setLocalScaling(i),e.addChildShape(t,n))},contactTest(){this.collisionWorld.performDiscreteCollisionDetection();const e=this.dispatcher.getNumManifolds();for(let t=0;t<e;++t){const e=this.dispatcher.getManifoldByIndexInternal(t),i=e.getNumContacts();for(let t=0;t<i;++t){if(e.getContactPoint(t).getDistance()<=0)return!0}}return!1},getTransform:(()=>{const e=new(ce().btTransform),t=new(ce().btVector3)(0,0,0),i=new(v());return function(n,s,o){const r=o||e;return i.set(n,s),t.setValue(i[12],i[13],i[14]),r.getBasis().setValue(i[0],i[4],i[8],i[1],i[5],i[9],i[2],i[6],i[10]),r.setOrigin(t),r}})()});const he=ae,pe=k().add("VolumePicker",he);function le(e){D.call(this,e),this.addType(_().PointPickSensor),this.picker=new pe,this.compoundShapes=[]}Object.assign(Object.setPrototypeOf(le.prototype,D.prototype),{initialize(){D.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode?._rebuild.removeInterest("set_geometry__",this),this.pickingGeometryNode=ne()(_().PointSet,this._pickingGeometry),this.pickingGeometryNode?._rebuild.addInterest("set_geometry__",this),this.set_geometry__()},set_geometry__:(()=>{const e=new(ce().btVector3)(1,1,1),t=new(ce().btVector3),i=new(ce().btTransform);return function(){const n=this.compoundShapes;if(this.pickingGeometryNode){const s=this.pickingGeometryNode.getCoord();if(s){const o=s.getSize();for(let r=0;r<o;++r)if(r<n.length){const o=n[r],c=s.get1Point(r,o.point);t.setValue(c.x,c.y,c.z),i.setOrigin(t),o.setLocalScaling(e),o.updateChildTransform(0,i)}else{const e=new(ce().btCompoundShape),o=new(ce().btSphereShape)(0),c=s.get1Point(r,new(z()));e.point=c,t.setValue(c.x,c.y,c.z),i.setOrigin(t),e.addChildShape(i,o),n.push(e)}n.length=o}else n.length=0}else n.length=0}})(),process:(()=>{const e=new(R()),t=new(R()),i=new(z()),n=new(z()),s=new(ce().btTransform),r=new(ce().btVector3),c=new(z()),a=new(oe()),h=new(z())(1,1,1),p=new(o().MFVec3f);return function(){if(this.pickingGeometryNode){const o=this.getModelMatrices(),l=this.getTargets();switch(this.getIntersectionType()){case N.BOUNDS:{for(let s=0,r=o.length;s<r;++s){const r=o[s];e.assign(this.pickingGeometryNode.getBBox()).multRight(r);for(let s=0,o=l.size;s<o;++s){const o=l[s];t.assign(o.geometryNode.getBBox()).multRight(o.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),o.intersected=!0,o.distance=i.distance(n))}}const s=this.getPickedGeometries(),r=!!s.length;s.assign(s.filter((e=>e))),r!==this._isActive.getValue()&&(this._isActive=r),this._pickedGeometry.equals(s)||(this._pickedGeometry=s);break}case N.GEOMETRY:{const d=this.picker,g=this.compoundShapes;for(let p=0,u=o.length;p<u;++p){const u=o[p];e.assign(this.pickingGeometryNode.getBBox()).multRight(u),u.get(c,a,h),d.getTransform(c,a,s),r.setValue(h.x,h.y,h.z);for(let o=0,c=g.length;o<c;++o){const c=g[o];d.setChildShape1Components(s,r,c);for(let s=0,o=l.size;s<o;++s){const o=l[s],r=this.getPickShape(o.geometryNode);t.assign(o.geometryNode.getBBox()).multRight(o.modelMatrix),d.setChildShape2(o.modelMatrix,r.getCompoundShape()),d.contactTest()&&(i.assign(e.center),n.assign(t.center),o.intersected=!0,o.distance=i.distance(n),o.pickedPoint.push(c.point))}}}const u=this.getPickedGeometries(),y=!!u.length;u.assign(u.filter((e=>e))),y!==this._isActive.getValue()&&(this._isActive=y),this._pickedGeometry.equals(u)||(this._pickedGeometry=u);const m=this.getPickedTargets();p.length=0;for(let e=0,t=m.length;e<t;++e){const t=m[e].pickedPoint;for(let e=0,i=t.length;e<i;++e)p.push(t[e])}this._pickedPoint.equals(p)||(this._pickedPoint=p);break}}}D.prototype.process.call(this)}})()}),Object.defineProperties(le,{...l().getStaticProperties("PointPickSensor","Picking",1,"children","3.2"),fieldDefinitions:{value:new(h())([new(c())(_().inputOutput,"metadata",new(o().SFNode)),new(c())(_().inputOutput,"description",new(o().SFString)),new(c())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(_().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(_().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(_().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(_().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(_().outputOnly,"isActive",new(o().SFBool)),new(c())(_().outputOnly,"pickedPoint",new(o().MFVec3f)),new(c())(_().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(_().inputOutput,"pickTarget",new(o().MFNode)),new(c())(_().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}});const de=le,ge=k().add("PointPickSensor",de);function ue(e){D.call(this,e),this.addType(_().PrimitivePickSensor),this.picker=new pe}Object.assign(Object.setPrototypeOf(ue.prototype,D.prototype),{initialize(){D.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode=null;try{const e=this._pickingGeometry.getValue().getInnerNode(),t=e.getType();for(let i=t.length-1;i>=0;--i)switch(t[i]){case _().Box:case _().Cone:case _().Cylinder:case _().Sphere:this.pickingGeometryNode=e;break;default:continue}}catch{}},process:(()=>{const e=new(R()),t=new(R()),i=new(z()),n=new(z());return function(){if(this.pickingGeometryNode){const s=this.getModelMatrices(),o=this.getTargets();switch(this.getIntersectionType()){case N.BOUNDS:{for(let r=0,c=s.length;r<c;++r){const c=s[r];e.assign(this.pickingGeometryNode.getBBox()).multRight(c);for(let s=0,r=o.size;s<r;++s){const r=o[s];t.assign(r.geometryNode.getBBox()).multRight(r.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),r.intersected=!0,r.distance=i.distance(n))}}const r=this.getPickedGeometries(),c=!!r.length;r.assign(r.filter((e=>e))),c!==this._isActive.getValue()&&(this._isActive=c),this._pickedGeometry.equals(r)||(this._pickedGeometry=r);break}case N.GEOMETRY:{const r=this.picker;for(let c=0,a=s.length;c<a;++c){const a=s[c],h=this.getPickShape(this.pickingGeometryNode);e.assign(this.pickingGeometryNode.getBBox()).multRight(a),r.setChildShape1(a,h.getCompoundShape());for(let s=0,c=o.size;s<c;++s){const c=o[s],a=this.getPickShape(c.geometryNode);t.assign(c.geometryNode.getBBox()).multRight(c.modelMatrix),r.setChildShape2(c.modelMatrix,a.getCompoundShape()),r.contactTest()&&(i.assign(e.center),n.assign(t.center),c.intersected=!0,c.distance=i.distance(n))}}const c=this.getPickedGeometries(),a=!!c.length;c.assign(c.filter((e=>e))),a!==this._isActive.getValue()&&(this._isActive=a),this._pickedGeometry.equals(c)||(this._pickedGeometry=c);break}}}D.prototype.process.call(this)}})()}),Object.defineProperties(ue,{...l().getStaticProperties("PrimitivePickSensor","Picking",2,"children","3.2"),fieldDefinitions:{value:new(h())([new(c())(_().inputOutput,"metadata",new(o().SFNode)),new(c())(_().inputOutput,"description",new(o().SFString)),new(c())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(_().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(_().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(_().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(_().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(_().outputOnly,"isActive",new(o().SFBool)),new(c())(_().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(_().inputOutput,"pickTarget",new(o().MFNode)),new(c())(_().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}});const ye=ue,me=k().add("PrimitivePickSensor",ye);function _e(e){D.call(this,e),this.addType(_().VolumePickSensor),this.picker=new pe}Object.assign(Object.setPrototypeOf(_e.prototype,D.prototype),{initialize(){D.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode=ne()(_().X3DGeometryNode,this._pickingGeometry)},process:(()=>{const e=new(R()),t=new(R()),i=new(z()),n=new(z());return function(){if(this.pickingGeometryNode){const s=this.getModelMatrices(),o=this.getTargets();switch(this.getIntersectionType()){case N.BOUNDS:{for(let r=0,c=s.length;r<c;++r){const c=s[r];e.assign(this.pickingGeometryNode.getBBox()).multRight(c);for(let s=0,r=o.size;s<r;++s){const r=o[s];t.assign(r.geometryNode.getBBox()).multRight(r.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),r.intersected=!0,r.distance=i.distance(n))}}const r=this.getPickedGeometries(),c=!!r.length;r.assign(r.filter((e=>e))),c!==this._isActive.getValue()&&(this._isActive=c),this._pickedGeometry.equals(r)||(this._pickedGeometry=r);break}case N.GEOMETRY:{const r=this.picker;for(let c=0,a=s.length;c<a;++c){const a=s[c],h=this.getPickShape(this.pickingGeometryNode);e.assign(this.pickingGeometryNode.getBBox()).multRight(a),r.setChildShape1(a,h.getCompoundShape());for(let s=0,c=o.size;s<c;++s){const c=o[s],a=this.getPickShape(c.geometryNode);t.assign(c.geometryNode.getBBox()).multRight(c.modelMatrix),r.setChildShape2(c.modelMatrix,a.getCompoundShape()),r.contactTest()&&(i.assign(e.center),n.assign(t.center),c.intersected=!0,c.distance=i.distance(n))}}const c=this.getPickedGeometries(),a=!!c.length;c.assign(c.filter((e=>e))),a!==this._isActive.getValue()&&(this._isActive=a),this._pickedGeometry.equals(c)||(this._pickedGeometry=c);break}}}D.prototype.process.call(this)}})()}),Object.defineProperties(_e,{...l().getStaticProperties("VolumePickSensor","Picking",3,"children","3.2"),fieldDefinitions:{value:new(h())([new(c())(_().inputOutput,"metadata",new(o().SFNode)),new(c())(_().inputOutput,"description",new(o().SFString)),new(c())(_().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(_().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(_().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(_().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(_().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(_().outputOnly,"isActive",new(o().SFBool)),new(c())(_().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(_().inputOutput,"pickTarget",new(o().MFNode)),new(c())(_().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}});const we=_e,ke=k().add("VolumePickSensor",we);n().add({name:"Picking",concreteNodes:[q,te,ge,me,ke],abstractNodes:[D,Z]});k().add("PickingComponent",undefined)})();