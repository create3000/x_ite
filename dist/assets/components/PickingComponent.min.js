/* X_ITE v14.0.3 */
const e=window[Symbol.for("X_ITE.X3D-14.0.3")];(()=>{var t={n:e=>{var i=e&&e.__esModule?()=>e.default:()=>e;return t.d(i,{a:i}),i},d:(e,i)=>{for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const i=e.Components;var n=t.n(i);const s=e.Fields;var o=t.n(s);const r=e.X3DFieldDefinition;var c=t.n(r);const a=e.FieldDefinitionArray;var p=t.n(a);const h=e.X3DNode;var d=t.n(h);const l=e.X3DSensorNode;var g=t.n(l);const u=e.X3DConstants;var y=t.n(u);const m=e.Namespace;var w=t.n(m);let _=0;const S={MATCH_ANY:_++,MATCH_EVERY:_++,MATCH_ONLY_ONE:_++},k=w().add("MatchCriterion",S);let f=0;const O={BOUNDS:f++,GEOMETRY:f++},b=w().add("IntersectionType",O);let T=0;const N={ANY:T++,CLOSEST:T++,ALL:T++,ALL_SORTED:T++},C=w().add("SortOrder",N),P=e.Matrix4;var M=t.n(P);const G=e.QuickSort;var v=t.n(G);const x=e.ObjectCache;const B=t.n(x)()(M());function j(e,t){return e.distance<t.distance}function A(e){g().call(this,e),this.addType(y().X3DPickSensorNode),this.objectType=new Set,this.intersectionType=b.BOUNDS,this.sortOrder=C.CLOSEST,this.pickTargetNodes=new Set,this.modelMatrices=[],this.targets=[],this.targets.size=0,this.pickedTargets=[],this.pickedTargetsSorter=new(v())(this.pickedTargets,j),this.pickedGeometries=new(o().MFNode)}Object.assign(Object.setPrototypeOf(A.prototype,g().prototype),{initialize(){this.getLive().addInterest("set_live__",this),this._enabled.addInterest("set_live__",this),this._objectType.addInterest("set_objectType__",this),this._matchCriterion.addInterest("set_matchCriterion__",this),this._intersectionType.addInterest("set_intersectionType__",this),this._sortOrder.addInterest("set_sortOrder__",this),this._pickTarget.addInterest("set_pickTarget__",this),this.set_objectType__(),this.set_matchCriterion__(),this.set_intersectionType__(),this.set_sortOrder__(),this.set_pickTarget__()},getObjectType(){return this.objectType},getMatchCriterion(){return this.matchCriterion},getIntersectionType(){return this.intersectionType},getSortOrder(){return this.sortOrder},getModelMatrices(){return this.modelMatrices},getTargets(){return this.targets},getPickShape:(()=>{const e=new WeakMap;return function(t){const i=e.get(t);if(void 0!==i)return i;const n=this.getBrowser().getPrivateScene(),s=n.createNode("Shape",!1),o=n.createNode("CollidableShape",!1);return s.setPrivate(!0),o.setPrivate(!0),o.setConvex(!0),s._geometry=t,o._shape=s,s.setup(),o.setup(),e.set(t,o),o}})(),getPickedGeometries(){const e=this.targets,t=e.size,i=this.pickedTargets,n=this.pickedGeometries;i.length=0;for(let n=0;n<t;++n){const t=e[n];t.intersected&&i.push(t)}if(0===i.length)return n.length=0,n;switch(this.sortOrder){case C.CLOSEST:this.pickedTargetsSorter.sort(0,i.length);case C.ANY:{n[0]=null;const e=i.length;for(let t=0;t<e&&!(n[0]=this.getPickedGeometry(i[t]));++t);n.length=1;break}case C.ALL_SORTED:this.pickedTargetsSorter.sort(0,i.length);case C.ALL:{const e=i.length;for(let t=0;t<e;++t)n[t]=this.getPickedGeometry(i[t]);n.length=e;break}}return n.assign(n.filter(e=>e)),n},getPickedGeometry(e){const t=e.geometryNode;return t.isPrivate()||t.getExecutionContext().isPrivate()?null:t},getPickedTargets(){return this.pickedTargets},set_live__(){this.getLive().getValue()&&this._enabled.getValue()&&!this.objectType.has("NONE")?(this.getBrowser().addPickSensor(this),this.setPickableObject(!0)):(this.getBrowser().removePickSensor(this),this.setPickableObject(!1))},set_objectType__(){this.objectType.clear();for(const e of this._objectType)this.objectType.add(e);this.set_live__()},set_matchCriterion__:(()=>{const e=new Map([["MATCH_ANY",k.MATCH_ANY],["MATCH_EVERY",k.MATCH_EVERY],["MATCH_ONLY_ONE",k.MATCH_ONLY_ONE]]);return function(){this.matchCriterion=e.get(this._matchCriterion.getValue())??k.MATCH_ANY}})(),set_intersectionType__:(()=>{const e=new Map([["BOUNDS",b.BOUNDS],["GEOMETRY",b.GEOMETRY]]);return function(){this.intersectionType=e.get(this._intersectionType.getValue())??b.BOUNDS}})(),set_sortOrder__:(()=>{const e=new Map([["ANY",C.ANY],["CLOSEST",C.CLOSEST],["ALL",C.ALL],["ALL_SORTED",C.ALL_SORTED]]);return function(){this.sortOrder=e.get(this._sortOrder.getValue())??C.CLOSEST}})(),set_pickTarget__(){this.pickTargetNodes.clear();for(const e of this._pickTarget)try{const t=e.getValue().getInnerNode(),i=t.getType();for(let e=i.length-1;e>=0;--e)switch(i[e]){case y().Inline:case y().Shape:case y().X3DGroupingNode:this.pickTargetNodes.add(t);break;default:continue}}catch{}},traverse(e,t){this.modelMatrices.push(B.pop().assign(t.getModelViewMatrix().get()))},collect(e,t,i){const n=this.pickTargetNodes;if(!i.some(e=>n.has(e)))return;const s=this.targets;let o;s.size<s.length?o=s[s.size]:s.push(o={modelMatrix:new(M()),pickedPoint:[],intersections:[]}),++s.size,o.intersected=!1,o.geometryNode=e,o.pickedPoint.length=0,o.intersections.length=0,o.modelMatrix.assign(t)},process(){for(const e of this.modelMatrices)B.push(e);this.modelMatrices.length=0,this.targets.size=0}}),Object.defineProperties(A,d().getStaticProperties("X3DPickSensorNode","Picking",1));const F=A,L=w().add("X3DPickSensorNode",F),V=e.X3DGeometryNode;var z=t.n(V);const D=e.Vector3;var E=t.n(D);const I=e.Vector4;var R=t.n(I);const Y=e.Box3;var H=t.n(Y);const X=e.Line3;var U=t.n(X);function q(e){L.call(this,e),this.addType(y().LinePickSensor)}Object.assign(Object.setPrototypeOf(q.prototype,L.prototype),{initialize(){L.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode=null;try{const e=this._pickingGeometry.getValue().getInnerNode(),t=e.getType();for(let i=t.length-1;i>=0;--i)switch(t[i]){case y().IndexedLineSet:case y().LineSet:this.pickingGeometryNode=e;break;default:continue}}catch{}},process:(()=>{const e=new(H()),t=new(H()),i=new(E()),n=new(E()),s=new(M()),r=new(E()),c=new(E()),a=new(U()),p=new(E()),h=new(E()),d=[],l=new(E()),g=new(o().MFVec3f),u=new(o().MFVec3f),y=new(o().MFVec3f);return function(){if(this.pickingGeometryNode){const o=this.getModelMatrices(),m=this.getTargets();switch(this.getIntersectionType()){case b.BOUNDS:{for(const s of o){e.assign(this.pickingGeometryNode.getBBox()).multRight(s);for(const s of m)t.assign(s.geometryNode.getBBox()).multRight(s.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),s.intersected=!0,s.distance=i.distance(n))}const s=this.getPickedGeometries(),r=!!s.length;r!==this._isActive.getValue()&&(this._isActive=r),this._pickedGeometry.equals(s)||(this._pickedGeometry=s);break}case b.GEOMETRY:{for(const l of o){e.assign(this.pickingGeometryNode.getBBox()).multRight(l);for(const o of m){const g=o.geometryNode,u=this.pickingGeometryNode.getVertices(),y=u.length;t.assign(g.getBBox()).multRight(o.modelMatrix),s.assign(o.modelMatrix).inverse().multLeft(l);for(let e=0;e<y;e+=8)if(s.multVecMatrix(r.set(u[e+0],u[e+1],u[e+2])),s.multVecMatrix(c.set(u[e+4],u[e+5],u[e+6])),a.setPoints(r,c),d.length=0,g.intersectsLine(a,d))for(const e of d){p.assign(e.point).subtract(r),h.assign(e.point).subtract(c);p.add(h).norm()<=r.distance(c)&&o.intersections.push(e)}o.intersections.length&&(i.assign(e.center),n.assign(t.center),o.intersected=!0,o.distance=i.distance(n))}}const w=this.getPickedGeometries(),_=!!w.length;w.assign(w.filter(e=>e)),_!==this._isActive.getValue()&&(this._isActive=_),this._pickedGeometry.equals(w)||(this._pickedGeometry=w);const S=this.getPickedTargets();g.length=0,u.length=0,y.length=0;for(const e of S){const t=e.intersections;for(const e of t){const t=e.texCoord;l.set(t.x,t.y,t.z).divide(t.w),g.push(l),u.push(e.normal),y.push(e.point)}}this._pickedTextureCoordinate.equals(g)||(this._pickedTextureCoordinate=g),this._pickedNormal.equals(u)||(this._pickedNormal=u),this._pickedPoint.equals(y)||(this._pickedPoint=y);break}}}L.prototype.process.call(this)}})()}),Object.defineProperties(q,{...d().getStaticProperties("LinePickSensor","Picking",1,"children","3.2"),fieldDefinitions:{value:new(p())([new(c())(y().inputOutput,"metadata",new(o().SFNode)),new(c())(y().inputOutput,"description",new(o().SFString)),new(c())(y().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(y().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(y().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(y().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(y().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(y().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(y().inputOutput,"pickTarget",new(o().MFNode)),new(c())(y().outputOnly,"isActive",new(o().SFBool)),new(c())(y().outputOnly,"pickedTextureCoordinate",new(o().MFVec3f)),new(c())(y().outputOnly,"pickedNormal",new(o().MFVec3f)),new(c())(y().outputOnly,"pickedPoint",new(o().MFVec3f)),new(c())(y().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}}),Object.assign(z().prototype,{intersectsLine:(()=>{const e=new(M()),t={u:0,v:0,t:0},i=new(E()),n=new(E()),s=new(E());return function(o,r){if(!this.intersectsBBox(o))return r.length;o.multLineMatrix(e.assign(this.getMatrix()).inverse());const c=this.multiTexCoords[0].getValue(),a=this.normals.getValue(),p=this.vertices.getValue(),h=this.vertexCount;for(let e=0;e<h;e+=3){const h=4*e;if(i.x=p[h],i.y=p[h+1],i.z=p[h+2],n.x=p[h+4],n.y=p[h+5],n.z=p[h+6],s.x=p[h+8],s.y=p[h+9],s.z=p[h+10],!o.intersectsTriangle(i,n,s,t))continue;const{u:d,v:l,t:g}=t,u=new(E())(d*p[h]+l*p[h+4]+g*p[h+8],d*p[h+1]+l*p[h+5]+g*p[h+9],d*p[h+2]+l*p[h+6]+g*p[h+10]),y=new(R())(d*c[h]+l*c[h+4]+g*c[h+8],d*c[h+1]+l*c[h+5]+g*c[h+9],d*c[h+2]+l*c[h+6]+g*c[h+10],d*c[h+3]+l*c[h+7]+g*c[h+11]),m=3*e,w=new(E())(d*a[m]+l*a[m+3]+g*a[m+6],d*a[m+1]+l*a[m+4]+g*a[m+7],d*a[m+2]+l*a[m+5]+g*a[m+8]);r.push({texCoord:y,normal:w,point:this.getMatrix().multVecMatrix(u)})}return r.length}})(),intersectsBBox:(()=>{const e=new(E());return function(t){const{min:i,max:n,planes:s}=this,o=i.x,r=n.x,c=i.y,a=n.y,p=i.z,h=n.z;return!!(s[0].intersectsLine(t,e)&&e.x>=o&&e.x<=r&&e.y>=c&&e.y<=a)||(!!(s[1].intersectsLine(t,e)&&e.x>=o&&e.x<=r&&e.y>=c&&e.y<=a)||(!!(s[2].intersectsLine(t,e)&&e.x>=o&&e.x<=r&&e.z>=p&&e.z<=h)||(!!(s[3].intersectsLine(t,e)&&e.x>=o&&e.x<=r&&e.z>=p&&e.z<=h)||!!(s[4].intersectsLine(t,e)&&e.y>=c&&e.y<=a&&e.z>=p&&e.z<=h))))}})()});const W=q,K=w().add("LinePickSensor",W),Q=e.X3DGroupingNode;var J=t.n(Q);function Z(e){this.addType(y().X3DPickableObject),this.objectType=new Set}Object.assign(Z.prototype,{initialize(){this._objectType.addInterest("set_objectType__",this),this.set_objectType__()},getObjectType(){return this.objectType},set_objectType__(){this.objectType.clear();for(const e of this._objectType)this.objectType.add(e)},dispose(){}}),Object.defineProperties(Z,d().getStaticProperties("X3DPickableObject","Picking",1));const $=Z,ee=w().add("X3DPickableObject",$),te=e.TraverseType;var ie=t.n(te);function ne(e){J().call(this,e),ee.call(this,e),this.addType(y().PickableGroup),this.pickSensorNodes=new Set}Object.assign(Object.setPrototypeOf(ne.prototype,J().prototype),ee.prototype,{initialize(){J().prototype.initialize.call(this),ee.prototype.initialize.call(this),this._pickable.addInterest("set_pickableObjects__",this)},set_pickableObjects__(){this.setPickableObject(this._pickable.getValue()||this.getTransformSensors().size)},traverse(e,t){if(e!==ie().PICKING)return void J().prototype.traverse.call(this,e,t);if(!this._pickable.getValue()){if(this.getTransformSensors().size){const e=t.getModelViewMatrix().get();for(const t of this.getTransformSensors())t.collect(e)}return}if(this.getObjectType().has("NONE"))return;const i=this.getBrowser(),n=i.getPickable();if(this.getObjectType().has("ALL"))return n.push(!0),J().prototype.traverse.call(this,e,t),void n.pop();const s=this.pickSensorNodes,o=i.getPickSensors();for(const e of o.at(-1)){if(!e.getObjectType().has("ALL")){let t=0;for(const i of this.getObjectType())if(e.getObjectType().has(i)){++t;break}switch(e.getMatchCriterion()){case k.MATCH_ANY:if(0===t)continue;break;case k.MATCH_EVERY:if(t!==pickSensor.getObjectType().size)continue;break;case k.MATCH_ONLY_ONE:if(1!==t)continue}}s.add(e)}n.push(!0),o.push(s),J().prototype.traverse.call(this,e,t),o.pop(),n.pop(),s.clear()},dispose(){ee.prototype.dispose.call(this),J().prototype.dispose.call(this)}}),Object.defineProperties(ne,{...d().getStaticProperties("PickableGroup","Picking",1,"children","3.2"),fieldDefinitions:{value:new(p())([new(c())(y().inputOutput,"metadata",new(o().SFNode)),new(c())(y().inputOutput,"description",new(o().SFString)),new(c())(y().inputOutput,"pickable",new(o().SFBool)(!0)),new(c())(y().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(y().inputOutput,"visible",new(o().SFBool)(!0)),new(c())(y().inputOutput,"bboxDisplay",new(o().SFBool)),new(c())(y().initializeOnly,"bboxSize",new(o().SFVec3f)(-1,-1,-1)),new(c())(y().initializeOnly,"bboxCenter",new(o().SFVec3f)),new(c())(y().inputOnly,"addChildren",new(o().MFNode)),new(c())(y().inputOnly,"removeChildren",new(o().MFNode)),new(c())(y().inputOutput,"children",new(o().MFNode))]),enumerable:!0}});const se=ne,oe=w().add("PickableGroup",se),re=e.X3DCast;var ce=t.n(re);const ae=e.Rotation4;var pe=t.n(ae);const he=e.AmmoClass;var de=t.n(he);function le(){this.broadphase=new(de().btDbvtBroadphase),this.collisionConfiguration=new(de().btDefaultCollisionConfiguration),this.dispatcher=new(de().btCollisionDispatcher)(this.collisionConfiguration),this.collisionWorld=new(de().btCollisionWorld)(this.dispatcher,this.broadphase,this.collisionConfiguration),this.compoundShape1=new(de().btCompoundShape),this.motionState1=new(de().btDefaultMotionState),this.constructionInfo1=new(de().btRigidBodyConstructionInfo)(0,this.motionState1,this.compoundShape1),this.rigidBody1=new(de().btRigidBody)(this.constructionInfo1),this.compoundShape2=new(de().btCompoundShape),this.motionState2=new(de().btDefaultMotionState),this.constructionInfo2=new(de().btRigidBodyConstructionInfo)(0,this.motionState2,this.compoundShape2),this.rigidBody2=new(de().btRigidBody)(this.constructionInfo2),this.collisionWorld.addCollisionObject(this.rigidBody1),this.collisionWorld.addCollisionObject(this.rigidBody2)}Object.assign(le.prototype,{constuctor:le,setChildShape1(e,t){this.setChildShape(this.compoundShape1,e,t)},setChildShape2(e,t){this.setChildShape(this.compoundShape2,e,t)},setChildShape1Components(e,t,i){this.setChildShapeComponents(this.compoundShape1,e,t,i)},setChildShape2Components(e,t,i){this.setChildShapeComponents(this.compoundShape2,e,t,i)},setChildShape:(()=>{const e=new(E()),t=new(pe()),i=new(E())(1),n=new(de().btVector3)(0,0,0);return function(s,o,r){s.getNumChildShapes()&&s.removeChildShapeByIndex(0),r.getNumChildShapes()&&(o.get(e,t,i),n.setValue(i.x,i.y,i.z),r.setLocalScaling(n),s.addChildShape(this.getTransform(e,t),r))}})(),setChildShapeComponents(e,t,i,n){e.getNumChildShapes()&&e.removeChildShapeByIndex(0),n.getNumChildShapes()&&(n.setLocalScaling(i),e.addChildShape(t,n))},contactTest(){this.collisionWorld.performDiscreteCollisionDetection();const e=this.dispatcher.getNumManifolds();for(let t=0;t<e;++t){const e=this.dispatcher.getManifoldByIndexInternal(t),i=e.getNumContacts();for(let t=0;t<i;++t){if(e.getContactPoint(t).getDistance()<=0)return!0}}return!1},getTransform:(()=>{const e=new(de().btTransform),t=new(de().btVector3)(0,0,0),i=new(M());return function(n,s,o){const r=o||e;return i.set(n,s),t.setValue(i[12],i[13],i[14]),r.getBasis().setValue(i[0],i[4],i[8],i[1],i[5],i[9],i[2],i[6],i[10]),r.setOrigin(t),r}})()});const ge=le,ue=w().add("VolumePicker",ge);function ye(e){L.call(this,e),this.addType(y().PointPickSensor),this.picker=new ue,this.compoundShapes=[]}Object.assign(Object.setPrototypeOf(ye.prototype,L.prototype),{initialize(){L.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode?._rebuild.removeInterest("set_geometry__",this),this.pickingGeometryNode=ce()(y().PointSet,this._pickingGeometry),this.pickingGeometryNode?._rebuild.addInterest("set_geometry__",this),this.set_geometry__()},set_geometry__:(()=>{const e=new(de().btVector3)(1,1,1),t=new(de().btVector3),i=new(de().btTransform);return function(){const n=this.compoundShapes,s=this.pickingGeometryNode?.getCoord(),o=s?.getSize()??0;for(let r=0;r<o;++r)if(r<n.length){const o=n[r],c=s.get1Point(r,o.point);t.setValue(c.x,c.y,c.z),i.setOrigin(t),o.setLocalScaling(e),o.updateChildTransform(0,i)}else{const e=new(de().btCompoundShape),o=new(de().btSphereShape)(0),c=s.get1Point(r,new(E()));e.point=c,t.setValue(c.x,c.y,c.z),i.setOrigin(t),e.addChildShape(i,o),n.push(e)}n.length=o}})(),process:(()=>{const e=new(H()),t=new(H()),i=new(E()),n=new(E()),s=new(de().btTransform),r=new(de().btVector3),c=new(E()),a=new(pe()),p=new(E())(1),h=new(o().MFVec3f);return function(){if(this.pickingGeometryNode){const o=this.getModelMatrices(),d=this.getTargets();switch(this.getIntersectionType()){case b.BOUNDS:{for(const s of o){e.assign(this.pickingGeometryNode.getBBox()).multRight(s);for(const s of d)t.assign(s.geometryNode.getBBox()).multRight(s.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),s.intersected=!0,s.distance=i.distance(n))}const s=this.getPickedGeometries(),r=!!s.length;s.assign(s.filter(e=>e)),r!==this._isActive.getValue()&&(this._isActive=r),this._pickedGeometry.equals(s)||(this._pickedGeometry=s);break}case b.GEOMETRY:{const l=this.picker,g=this.compoundShapes;for(const h of o){e.assign(this.pickingGeometryNode.getBBox()).multRight(h),h.get(c,a,p),l.getTransform(c,a,s),r.setValue(p.x,p.y,p.z);for(const o of g){l.setChildShape1Components(s,r,o);for(const s of d){const r=this.getPickShape(s.geometryNode);t.assign(s.geometryNode.getBBox()).multRight(s.modelMatrix),l.setChildShape2(s.modelMatrix,r.getCompoundShape()),l.contactTest()&&(i.assign(e.center),n.assign(t.center),s.intersected=!0,s.distance=i.distance(n),s.pickedPoint.push(o.point))}}}const u=this.getPickedGeometries(),y=!!u.length;u.assign(u.filter(e=>e)),y!==this._isActive.getValue()&&(this._isActive=y),this._pickedGeometry.equals(u)||(this._pickedGeometry=u);const m=this.getPickedTargets();h.length=0;for(const e of m)for(const t of e.pickedPoint)h.push(t);this._pickedPoint.equals(h)||(this._pickedPoint=h);break}}}L.prototype.process.call(this)}})()}),Object.defineProperties(ye,{...d().getStaticProperties("PointPickSensor","Picking",1,"children","3.2"),fieldDefinitions:{value:new(p())([new(c())(y().inputOutput,"metadata",new(o().SFNode)),new(c())(y().inputOutput,"description",new(o().SFString)),new(c())(y().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(y().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(y().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(y().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(y().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(y().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(y().inputOutput,"pickTarget",new(o().MFNode)),new(c())(y().outputOnly,"isActive",new(o().SFBool)),new(c())(y().outputOnly,"pickedPoint",new(o().MFVec3f)),new(c())(y().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}});const me=ye,we=w().add("PointPickSensor",me);function _e(e){L.call(this,e),this.addType(y().PrimitivePickSensor),this.picker=new ue}Object.assign(Object.setPrototypeOf(_e.prototype,L.prototype),{initialize(){L.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode=null;try{const e=this._pickingGeometry.getValue().getInnerNode(),t=e.getType();for(let i=t.length-1;i>=0;--i)switch(t[i]){case y().Box:case y().Cone:case y().Cylinder:case y().Sphere:this.pickingGeometryNode=e;break;default:continue}}catch{}},process:(()=>{const e=new(H()),t=new(H()),i=new(E()),n=new(E());return function(){if(this.pickingGeometryNode){const s=this.getModelMatrices(),o=this.getTargets();switch(this.getIntersectionType()){case b.BOUNDS:{for(const r of s){e.assign(this.pickingGeometryNode.getBBox()).multRight(r);for(const s of o)t.assign(s.geometryNode.getBBox()).multRight(s.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),s.intersected=!0,s.distance=i.distance(n))}const r=this.getPickedGeometries(),c=!!r.length;r.assign(r.filter(e=>e)),c!==this._isActive.getValue()&&(this._isActive=c),this._pickedGeometry.equals(r)||(this._pickedGeometry=r);break}case b.GEOMETRY:{const r=this.picker;for(const c of s){const s=this.getPickShape(this.pickingGeometryNode);e.assign(this.pickingGeometryNode.getBBox()).multRight(c),r.setChildShape1(c,s.getCompoundShape());for(const s of o){const o=this.getPickShape(s.geometryNode);t.assign(s.geometryNode.getBBox()).multRight(s.modelMatrix),r.setChildShape2(s.modelMatrix,o.getCompoundShape()),r.contactTest()&&(i.assign(e.center),n.assign(t.center),s.intersected=!0,s.distance=i.distance(n))}}const c=this.getPickedGeometries(),a=!!c.length;c.assign(c.filter(e=>e)),a!==this._isActive.getValue()&&(this._isActive=a),this._pickedGeometry.equals(c)||(this._pickedGeometry=c);break}}}L.prototype.process.call(this)}})()}),Object.defineProperties(_e,{...d().getStaticProperties("PrimitivePickSensor","Picking",2,"children","3.2"),fieldDefinitions:{value:new(p())([new(c())(y().inputOutput,"metadata",new(o().SFNode)),new(c())(y().inputOutput,"description",new(o().SFString)),new(c())(y().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(y().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(y().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(y().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(y().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(y().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(y().inputOutput,"pickTarget",new(o().MFNode)),new(c())(y().outputOnly,"isActive",new(o().SFBool)),new(c())(y().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}});const Se=_e,ke=w().add("PrimitivePickSensor",Se);function fe(e){L.call(this,e),this.addType(y().VolumePickSensor),this.picker=new ue}Object.assign(Object.setPrototypeOf(fe.prototype,L.prototype),{initialize(){L.prototype.initialize.call(this),this._pickingGeometry.addInterest("set_pickingGeometry__",this),this.set_pickingGeometry__()},set_pickingGeometry__(){this.pickingGeometryNode=ce()(y().X3DGeometryNode,this._pickingGeometry)},process:(()=>{const e=new(H()),t=new(H()),i=new(E()),n=new(E());return function(){if(this.pickingGeometryNode){const s=this.getModelMatrices(),o=this.getTargets();switch(this.getIntersectionType()){case b.BOUNDS:{for(const r of s){e.assign(this.pickingGeometryNode.getBBox()).multRight(r);for(const s of o)t.assign(s.geometryNode.getBBox()).multRight(s.modelMatrix),e.intersectsBox(t)&&(i.assign(e.center),n.assign(t.center),s.intersected=!0,s.distance=i.distance(n))}const r=this.getPickedGeometries(),c=!!r.length;r.assign(r.filter(e=>e)),c!==this._isActive.getValue()&&(this._isActive=c),this._pickedGeometry.equals(r)||(this._pickedGeometry=r);break}case b.GEOMETRY:{const r=this.picker;for(const c of s){const s=this.getPickShape(this.pickingGeometryNode);e.assign(this.pickingGeometryNode.getBBox()).multRight(c),r.setChildShape1(c,s.getCompoundShape());for(const s of o){const o=this.getPickShape(s.geometryNode);t.assign(s.geometryNode.getBBox()).multRight(s.modelMatrix),r.setChildShape2(s.modelMatrix,o.getCompoundShape()),r.contactTest()&&(i.assign(e.center),n.assign(t.center),s.intersected=!0,s.distance=i.distance(n))}}const c=this.getPickedGeometries(),a=!!c.length;c.assign(c.filter(e=>e)),a!==this._isActive.getValue()&&(this._isActive=a),this._pickedGeometry.equals(c)||(this._pickedGeometry=c);break}}}L.prototype.process.call(this)}})()}),Object.defineProperties(fe,{...d().getStaticProperties("VolumePickSensor","Picking",3,"children","3.2"),fieldDefinitions:{value:new(p())([new(c())(y().inputOutput,"metadata",new(o().SFNode)),new(c())(y().inputOutput,"description",new(o().SFString)),new(c())(y().inputOutput,"enabled",new(o().SFBool)(!0)),new(c())(y().inputOutput,"objectType",new(o().MFString)("ALL")),new(c())(y().inputOutput,"matchCriterion",new(o().SFString)("MATCH_ANY")),new(c())(y().initializeOnly,"intersectionType",new(o().SFString)("BOUNDS")),new(c())(y().initializeOnly,"sortOrder",new(o().SFString)("CLOSEST")),new(c())(y().inputOutput,"pickingGeometry",new(o().SFNode)),new(c())(y().inputOutput,"pickTarget",new(o().MFNode)),new(c())(y().outputOnly,"isActive",new(o().SFBool)),new(c())(y().outputOnly,"pickedGeometry",new(o().MFNode))]),enumerable:!0}});const Oe=fe,be=w().add("VolumePickSensor",Oe);n().add({name:"Picking",concreteNodes:[K,oe,we,ke,be],abstractNodes:[L,ee]});w().add("PickingComponent",void 0)})();