/* X_ITE v10.2.0 */
const __X_ITE_X3D__=window[Symbol.for("X_ITE.X3D-10.2.0")];(()=>{"use strict";var e={n:t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},d:(t,i)=>{for(var n in i)e.o(i,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:i[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=__X_ITE_X3D__.Components;var i=e.n(t);const n=__X_ITE_X3D__.Fields;var o=e.n(n);const s=__X_ITE_X3D__.X3DFieldDefinition;var r=e.n(s);const l=__X_ITE_X3D__.FieldDefinitionArray;var a=e.n(l);const u=__X_ITE_X3D__.X3DNode;var h=e.n(u);const d=__X_ITE_X3D__.X3DConstants;var c=e.n(d);const g=__X_ITE_X3D__.X3DCast;var _=e.n(g);const p=__X_ITE_X3D__.Namespace;var f=e.n(p);function m(e){h().call(this,e),this.addType(c().Contour2D),this.childNodes=[]}function v(e,t){const i=new Set(t);return e.filter((e=>!i.has(e)))}Object.assign(Object.setPrototypeOf(m.prototype,h().prototype),{initialize(){h().prototype.initialize.call(this),this._addChildren.addInterest("set_addChildren__",this),this._removeChildren.addInterest("set_removeChildren__",this),this._children.addInterest("set_children__",this),this.set_children__()},set_addChildren__(){this._addChildren.setTainted(!0),this._addChildren.assign(v(this._addChildren,this._children));for(const e of this._addChildren)this._children.push(e);this._addChildren.length=0,this._addChildren.setTainted(!1)},set_removeChildren__(){this._removeChildren.setTainted(!0),this._children.assign(v(this._children,this._removeChildren)),this._removeChildren.length=0,this._removeChildren.setTainted(!1)},set_children__(){const e=this.childNodes;e.length=0;for(const t of this._children){const i=_()(c().NurbsCurve2D,t);if(i)e.push(i);else{const i=_()(c().ContourPolyline2D,t);if(i){e.push(i);continue}}}},addTrimmingContour(e){for(const t of this.childNodes)e.push(t.tessellate(2))}}),Object.defineProperties(m,{typeName:{value:"Contour2D",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:4}),enumerable:!0},containerField:{value:"trimmingContour",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"addChildren",new(o().MFNode)),new(r())(c().inputOnly,"removeChildren",new(o().MFNode)),new(r())(c().inputOutput,"children",new(o().MFNode))]),enumerable:!0}});const w=m;f().add("Contour2D",w);const b=w;function y(e){h().call(this,e),this.addType(c().X3DNurbsControlCurveNode)}Object.setPrototypeOf(y.prototype,h().prototype),Object.defineProperties(y,{typeName:{value:"X3DNurbsControlCurveNode",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0}});const O=y;f().add("X3DNurbsControlCurveNode",O);const N=O,C=__X_ITE_X3D__.Vector3;var P=e.n(C);function S(e){N.call(this,e),this.addType(c().ContourPolyline2D),this.controlPoints=[]}Object.assign(Object.setPrototypeOf(S.prototype,N.prototype),{tessellate(e){switch(e){case 0:{const e=this._controlPoint.getValue(),t=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n;t[i+0]=e[i+0],t[i+1]=e[i+1]}return t.length=2*i,t}case 1:{const e=this._controlPoint.getValue(),t=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n,o=3*n;t[o+0]=e[i+0],t[o+1]=0,t[o+2]=e[i+1]}return t.length=3*i,t}case 3:{const e=this._controlPoint.getValue(),t=this.controlPoints,i=this._controlPoint.length;for(let n=0;n<i;++n){const i=2*n;t[n]=new(P())(e[i+0],e[i+1],0)}return t.length=i,t}}}}),Object.defineProperties(S,{typeName:{value:"ContourPolyline2D",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:3}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"controlPoint",new(o().MFVec2d))]),enumerable:!0}});const D=S;f().add("ContourPolyline2D",D);const F=D,I=__X_ITE_X3D__.X3DGeometryNode;var V=e.n(I);const z=__X_ITE_X3D__.Vector2;var T=e.n(z);const j=__X_ITE_X3D__.Vector4;var R=e.n(j);const x={getTessellation:(e,t)=>e>0?e+1:e<0?-e*t+1:2*t+1,getClosed2D(e,t,i,n){const o=n.length;return(!(i.length===o)||i[0]===i[o-1])&&(!!n[0].equals(n[o-1])&&!!this.isPeriodic(e,o,t))},getClosed:(()=>{const e=new(P()),t=new(P());return function(i,n,o,s){const r=s.getSize();return(!(o.length===r)||o[0]===o[r-1])&&(!!s.get1Point(0,e).equals(s.get1Point(r-1,t))&&!!this.isPeriodic(i,r,n))}})(),getUClosed:(()=>{const e=new(P()),t=new(P());return function(i,n,o,s,r,l){const a=r.length===l.getSize();for(let i=0,s=o;i<s;++i){const o=i*n,s=i*n+n-1;if(a&&r[o]!==r[s])return!1;if(!l.get1Point(o,e).equals(l.get1Point(s,t)))return!1}return!!this.isPeriodic(i,n,s)}})(),getVClosed:(()=>{const e=new(P()),t=new(P());return function(i,n,o,s,r,l){const a=r.length===l.getSize();for(let i=0,s=n;i<s;++i){const s=i,u=(o-1)*n+i;if(a&&r[s]!==r[u])return!1;if(!l.get1Point(s,e).equals(l.get1Point(u,t)))return!1}return!!this.isPeriodic(i,o,s)}})(),isPeriodic(e,t,i){if(i.length===t+e){{let t=1;for(let n=1,o=e;n<o;++n)t+=i[n]===i[0];if(t===e)return!1}{let t=1;for(let n=i.length-e,o=i.length-1;n<o;++n)t+=i[n]===i[o];if(t===e)return!1}}return!0},getKnots(e,t,i,n,o){const s=e||[];for(let e=0,t=o.length;e<t;++e)s[e]=o[e];s.length=o.length;let r=!0;if(s.length===n+i){r=!1;let e=0;for(let t=1,n=s.length;t<n;++t)s[t]==s[t-1]?++e:e=0,e>i-1&&(r=!0),s[t-1]>s[t]&&(r=!0)}if(r)for(let e=0,t=n+i;e<t;++e)s[e]=e/(t-1);if(t)for(let e=1,t=i-1;e<t;++e)s.push(s.at(-1)+(s[e]-s[e-1]));return s},getWeights(e,t,i){if(i.length!==t)return;const n=e||[];for(let e=0;e<t;++e)n[e]=i[e];return n.length=t,n},getUVWeights(e,t,i,n){const o=t*i;if(n.length!==o)return;const s=e||[];for(let e=0,o=0;e<t;++e)for(let e=0;e<i;++e,++o)s[o]=n[o];return s.length=o,s},getControlPoints2D(e,t,i,n,o){const s=e||[],r=o.getValue(),l=o.length,a=!!n,u=a?P():T();s.haveWeights!==a&&(s.haveWeights=a,s.length=0);for(let e=0;e<l;++e){const t=2*e,i=s[e]||new u(0,0,0);s[e]=i.set(r[t+0],r[t+1],a?n[e]:0)}if(s.length=l,t)for(let e=1,t=i-1;e<t;++e)s.push(s[e]);return s},getControlPoints(e,t,i,n,o){const s=e||[],r=o.getSize(),l=!!n,a=l?R():P();s.haveWeights!==l&&(s.haveWeights=l,s.length=0);for(let e=0;e<r;++e){const t=s[e]=o.get1Point(e,s[e]||new a(0,0,0,0));l&&(t.w=n[e])}if(s.length=r,t)for(let e=1,t=i-1;e<t;++e)s.push(s[e]);return s},getUVControlPoints(e,t,i,n,o,s,r,l,a){const u=e||[],h=!!l,d=h?R():P();u.haveWeights!==h&&(u.haveWeights=h,u.length=0);for(let e=0;e<s;++e){let t=u[e];t||(t=u[e]=[]);for(let i=0;i<r;++i){const n=i*s+e;t[i]=a.get1Point(n,t[i]||new d(0,0,0,0)),h&&(t[i].w=l[n])}if(t.length=r,i)for(let e=1,i=o-1;e<i;++e)t.push(t[e])}if(u.length=s,t)for(let e=1,t=n-1;e<t;++e)u.push(u[e]);return u},getTexControlPoints(e,t,i,n,o,s,r,l){const a=e||[];for(let e=0;e<s;++e){let t=a[e];t||(t=a[e]=[]);for(let i=0;i<r;++i){const n=i*s+e;t[i]=l.get1Point(n,t[i]||new(R()))}if(t.length=r,i)for(let e=1,i=o-1;e<i;++e)t.push(t[e])}if(a.length=s,t)for(let e=1,t=n-1;e<t;++e)a.push(a[e]);return a}};f().add("NURBS",x);const k=x;function A(e){V().call(this,e),this.addType(c().X3DParametricGeometryNode)}Object.assign(Object.setPrototypeOf(A.prototype,V().prototype),{getKnots:(e,t,i,n,o)=>k.getKnots(e,t,i,n,o)}),Object.defineProperties(A,{typeName:{value:"X3DParametricGeometryNode",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0}});const X=A;f().add("X3DParametricGeometryNode",X);const E=X,B=__X_ITE_X3D__.X3DLineGeometryNode;var K=e.n(B);const M=function(e){return!!e&&(!!e.dtype&&new RegExp("function View[0-9]+d(:?"+e.dtype+")+").test(String(e.constructor)))};f().add("is-ndarray",M);const U=M,W=function(e){return!!e&&(void 0!==e.data&&Array.isArray(e.shape)&&void 0!==e.offset&&void 0!==e.stride)};f().add("is-ndarray-like",W);const q=W,G=function(e){return Array.isArray(e)||ArrayBuffer.isView(e)||void 0!==e.length};f().add("is-array-like",G);const Y=G;function J(e){if(e){if(U(e)||q(e))return"generic"===e.dtype?J.GENERIC_NDARRAY:J.NDARRAY;if(Y(e)){for(var t=e;Y(t[0]);t=t[0]);return"x"in t?J.ARRAY_OF_OBJECTS:J.ARRAY_OF_ARRAYS}throw new Error("Unhandled data type. Got type: "+typeof e)}}J.ARRAY_OF_OBJECTS="Obj",J.ARRAY_OF_ARRAYS="Arr",J.NDARRAY="Nd",J.GENERIC_NDARRAY="GenNd",J.PACKED="PackArr";const L=J;f().add("infer-type",L);const Z=L;const H=function(e,t,i,n,o,s){var r,l,a=[],u=!1;for(r=0;r<e.splineDimension;r++){var h=Y(e.knots)&&Y(e.knots[r]);h&&(u=!0),a.push("Deg"+e.degree[r]+(h?"":"Uniform")+((l=e.boundary[r])[0].toUpperCase()+l.slice(1)))}var d=[[u?"NU":"",e.weights?"RBS":"BS"].join("")+e.dimension+"D",a.join("_")];return n&&d.push(n+"Pts"),o&&d.push(o+"Wts"),s&&d.push(s+"Kts"),t&&d.push("debug"),i&&d.push("chk"),d.join("_")};f().add("cache-key",H);const Q=H;var $=function e(t,i){return function(i,n){void 0===i||Array.isArray(i)||(i=[i]);for(var o=[],s=0;s<i.length;s++)o.push(e.sum(i[s]));if(n)for(i=0;i<o.length;i++)void 0!==n[i]&&(o[i]="("+o[i]+" + "+n[i]+") % "+n[i]);return t+o.join("_")}};$.sum=function(e){return 0===(e=(e=Array.isArray(e)?e:[e]).filter((e=>void 0!==e&&0!==e))).length&&e.push(0),e.join(" + ")};const ee=$;f().add("variable",ee);const te=ee;var ie=[".x",".y",".z",".w"];function ne(e){return function(t,i){void 0===t||Array.isArray(t)||(t=[t]);for(var n=[],o=0;o<t.length;o++)n.push(te.sum(t[o]));if(i)for(t=0;t<n.length;t++)void 0!==i[t]&&(n[t]="("+n[t]+" + "+i[t]+") % "+i[t]);return e(n)}}function oe(e,t){if(t)switch(Z(t)){case Z.ARRAY_OF_OBJECTS:return ne((t=>{var i=t.pop();return e+"["+t.join("][")+"]"+ie[i]}));case Z.ARRAY_OF_ARRAYS:return ne((t=>e+"["+t.join("][")+"]"));case Z.GENERIC_NDARRAY:return ne((t=>e+".get("+t.join(",")+")"));case Z.NDARRAY:return ne((t=>{for(var i=[e+"Offset"],n=0;n<t.length;n++)i.push(e+"Stride"+n+" * ("+t[n]+")");return e+"["+i.join(" + ")+"]"}));case Z.PACKED:default:return}}const se=function(e){var t,i={};return(t=oe("x",e.points))&&(i.point=t),(t=oe("w",e.weights))&&(i.weight=t),(t=oe("k",e.knots))&&(i.knot=t),i};f().add("create-accessors",se);const re=se;var le=[],ae=[];const ue=function(e,t,i){if(1!==t)throw new Error("Numerical derivative not implemented for order n = "+t+".");var n,o=void 0===arguments[this.splineDimension+3]?1e-4:arguments[this.splineDimension+3];for(le.length=this.splineDimension,n=0;n<this.splineDimension;n++)le[n+1]=arguments[n+3];var s,r,l,a=this.domain,u=a[i][0],h=a[i][1],d=le[i+1],c=(h-u)*o;for("closed"===this.boundary[i]?(s=u+(d-u-c+(l=h-u))%l,r=u+(d-u+c+l)%l,c*=2):(s=Math.min(h,Math.max(u,d-c)),c=(r=Math.min(h,Math.max(u,d+c)))-s),le[i+1]=s,le[0]=ae,this.evaluate.apply(null,le),le[i+1]=r,le[0]=e,this.evaluate.apply(null,le),n=0;n<this.dimension;n++)e[n]=(e[n]-ae[n])/c;return e};f().add("numerical-derivative",ue);const he=ue,de=function(e,t){for(var i=1,n=0,o=[];n<e.length;n++)i*=Array.isArray(e[n])?e[n][1]-e[n][0]:e[n],o[n]=Array.isArray(e[n])?e[n][0]:0;for(var s=0;s<i;s++)for(t(o.slice()),n=e.length-1;n>=0;n--){if(o[n]!==(Array.isArray(e[n])?e[n][1]:e[n])-1){o[n]++;break}o[n]=Array.isArray(e[n])?e[n][0]:0}};f().add("ndloop",de);const ce=de,ge=function(e,t,i,n){var o=[];switch(Z(n)){case Z.NDARRAY:o.push("  var "+t+" = "+i+".data;"),o.push("  var "+t+"Offset = "+i+".offset;");for(var s=0;s<n.dimension;s++)o.push("  var "+t+"Stride"+s+" = "+i+".stride["+s+"];");break;case Z.ARRAY_OF_OBJECTS:case Z.ARRAY_OF_ARRAYS:o.push("  var "+t+" = "+i+";")}return o.join("\n")};f().add("accessor-preamble",ge);const _e=ge,pe=function(e,t,i){if(e){if(q(e))return t+".shape["+i+"]";for(var n=t,o=0;o<i;o++)n+="[0]";return n+".length"}return"this.size["+i+"]"};f().add("size-getter",pe);const fe=pe;var me={},ve={};const we=function(e,t,i,n,o,s,r){var l,a,u,h,d,c,g=t.splineDimension,_=t.points,p=t.degree,f=t.weights,m=void 0!==f,v=t.knots,w=t.dimension,b=t.boundary;if(null!=r){Array.isArray(r)||(r=[r]);var y=0;for(l=0;l<g;l++)void 0===r[l]&&(r[l]=0),y+=r[l];if(m&&y>1)throw new Error("Analytical derivative not implemented for rational b-splines with order n = "+y+".")}s&&(e="Basis"+e),r&&(e="Der"+r.join("_")+"_"+e);var O=me[e];if(n)var N="function"==typeof n?n:console.log;if(O)return n&&N(ve[e]),O.bind(t);var C=[],P="evaluate"+e,S=i.point;s&&(S=function(e,t){for(var i=[],n=0;n<e.length;n++){for(var o=e[n],s=[],r=0;r<o.length;r++)0!==o[r]&&s.push(o[r]);o=s.join(" + "),t[n]&&(o="("+o+" + "+t[n]+") % "+t[n]),i.push(o+" === "+T(n))}return"(("+i.join(" && ")+") ? 1 : 0)"});var D=i.weight,F=i.knot,I=te("k"),V=te("x"),z=te("w"),T=te("i"),j=te("t"),R=n?"domain":"d",x=te(n?"size":"s"),k=te(n?"knotIndex":"j"),A=!0;for(d=0;d<g;d++)Y(v)&&Y(v[d])&&(A=!1);function X(e){C.push("  "+(e||""))}function E(e){n&&X(e)}if(s)var B=[];var K=[];for(l=0;l<g;l++)s&&B.push(T([l])),K.push(j([l]));for(C.push("function "+P+" ("+(s?"":"out, ")+K.join(", ")+(s?", "+B.join(", "):"")+") {"),X("var h, m, a, b;"),o&&(X("var "+R+" = this.domain;"),X("for (var i = 0; i < this.splineDimension; i++) {"),X("  a = arguments[i + 1];"),X("  if (a < "+R+"[i][0] || a > "+R+"[i][1] || a === undefined || isNaN(a)) {"),X('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+R+'[i][0]+", "+'+R+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),X("  }"),X("}")),d=0;d<g;d++)X("var "+x(d)+" = "+fe(_,"this.points",d)+";");function M(e,t,i){return"("+e+") ? ("+t+") : ("+i+")"}C.push(_e(t,"x","this.points",_)),m&&C.push(_e(t,"w","this.weights",f)),A||C.push(_e(t,"k","this.knots",v));var U=[];for(d=0;d<g;d++)switch(Z(v)){case Z.NDARRAY:U[d]=!0;break;case Z.ARRAY_OF_ARRAYS:U[d]=Y(v[d])}for(d=0;d<g;d++)if(U[d])for(E("\n  // Bisect to locate the knot interval in dimension "+d+"\n"),X("var "+k(d)+" = 0;"),X("h = "+x(d)+";"),X("while(h > "+k(d)+" + 1) {"),X("  m = 0.5 * (h + "+k(d)+") | 0;"),X("  if ("+F([d,"m"])+" > "+j(d)+") h = m;"),X("  else "+k(d)+" = m;"),X("}"),E("\n  // Fetch knots for dimension "+d+"\n"),l=1-p[d];l<=p[d];l++)"closed"===b[d]?X(l<0?"var "+I([d,l+p[d]-1])+" = "+M(k(d)+" < "+-l,F([d,0])+" + "+F([d,[x(d),k(d),l]])+" - "+F([d,[x(d)]]),F([d,[k(d),l]]))+";":l>0?"var "+I([d,l+p[d]-1])+" = "+M(k(d)+" + "+l+" > "+x(d),F([d,x(d)])+" + "+F([d,l+" + "+k(d)+" - "+x(d)])+" - "+F([d,0]),F([d,[k(d),l]]))+";":"var "+I([d,l+p[d]-1])+" = "+F([d,[k(d),l]])+";"):X("var "+I([d,l+p[d]-1])+" = "+F([d,[k(d),l]])+";");else{for(E("\n  // Directly compute knot interval for dimension "+d+"\n"),"closed"===b[d]?X(k(d)+" = ("+j(d)+" | 0) % "+x(d)+";"):(X(k(d)+" = ("+j(d)+" | 0);"),X("if ("+k(d)+" < "+p[d]+") "+k(d)+" = "+p[d]+";"),X("if ("+k(d)+" > "+x(d)+" - 1) "+k(d)+" = "+x(d)+" - 1;")),E("\n  // Compute and clamp knots for dimension "+d+"\n"),l=1-p[d];l<=p[d];l++)X("var "+(c=I([d,l+p[d]-1]))+" = "+k(d)+" + "+l+";");if("clamped"===b[d])for(l=1-p[d];l<=p[d];l++)c=I([d,l+p[d]-1]),l<0&&X("if ("+c+" < "+p[d]+") "+c+" = "+p[d]+";"),l>0&&X("if ("+c+" > "+x(d)+") "+c+" = "+x(d)+";");"closed"===b[d]&&(E("\n  // Wrap the B-Spline parameter for closed boundary"),X(j(d)+" %= "+x(d)+";"))}for(d=0,u=[];d<g;d++)u[d]=p[d]+1;for(m&&(E("\n  // Fetch weights\n"),ce(u,(function(e){for(var t=[],i=[],n=0;n<g;n++)t[n]=[k(n),e[n]-p[n]],"closed"===b[n]&&e[n]-p[n]<0&&(i[n]=x(n));X("var "+z(e)+" = "+D(t,i)+";")}))),n&&X(m?"\n  // Fetch points and project into homogeneous (weighted) coordinates\n":"\n  // Fetch points\n"),ce(u,(function(e){for(var t=[],i=[],n=0;n<g;n++)t[n]=[k(n),e[n]-p[n]],"closed"===b[n]&&e[n]-p[n]<0&&(i[n]=x(n));if(s)X(m?"var "+V(e)+" = "+S(t,i)+" * "+z(e)+";":"var "+V(e)+" = "+S(t,i)+";");else for(n=0;n<w;n++){var o=e.concat(n);t[g]=n,X(m?"var "+V(o)+" = "+S(t,i)+" * "+z(e)+";":"var "+V(o)+" = "+S(t,i)+";")}})),E("\n"),E('// Perform De Boor"s algorithm'),d=u.length-1;d>=0;d--)for(u[d]=[p[d],p[d]+1],l=0;l<p[d];l++)for(E("\n  // Degree "+p[d]+" evaluation in dimension "+d+", step "+(l+1)+"\n"),a=p[d];a>l;a--){var W=r&&p[d]-l-r[d]<=0;W?(X("m = 1 / ("+I([d,a-l+p[d]-1])+" - "+I([d,a-1])+");"),m&&(X("a = ("+j(d)+" - "+I([d,a-1])+") * m;"),X("b = 1 - a;"))):(X("a = ("+j(d)+" - "+I([d,a-1])+") / ("+I([d,a-l+p[d]-1])+" - "+I([d,a-1])+");"),X("b = 1 - a;")),m&&ce(u,(function(e){var t=e.slice(),i=e.slice();t[d]=a,i[d]=a-1,W&&m&&X("h = "+z(t)+";"),X(z(t)+" = b * "+z(i)+" + a * "+z(t)+";")})),ce(u,(function(e){var t,i,n,o=e.slice(),r=e.slice();if(o[d]=a,r[d]=a-1,W){var u=l+1;if(s)t=m?"h * "+z(r)+" / "+z(o)+" * ":"",i=V(o)+(m?" / h":""),n=V(r)+(m?" / "+z(r):""),X(V(o)+" = "+u+" * "+t+"("+i+" - "+n+") * m;");else{var c=o.slice(),_=r.slice();for(h=0;h<w;h++)c[g]=_[g]=h,t=m?"h * "+z(r)+" / "+z(o)+" * ":"",i=V(c)+(m?" / h":""),n=V(_)+(m?" / "+z(r):""),X(V(c)+" = "+u+" * "+t+"("+i+" - "+n+") * m;")}}else if(s)X(V(o)+" = b * "+V(r)+" + a * "+V(o)+";");else for(h=0;h<w;h++)o[g]=r[g]=h,X(V(o)+" = b * "+V(r)+" + a * "+V(o)+";")})),E("\n")}if(n&&X(m?"\n  // Project back from homogeneous coordinates and return final output\n":"\n  // Return final output\n"),s)X(m?"return "+V(p)+" / "+z(p)+";":"return "+V(p)+";");else for(d=0;d<w;d++)X(m?"out["+d+"] = "+V(p.concat([d]))+" / "+z(p)+";":"out["+d+"] = "+V(p.concat([d]))+";");if(s||X("return out;"),C.push("}"),n){var q=C.join("\n");N(q),ve[e]=q}var G=new Function([C.join("\n"),"; return ",P].join(""))();return me[e]=G,G.bind(t)};f().add("evaluator",we);const be=we;var ye={};const Oe=function(e,t,i,n){var o,s,r,l,a,u,h,d,c=ye[e];if(c)return c.bind(t);var g=[],_="transform"+e;g.push("function "+_+"(m) {"),g.push("var i, w;"),g.push(_e(t,"x","this.points",t.points));var p=te(n?"size":"s");for(o=0;o<t.splineDimension;o++)g.push("var "+p(o)+" = "+fe(t.points,"this.points",o)+";");for(l=[],o=0;o<t.splineDimension;o++)r="i"+o,l.push(r),g.push("for ("+r+" = "+p(o)+"- 1; "+r+" >= 0; "+r+"--) {");for(o=0;o<t.dimension;o++)g.push("x"+o+" = "+i.point(l.concat([o])));for(a=[],o=0;o<t.dimension;o++)a.push("m["+((t.dimension+1)*(o+1)-1)+"] * x"+o);for(a.push("m["+((t.dimension+1)*(t.dimension+1)-1)+"]"),g.push("var w = ("+a.join(" + ")+") || 1.0;"),o=0;o<t.dimension;o++){for(a=[],u=t.dimension,s=0;s<u;s++)a.push("m["+(s*(u+1)+o)+"] * x"+s);a.push("m["+(s*(u+1)+o)+"]"),d=i.point(l.concat([o])),h="("+a.join(" + ")+") / w",g.push(d+" = "+h+";")}for(o=t.splineDimension-1;o>=0;o--)g.push("}");g.push("return this;"),g.push("}");var f=new Function([g.join("\n"),"; return ",_].join(""))();return n&&console.log(g.join("\n")),ye[e]=f,f.bind(t)};f().add("transform",Oe);const Ne=Oe;var Ce={};const Pe=function(e,t,i,n,o){var s=Ce[e];if(s)return s.bind(t);var r,l,a,u=t.degree,h=t.knots,d=t.splineDimension,c=t.boundary,g=[],_="support"+e,p=i.knot,f=te("t"),m=n?"domain":"d",v=te(n?"size":"s"),w=te(n?"knotIndex":"i"),b=!0;for(a=0;a<d;a++)Y(h)&&Y(h[a])&&(b=!1);function y(e){g.push("  "+(e||""))}var O=[];for(r=0;r<d;r++)O.push(f([r]));g.push("function "+_+" (out, "+O.join(", ")+") {");var N=0;function C(e,t){y(void 0===t?"out["+N+++"] = "+e.join(" + ")+";":"out["+N+++"] = ("+e.join(" + ")+" + "+t+") % "+t+";")}for(y("var h, m;"),y("var c = 0;"),o&&(y("var "+m+" = this.domain;"),y("for (var i = 0; i < this.splineDimension; i++) {"),y("  a = arguments[i + 1];"),y("  if (a < "+m+"[i][0] || a > "+m+"[i][1] || a === undefined || isNaN(a)) {"),y('    throw new Error("Invalid Spline parameter in dimension "+i+". Valid domain is ["+'+m+'[i][0]+", "+'+m+'[i][1]+"]. but got t"+i+" = "+arguments[i + 1]+".");'),y("  }"),y("}")),a=0;a<d;a++)y("var "+v(a)+" = "+fe(t.points,"this.points",a)+";");b||g.push(_e(t,"k","this.knots",h));var P=[];for(a=0;a<d;a++)switch(Z(h)){case Z.NDARRAY:P[a]=!0;break;case Z.ARRAY_OF_ARRAYS:P[a]=Y(h[a])}for(a=0;a<d;a++)P[a]?(y("var "+w(a)+" = 0;"),y("h = "+v(a)+";"),y("while(h > "+w(a)+" + 1) {"),y("  m = 0.5 * (h + "+w(a)+") | 0;"),y("  if ("+p([a,"m"])+" > "+f(a)+") h = m;"),y("  else "+w(a)+" = m;"),y("}")):"closed"===c[a]?y(w(a)+" = ("+f(a)+" | 0) % "+v(a)+";"):(y(w(a)+" = ("+f(a)+" | 0);"),y("if ("+w(a)+" < "+u[a]+") "+w(a)+" = "+u[a]+";"),y("if ("+w(a)+" > "+v(a)+" - 1) "+w(a)+" = "+v(a)+" - 1;"));for(a=0,l=[];a<d;a++)l[a]=u[a]+1;ce(l,(function(e){for(var t=[],i=[],n=0;n<d;n++)t[n]=[w(n),e[n]-u[n]],"closed"===c[n]&&e[n]-u[n]<0&&(i[n]=v(n));for(n=0;n<d;n++)C(t[n],i[n])})),y("out.length = "+N+";"),y("return out;"),g.push("}"),n&&console.log(g.join("\n"));var S=new Function([g.join("\n"),"; return ",_].join(""))();return Ce[e]=S,S.bind(t)};f().add("support",Pe);const Se=Pe;var De=[];const Fe=function(e,t,i){i=i||{};var n=(e=e||{}).points=e.points||[],o=e.faces=e.faces||[],s=i.haveWeights,r=t.dimension-s;if(Array.isArray(i.resolution))var l=i.resolution;else{var a=void 0===i.resolution?31:i.resolution;l=new Array(t.splineDimension).fill(a)}switch(t.splineDimension){case 1:for(var u=(f=(v=l[0])+!(b="closed"===t.boundary[0]))*r,h=(O=(m=i.domain||t.domain)[0])[1]-O[0],d=0;d<f;++d){var c=O[0]+h*d/v,g=d*r;if(t.evaluate(De,c),s)for(var _=De[r],p=0;p<r;++p)n[g+p]=De[p]/_;else for(p=0;p<r;++p)n[g+p]=De[p]}n.length=u;break;case 2:var f,m,v=l[0],w=l[1],b="closed"===t.boundary[0],y=w+!(D="closed"===t.boundary[1]),O=(u=(f=v+!b)*y*r,(m=i.domain||t.domain)[0]),N=m[1],C=(h=O[1]-O[0],N[1]-N[0]);for(d=0;d<f;++d){c=O[0]+h*d/v;for(var P=0;P<y;++P){var S=N[0]+C*P/w;g=(d+f*P)*r;if(t.evaluate(De,c,S),s)for(_=De[r],p=0;p<r;++p)n[g+p]=De[p]/_;else for(p=0;p<r;++p)n[g+p]=De[p]}}n.length=u;b=i.closed[0];var D=i.closed[1],F=0;for(d=0;d<v;++d){var I=d,V=d+1;b&&(V%=v);for(P=0;P<w;++P){var z=P,T=P+1;D&&(T%=w),o[F++]=I+f*z,o[F++]=V+f*z,o[F++]=V+f*T,o[F++]=I+f*z,o[F++]=V+f*T,o[F++]=I+f*T}}o.length=F;break;default:throw new Error("Can only sample contours and surfaces")}return e};f().add("sample",Fe);const Ie=Fe;var Ve={open:"open",closed:"closed",clamped:"clamped"};function ze(e){return null==e}function Te(e,t,i,n,o,s){var r,l;!e||Y(e)||U(e)?(s=s||{},this.weights=n,this.knots=i,this.degree=t,this.points=e,this.boundary=o,this.debug=s.debug,this.checkBounds=!!s.checkBounds,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0})):(s=e,this.debug=e.debug,this.checkBounds=!!e.checkBounds,this.weights=e.weights,this.knots=e.knots,this.degree=e.degree,this.boundary=e.boundary,this.points=e.points,Object.defineProperty(this,"size",{value:s.size,writable:!0,configurable:!0}));var a=Z(this.points),u=Z(this.weights),h=Z(this.knots);if(this.points)switch(a){case Z.GENERIC_NDARRAY:case Z.NDARRAY:Object.defineProperties(this,{splineDimension:{value:this.points.shape.length-1,writable:!1,configurable:!0},dimension:{value:this.points.shape[this.points.shape.length-1],writable:!1,configurable:!0},size:{get:function(){return this.points.shape.slice(0,this.points.shape.length-1)},set:function(){throw new Error("Cannot assign to read only property 'size'")},configurable:!0}});break;case Z.ARRAY_OF_OBJECTS:case Z.ARRAY_OF_ARRAYS:var d=0,c=this.size||[];c.length=0;for(var g=this.points;Y(g[0]);g=g[0])d++,c.push(g.length);if(0===d)throw new Error("Expected an array of points");Object.defineProperties(this,{splineDimension:{value:d,writable:!1,configurable:!0},dimension:{value:g.length,writable:!1,configurable:!0},size:{get:function(){var e=[];e.length=0;for(var t=0,i=this.points;t<this.splineDimension;t++,i=i[0])e[t]=i.length;return e},set:function(){throw new Error('Cannot assign to read only property "size"')},configurable:!0}});break;case Z.PACKED:default:throw new Error("Expected either a packed array, array of arrays, or ndarray of points")}else{if(void 0===this.size||null===this.size)throw new Error("Either points or a control hull size must be provided.");if(Y(this.size)||Object.defineProperty(this,"size",{value:[this.size],writable:!0,configurable:!0}),0===this.size.length)throw new Error("`size` must be a number or an array of length at least one.");Object.defineProperties(this,{splineDimension:{value:this.size.length,writable:!1,configurable:!0},dimension:{value:0,writable:!1,configurable:!0}})}if(Y(this.degree)){for(r=0;r<this.splineDimension;r++)if(ze(this.degree[r]))throw new Error("Missing degree in dimension "+(r+1))}else{var _=!ze(this.degree),p=ze(this.degree)?2:this.degree;for(this.degree=[],r=0;r<this.splineDimension;r++)if(this.size[r]<=p){if(_)throw new Error("Expected at least "+(p+1)+" points for degree "+p+" spline in dimension "+(r+1)+" but got only "+this.size[r]);this.degree[r]=this.size[r]-1}else this.degree[r]=p}if(l="string"!=typeof this.boundary?"open":this.boundary,!Ve[l])throw new Error("Boundary type must be one of "+Object.keys(Ve)+". Got "+l);for(this.boundary=Y(this.boundary)?this.boundary:[],this.boundary.length=this.splineDimension,r=0;r<this.splineDimension;r++)if(this.boundary[r]=ze(this.boundary[r])?l:this.boundary[r],!Ve[l])throw new Error("Boundary type must be one of "+Object.keys(Ve)+". Got "+l+" for dimension "+(r+1));switch(h){case Z.ARRAY_OF_ARRAYS:for(Y(this.knots)&&this.knots.length>0&&!Y(this.knots[0])&&(this.knots=[this.knots]),r=0;r<this.splineDimension;r++){if(this.size[r]<=this.degree[r])throw new Error("Expected at least "+(this.degree[r]+1)+" points in dimension "+(r+1)+" but got "+this.size[r]+".");if(Y(this.knots[r])){if("closed"!==this.boundary[r]&&this.knots[r].length!==this.degree[r]+this.size[r]+1)throw new Error("Expected "+(this.degree[r]+this.size[r]+1)+" knots in dimension "+(r+1)+" but got "+this.knots[r].length+".");if("closed"===this.boundary[r]&&this.knots[r].length!==this.size[r]+1&&!(this.knots[r].length===this.size[r]+this.degree[r]+1))throw new Error("Expected "+(this.size[r]+1)+" knots for closed spline in dimension "+(r+1)+" but got "+this.knots[r].length+".")}}case Z.NDARRAY:}var f=Q(this,this.debug,this.checkBounds,a,u,h);if(f!==this.__cacheKey){this.__cacheKey=f;var m=re(this);this.evaluate=be(this.__cacheKey,this,m,this.debug,this.checkBounds,!1),this.transform=Ne(this.__cacheKey,this,m,this.debug),this.support=Se(this.__cacheKey,this,m,this.debug,this.checkBounds),this.evaluator=function(e,t){return be(this.__cacheKey,this,m,this.debug,this.checkBounds,t,e)}}return this.numericalDerivative=he.bind(this),this}function je(){var e,t=[],i=this.points;i?q(i)&&(e=i.shape):e=this.size;for(var n=0;n<this.splineDimension;n++){var o=e?e[n]:i.length,s=this.degree[n],r="closed"===this.boundary[n];if(this.knots&&this.knots[n]){var l=this.knots[n];t[n]=[l[r?0:s],l[o]]}else t[n]=[r?0:s,o];i&&(i=i[0])}return t}function Re(e,t,i,n,o,s){var r=function(e,t,i,n,o,s){return l(e,t,i,n,o,s),r},l=Te.bind(r);return Object.defineProperty(r,"domain",{get:je}),l(e,t,i,n,o,s),r}Re.sample=Ie;const xe=Re;f().add("nurbs",xe);const ke=xe;function Ae(e){E.call(this,e),K().call(this,e),this.addType(c().NurbsCurve),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]}}Object.assign(Object.setPrototypeOf(Ae.prototype,E.prototype),K().prototype,{initialize(){E.prototype.initialize.call(this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},getTessellation(e){return k.getTessellation(this._tessellation.getValue(),e-this._order.getValue())},getClosed(e,t,i,n){return!!this._closed.getValue()&&k.getClosed(e,t,i,n)},getWeights:(e,t,i)=>k.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>k.getControlPoints(e,t,i,n,o),tessellate(){if(this._order.getValue()<2)return[];if(!this.controlPointNode)return[];if(this.controlPointNode.getSize()<this._order.getValue())return[];const e=this.getVertices(),t=[];if(e.length){const i=e.length;for(let n=0;n<i;n+=8)t.push(e[n],e[n+1],e[n+2]);t.push(e[i-4],e[i-3],e[i-2])}return t},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),n=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=(n.at(-1),n[0],this._order.getValue()-1),s=this.surface=(this.surface||ke)({boundary:["open"],degree:[o],knots:[n],points:i,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(n.length),this.sampleOptions.haveWeights=!!t;const r=ke.sample(this.mesh,s,this.sampleOptions).points,l=this.getVertices();for(let e=3,t=r.length;e<t;e+=3){const t=e-3;l.push(r[t],r[t+1],r[t+2],1),l.push(r[e],r[e+1],r[e+2],1)}},dispose(){E.prototype.dispose.call(this)}}),Object.defineProperties(Ae,{typeName:{value:"NurbsCurve",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"tessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"closed",new(o().SFBool)),new(r())(c().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode))]),enumerable:!0}});const Xe=Ae;f().add("NurbsCurve",Xe);const Ee=Xe;function Be(e){N.call(this,e),this.addType(c().NurbsCurve2D),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[]},this.array=[]}Object.assign(Object.setPrototypeOf(Be.prototype,N.prototype),{getTessellation(e){return k.getTessellation(this._tessellation.getValue(),e-this._order.getValue())},getClosed(e,t,i,n){return!!this._closed.getValue()&&k.getClosed2D(e,t,i,n)},getKnots:(e,t,i,n,o)=>k.getKnots(e,t,i,n,o),getWeights:(e,t,i)=>k.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>k.getControlPoints2D(e,t,i,n,o),tessellate(e){const t=this.array;if(t.length=0,this._order.getValue()<2)return t;if(this._controlPoint.length<this._order.getValue())return t;const i=this.getClosed(this._order.getValue(),this._knot,this._weight,this._controlPoint),n=this.getWeights(this.weights,this._controlPoint.length,this._weight),o=this.getControlPoints(this.controlPoints,i,this._order.getValue(),n,this._controlPoint),s=this.getKnots(this.knots,i,this._order.getValue(),this._controlPoint.length,this._knot),r=(s.at(-1),s[0],this._order.getValue()-1),l=this.surface=(this.surface||ke)({boundary:["open"],degree:[r],knots:[s],points:o,debug:!1});this.sampleOptions.resolution[0]=this.getTessellation(s.length),this.sampleOptions.haveWeights=!!n;const a=ke.sample(this.mesh,l,this.sampleOptions).points;switch(e){case 0:for(let e=0,i=a.length;e<i;e+=2)t.push(a[e],a[e+1]);break;case 1:for(let e=0,i=a.length;e<i;e+=2)t.push(a[e],0,a[e+1]);break;case 2:for(let e=0,i=a.length;e<i;e+=2)t.push(new(P())(a[e],a[e+1],0))}return t}}),Object.defineProperties(Be,{typeName:{value:"NurbsCurve2D",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:3}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"tessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"closed",new(o().SFBool)),new(r())(c().initializeOnly,"order",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().MFVec2d))]),enumerable:!0}});const Ke=Be;f().add("NurbsCurve2D",Ke);const Me=Ke,Ue=__X_ITE_X3D__.X3DChildNode;var We=e.n(Ue);const qe=__X_ITE_X3D__.OrientationInterpolator;var Ge=e.n(qe);const Ye=__X_ITE_X3D__.Rotation4;var Je=e.n(Ye);function Le(e){We().call(this,e),this.addType(c().NurbsOrientationInterpolator),this.addChildObjects(c().inputOutput,"rebuild",new(o().SFTime)),this.interpolator=new(Ge())(e),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}Object.assign(Object.setPrototypeOf(Le.prototype,We().prototype),{initialize(){We().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:(e,t,i,n)=>!1,getKnots:(e,t,i,n,o)=>k.getKnots(e,t,i,n,o),getWeights:(e,t,i)=>k.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>k.getControlPoints(e,t,i,n,o),requestRebuild(){this._rebuild.addEvent()},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),n=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),o=n.at(-1)-n[0],s=this._order.getValue()-1,r=this.surface=(this.surface||ke)({boundary:["open"],degree:[s],knots:[n],points:i,debug:!1});this.sampleOptions.haveWeights=!!t;const l=ke.sample(this.mesh,r,this.sampleOptions).points,a=this.interpolator;a._key.length=0,a._keyValue.length=0;for(let t=0,i=l.length-3;t<i;t+=3){const s=new(P())(l[t+3]-l[t+0],l[t+4]-l[t+1],l[t+5]-l[t+2]);a._key.push(n[0]+t/(i-3+3*e)*o),a._keyValue.push(new(Je())(P().zAxis,s))}e&&(a._key.push(n[0]+o),a._keyValue.push(a._keyValue[0]))}}),Object.defineProperties(Le,{typeName:{value:"NurbsOrientationInterpolator",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(c().inputOutput,"order",new(o().SFInt32)(3)),new(r())(c().inputOutput,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().outputOnly,"value_changed",new(o().SFRotation))]),enumerable:!0}});const Ze=Le;f().add("NurbsOrientationInterpolator",Ze);const He=Ze,Qe=__X_ITE_X3D__.Algorithm;var $e=e.n(Qe);const et=__X_ITE_X3D__.Triangle3;var tt=e.n(et);function it(e){E.call(this,e),this.addType(c().X3DNurbsSurfaceGeometryNode),this.tessellationScale=1,this.uKnots=[],this.vKnots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[],closed:[]},this.textUKnots=[],this.textVKnots=[],this.textWeights=[],this.texControlPoints=[],this.texMesh={}}Object.assign(Object.setPrototypeOf(it.prototype,E.prototype),{initialize(){E.prototype.initialize.call(this),this._texCoord.addInterest("set_texCoord__",this),this._controlPoint.addInterest("set_controlPoint__",this),this.set_texCoord__(),this.set_controlPoint__()},set_texCoord__(){this.texCoordNode?.removeInterest("requestRebuild",this),this.nurbsTexCoordNode?.removeInterest("requestRebuild",this),this.texCoordNode=_()(c().X3DTextureCoordinateNode,this._texCoord),this.nurbsTexCoordNode=_()(c().NurbsTextureCoordinate,this._texCoord),this.texCoordNode?.addInterest("requestRebuild",this),this.nurbsTexCoordNode?.addInterest("requestRebuild",this)},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this)},setTessellationScale(e){this.tessellationScale=e,this.requestRebuild()},getUTessellation(e){return Math.floor(k.getTessellation(this._uTessellation.getValue(),e-this._uOrder.getValue())*this.tessellationScale)},getVTessellation(e){return Math.floor(k.getTessellation(this._vTessellation.getValue(),e-this._vOrder.getValue())*this.tessellationScale)},getUClosed(e,t,i,n,o,s){return!!this._uClosed.getValue()&&k.getUClosed(e,t,i,n,o,s)},getVClosed(e,t,i,n,o,s){return!!this._vClosed.getValue()&&k.getVClosed(e,t,i,n,o,s)},getUVWeights:(e,t,i,n)=>k.getUVWeights(e,t,i,n),getTexControlPoints:(e,t,i,n,o,s,r,l)=>k.getTexControlPoints(e,t,i,n,o,s,r,l),getUVControlPoints:(e,t,i,n,o,s,r,l,a)=>k.getUVControlPoints(e,t,i,n,o,s,r,l,a),getTrimmingContours(){},build(){if(this._uOrder.getValue()<2)return;if(this._vOrder.getValue()<2)return;if(this._uDimension.getValue()<this._uOrder.getValue())return;if(this._vDimension.getValue()<this._vOrder.getValue())return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()!==this._uDimension.getValue()*this._vDimension.getValue())return;const e=this.getUClosed(this._uOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._uKnot,this._weight,this.controlPointNode),t=this.getVClosed(this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),this._vKnot,this._weight,this.controlPointNode),i=this.getUVWeights(this.weights,this._uDimension.getValue(),this._vDimension.getValue(),this._weight),n=this.getUVControlPoints(this.controlPoints,e,t,this._uOrder.getValue(),this._vOrder.getValue(),this._uDimension.getValue(),this._vDimension.getValue(),i,this.controlPointNode),o=this.getKnots(this.uKnots,e,this._uOrder.getValue(),this._uDimension.getValue(),this._uKnot),s=this.getKnots(this.vKnots,t,this._vOrder.getValue(),this._vDimension.getValue(),this._vKnot),r=(o.at(-1),o[0],s.at(-1),s[0],this._uOrder.getValue()-1),l=this._vOrder.getValue()-1,a=this.surface=(this.surface||ke)({boundary:["open","open"],degree:[r,l],knots:[o,s],points:n,debug:!1}),u=this.sampleOptions;u.resolution[0]=this.getUTessellation(o.length),u.resolution[1]=this.getVTessellation(s.length),u.closed[0]=e,u.closed[1]=t,u.domain=void 0,u.haveWeights=!!i,u.trimmingContours=this.getTrimmingContours();const h=ke.sample(this.mesh,a,u),d=h.faces,c=h.points,g=this.getVertices();for(let e=0,t=d.length;e<t;++e){const t=3*d[e];g.push(c[t],c[t+1],c[t+2],1)}this.buildNurbsTexCoords(e,t,this._uOrder.getValue(),this._vOrder.getValue(),o,s,this._uDimension.getValue(),this._vDimension.getValue(),a.domain),this.generateNormals(d,c),this.setSolid(this._solid.getValue()),this.setCCW(!0)},buildNurbsTexCoords:(()=>{const e=[],t=[],i=[[[0,0,0,1],[0,1,0,1]],[[1,0,0,1],[1,1,0,1]]];function n(e,t){return e[0]=e[1]=t[0],e[2]=e[3]=t.at(-1),e}return function(o,s,r,l,a,u,h,d,c){const g=this.sampleOptions;if(this.texCoordNode&&this.texCoordNode.getSize()===h*d)var _=r-1,p=l-1,f=a,m=u,v=this.getTexControlPoints(this.texControlPoints,o,s,r,l,h,d,this.texCoordNode);else if(this.nurbsTexCoordNode&&this.nurbsTexCoordNode.isValid()){var w=this.nurbsTexCoordNode,b=(_=w._uOrder.getValue()-1,p=w._vOrder.getValue()-1,f=this.getKnots(this.texUKnots,!1,w._uOrder.getValue(),w._uDimension.getValue(),w._uKnot),m=this.getKnots(this.texVKnots,!1,w._vOrder.getValue(),w._vDimension.getValue(),w._vKnot),this.getUVWeights(this.texWeights,w._uDimension.getValue(),w._vDimension.getValue(),w._weight));v=w.getControlPoints(b)}else{_=1,p=1,f=n(e,a),m=n(t,u),v=i;g.domain=c}const y=this.texSurface=(this.texSurface||ke)({boundary:["open","open"],degree:[_,p],knots:[f,m],points:v});g.closed[0]=!1,g.closed[1]=!1,g.haveWeights=!1;const O=ke.sample(this.texMesh,y,g),N=O.faces,C=O.points,P=this.getTexCoords();for(let e=0,t=N.length;e<t;++e){const t=4*N[e];P.push(C[t],C[t+1],C[t+2],C[t+3])}this.getMultiTexCoords().push(this.getTexCoords())}})(),generateNormals(e,t){const i=this.createNormals(e,t),n=this.getNormals();for(const e of i)n.push(e.x,e.y,e.z)},createNormals(e,t){const i=new Map,n=this.createFaceNormals(e,t),o=e.length;for(let t=0;t<o;++t){const n=e[t];let o=i.get(n);o||i.set(n,o=[]),o.push(t)}return this.refineNormals(i,n,$e().radians(85))},createFaceNormals:(()=>{const e=new(P()),t=new(P()),i=new(P());return function(n,o){const s=this.faceNormals||[],r=n.length;for(let l=0;l<r;l+=3){const r=3*n[l],a=3*n[l+1],u=3*n[l+2];e.set(o[r],o[r+1],o[r+2]),t.set(o[a],o[a+1],o[a+2]),i.set(o[u],o[u+1],o[u+2]);const h=tt().normal(e,t,i,s[l]||new(P()));s[l]=h,s[l+1]=h,s[l+2]=h}return s.length=r,s}})()}),Object.defineProperties(it,{typeName:{value:"X3DNurbsSurfaceGeometryNode",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0}});const nt=it;f().add("X3DNurbsSurfaceGeometryNode",nt);const ot=nt;function st(e){ot.call(this,e),this.addType(c().NurbsPatchSurface)}Object.setPrototypeOf(st.prototype,ot.prototype),Object.defineProperties(st,{typeName:{value:"NurbsPatchSurface",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(c().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().initializeOnly,"uClosed",new(o().SFBool)),new(r())(c().initializeOnly,"vClosed",new(o().SFBool)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"texCoord",new(o().SFNode)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode))]),enumerable:!0}});const rt=st;f().add("NurbsPatchSurface",rt);const lt=rt,at=__X_ITE_X3D__.PositionInterpolator;var ut=e.n(at);function ht(e){We().call(this,e),this.addType(c().NurbsPositionInterpolator),this.addChildObjects(c().inputOutput,"rebuild",new(o().SFTime)),this.interpolator=new(ut())(e),this.knots=[],this.weights=[],this.controlPoints=[],this.mesh={},this.sampleOptions={resolution:[128]}}Object.assign(Object.setPrototypeOf(ht.prototype,We().prototype),{initialize(){We().prototype.initialize.call(this),this._order.addInterest("requestRebuild",this),this._knot.addInterest("requestRebuild",this),this._weight.addInterest("requestRebuild",this),this._controlPoint.addInterest("set_controlPoint__",this),this._rebuild.addInterest("build",this),this._set_fraction.addFieldInterest(this.interpolator._set_fraction),this.interpolator._value_changed.addFieldInterest(this._value_changed),this.interpolator.setup(),this.set_controlPoint__()},set_controlPoint__(){this.controlPointNode&&this.controlPointNode.removeInterest("requestRebuild",this),this.controlPointNode=_()(c().X3DCoordinateNode,this._controlPoint),this.controlPointNode&&this.controlPointNode.addInterest("requestRebuild",this),this.requestRebuild()},getClosed:(e,t,i,n)=>!1,getKnots:(e,t,i,n,o)=>k.getKnots(e,t,i,n,o),getWeights:(e,t,i)=>k.getWeights(e,t,i),getControlPoints:(e,t,i,n,o)=>k.getControlPoints(e,t,i,n,o),requestRebuild(){this._rebuild.addEvent()},build(){if(this._order.getValue()<2)return;if(!this.controlPointNode)return;if(this.controlPointNode.getSize()<this._order.getValue())return;const e=this.getClosed(this._order.getValue(),this._knot,this._weight,this.controlPointNode),t=this.getWeights(this.weights,this.controlPointNode.getSize(),this._weight),i=this.getControlPoints(this.controlPoints,e,this._order.getValue(),t,this.controlPointNode),n=this.getKnots(this.knots,e,this._order.getValue(),this.controlPointNode.getSize(),this._knot),s=n.at(-1)-n[0],r=this._order.getValue()-1,l=this.surface=(this.surface||ke)({boundary:["open"],degree:[r],knots:[n],points:i,debug:!1});this.sampleOptions.haveWeights=!!t;const a=ke.sample(this.mesh,l,this.sampleOptions).points,u=this.interpolator;u._key.length=0,u._keyValue.length=0;for(let e=0,t=a.length;e<t;e+=3)u._key.push(n[0]+e/(t-3)*s),u._keyValue.push(new(o().SFVec3f)(a[e],a[e+1],a[e+2]))}}),Object.defineProperties(ht,{typeName:{value:"NurbsPositionInterpolator",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"set_fraction",new(o().SFFloat)),new(r())(c().inputOutput,"order",new(o().SFInt32)(3)),new(r())(c().inputOutput,"knot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().outputOnly,"value_changed",new(o().SFVec3f))]),enumerable:!0}});const dt=ht;f().add("NurbsPositionInterpolator",dt);const ct=dt,gt=__X_ITE_X3D__.X3DBoundedObject;var _t=e.n(gt);function pt(e){We().call(this,e),_t().call(this,e),this.addType(c().NurbsSet),this.geometryNodes=[]}function ft(e,t){const i=new Set(t);return e.filter((e=>!i.has(e)))}Object.assign(Object.setPrototypeOf(pt.prototype,We().prototype),_t().prototype,{initialize(){We().prototype.initialize.call(this),_t().prototype.initialize.call(this),this._tessellationScale.addInterest("set_tessellationScale__",this),this._addGeometry.addInterest("set_addGeometry__",this),this._removeGeometry.addInterest("set_removeGeometry__",this),this._geometry.addInterest("set_geometry__",this),this.set_geometry__()},getBBox(e,t){for(const t of this.geometryNodes)e.add(t.getBBox());return e},set_tessellationScale__(){const e=Math.max(0,this._tessellationScale.getValue());for(const t of this.geometryNodes)t.setTessellationScale(e)},set_addGeometry__(){this._addGeometry.setTainted(!0),this._addGeometry.assign(ft(this._addGeometry,this._geometry));for(const e of this._addGeometry)this._geometry.push(e);this._addGeometry.length=0,this._addGeometry.setTainted(!1)},set_removeGeometry__(){this._removeGeometry.setTainted(!0),this._geometry.assign(ft(this._geometry,this._removeGeometry)),this._removeGeometry.length=0,this._removeGeometry.setTainted(!1)},set_geometry__(){for(const e of this.geometryNodes)e.setTessellationScale(1);this.geometryNodes.length=0;for(const e of this._geometry){const t=_()(c().X3DNurbsSurfaceGeometryNode,e);t&&this.geometryNodes.push(t)}this.set_tessellationScale__()},dispose(){_t().prototype.dispose.call(this),We().prototype.dispose.call(this)}}),Object.defineProperties(pt,{typeName:{value:"NurbsSet",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:2}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"tessellationScale",new(o().SFFloat)(1)),new(r())(c().inputOutput,"visible",new(o().SFBool)(!0)),new(r())(c().inputOutput,"bboxDisplay",new(o().SFBool)),new(r())(c().initializeOnly,"bboxSize",new(o().SFVec3f)(-1,-1,-1)),new(r())(c().initializeOnly,"bboxCenter",new(o().SFVec3f)),new(r())(c().inputOnly,"addGeometry",new(o().MFNode)),new(r())(c().inputOnly,"removeGeometry",new(o().MFNode)),new(r())(c().inputOutput,"geometry",new(o().MFNode))]),enumerable:!0}});const mt=pt;f().add("NurbsSet",mt);const vt=mt,wt=__X_ITE_X3D__.Line3;var bt=e.n(wt);const yt={isPointInTriangle(e,t,i,n){const o=(t.y-i.y)*(e.x-i.x)+(i.x-t.x)*(e.y-i.y);if(0==o)return!1;const s=((t.y-i.y)*(n.x-i.x)+(i.x-t.x)*(n.y-i.y))/o;if(s<0||s>1)return!1;const r=((i.y-e.y)*(n.x-i.x)+(e.x-i.x)*(n.y-i.y))/o;if(r<0||r>1)return!1;const l=1-s-r;return!(l<0||l>1)}};f().add("Triangle2",yt);const Ot=yt;function Nt(e){We().call(this,e),this.addType(c().NurbsSurfaceInterpolator),this.geometry=new lt(e)}Object.assign(Object.setPrototypeOf(Nt.prototype,We().prototype),{initialize(){this._set_fraction.addInterest("set_fraction__",this),this._uOrder.addFieldInterest(this.geometry._uOrder),this._vOrder.addFieldInterest(this.geometry._vOrder),this._uDimension.addFieldInterest(this.geometry._uDimension),this._vDimension.addFieldInterest(this.geometry._vDimension),this._uKnot.addFieldInterest(this.geometry._uKnot),this._vKnot.addFieldInterest(this.geometry._vKnot),this._weight.addFieldInterest(this.geometry._weight),this._controlPoint.addFieldInterest(this.geometry._controlPoint),this.geometry._uTessellation=128,this.geometry._vTessellation=128,this.geometry._uOrder=this._uOrder,this.geometry._vOrder=this._vOrder,this.geometry._uDimension=this._uDimension,this.geometry._vDimension=this._vDimension,this.geometry._uKnot=this._uKnot,this.geometry._vKnot=this._vKnot,this.geometry._weight=this._weight,this.geometry._controlPoint=this._controlPoint,this.geometry.setup()},set_fraction__:(()=>{const e=new(P()),t=new(P()),i=new(P()),n=new(P()),o=new(bt())(P().Zero,P().zAxis),s={};return function(){const r=this._set_fraction.getValue(),l=this.geometry.getTexCoords(),a=this.geometry.getNormals(),u=this.geometry.getVertices();for(let h=0,d=0,c=l.length;h<c;h+=12,d+=9)if(e.set(l[h+0],l[h+1],0),t.set(l[h+4],l[h+5],0),i.set(l[h+7],l[h+9],0),Ot.isPointInTriangle(e,t,i,r)&&(o.set(n.set(r.x,r.y,0),P().zAxis),o.intersectsTriangle(e,t,i,s))){const e=s.u,t=s.v,i=s.t,n=new(P())(i*a[d+0]+e*a[d+3]+t*a[d+6],i*a[d+1]+e*a[d+4]+t*a[d+7],i*a[d+2]+e*a[d+5]+t*a[d+8]),o=new(P())(i*u[h+0]+e*u[h+4]+t*u[h+8],i*u[h+1]+e*u[h+5]+t*u[h+9],i*u[h+2]+e*u[h+6]+t*u[h+10]);this._normal_changed=n,this._position_changed=o}}})()}),Object.defineProperties(Nt,{typeName:{value:"NurbsSurfaceInterpolator",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOnly,"set_fraction",new(o().SFVec2f)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().outputOnly,"normal_changed",new(o().SFVec3f)),new(r())(c().outputOnly,"position_changed",new(o().SFVec3f))]),enumerable:!0}});const Ct=Nt;f().add("NurbsSurfaceInterpolator",Ct);const Pt=Ct,St=__X_ITE_X3D__.Extrusion;var Dt=e.n(St);function Ft(e){E.call(this,e),this.addType(c().NurbsSweptSurface),this.extrusion=new(Dt())(e)}Object.assign(Object.setPrototypeOf(Ft.prototype,E.prototype),{initialize(){E.prototype.initialize.call(this),this._crossSectionCurve.addInterest("set_crossSectionCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const e=this.extrusion;e._beginCap=!1,e._endCap=!1,e._solid=!0,e._ccw=!0,e._convex=!0,e._creaseAngle=Math.PI,e.setup(),e._crossSection.setTainted(!0),e._spine.setTainted(!0),this.set_crossSectionCurve__(),this.set_trajectoryCurve__()},set_crossSectionCurve__(){this.crossSectionCurveNode&&this.crossSectionCurveNode.removeInterest("requestRebuild",this),this.crossSectionCurveNode=_()(c().X3DNurbsControlCurveNode,this._crossSectionCurve),this.crossSectionCurveNode&&this.crossSectionCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode?._rebuild.removeInterest("requestRebuild",this),this.trajectoryCurveNode=_()(c().NurbsCurve,this._trajectoryCurve),this.trajectoryCurveNode?._rebuild.addInterest("requestRebuild",this)},build(){if(!this.crossSectionCurveNode)return;if(!this.trajectoryCurveNode)return;const e=this.extrusion;if(e._crossSection=this.crossSectionCurveNode.tessellate(0),e._spine=this.trajectoryCurveNode.tessellate(0),e.rebuild(),this.getColors().assign(e.getColors()),this.getTexCoords().assign(e.getTexCoords()),this.getNormals().assign(e.getNormals()),this.getVertices().assign(e.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const e=this.getNormals();for(let t=0,i=e.length;t<i;++t)e[t]=-e[t]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(Ft,{typeName:{value:"NurbsSweptSurface",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:3}),enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(c().inputOutput,"crossSectionCurve",new(o().SFNode)),new(r())(c().inputOutput,"trajectoryCurve",new(o().SFNode))]),enumerable:!0}});const It=Ft;f().add("NurbsSweptSurface",It);const Vt=It;function zt(e){E.call(this,e),this.addType(c().NurbsSwungSurface),this.extrusion=new(Dt())(e)}Object.assign(Object.setPrototypeOf(zt.prototype,E.prototype),{initialize(){E.prototype.initialize.call(this),this._profileCurve.addInterest("set_profileCurve__",this),this._trajectoryCurve.addInterest("set_trajectoryCurve__",this);const e=this.extrusion;e._beginCap=!1,e._endCap=!1,e._solid=!0,e._ccw=!0,e._convex=!0,e._creaseAngle=Math.PI,e.setup(),e._crossSection.setTainted(!0),e._spine.setTainted(!0),this.set_profileCurve__(),this.set_trajectoryCurve__()},set_profileCurve__(){this.profileCurveNode&&this.profileCurveNode.removeInterest("requestRebuild",this),this.profileCurveNode=_()(c().X3DNurbsControlCurveNode,this._profileCurve),this.profileCurveNode&&this.profileCurveNode.addInterest("requestRebuild",this)},set_trajectoryCurve__(){this.trajectoryCurveNode&&this.trajectoryCurveNode.removeInterest("requestRebuild",this),this.trajectoryCurveNode=_()(c().X3DNurbsControlCurveNode,this._trajectoryCurve),this.trajectoryCurveNode&&this.trajectoryCurveNode.addInterest("requestRebuild",this)},build(){if(!this.profileCurveNode)return;if(!this.trajectoryCurveNode)return;const e=this.extrusion;if(e._crossSection=this.profileCurveNode.tessellate(0),e._spine=this.trajectoryCurveNode.tessellate(1),e.rebuild(),this.getColors().assign(e.getColors()),this.getTexCoords().assign(e.getTexCoords()),this.getNormals().assign(e.getNormals()),this.getVertices().assign(e.getVertices()),this.getMultiTexCoords().push(this.getTexCoords()),!this._ccw.getValue()){const e=this.getNormals();for(let t=0,i=e.length;t<i;++t)e[t]=-e[t]}this.setSolid(this._solid.getValue()),this.setCCW(this._ccw.getValue())}}),Object.defineProperties(zt,{typeName:{value:"NurbsSwungSurface",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:3}),enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().initializeOnly,"ccw",new(o().SFBool)(!0)),new(r())(c().inputOutput,"profileCurve",new(o().SFNode)),new(r())(c().inputOutput,"trajectoryCurve",new(o().SFNode))]),enumerable:!0}});const Tt=zt;f().add("NurbsSwungSurface",Tt);const jt=Tt;function Rt(e){h().call(this,e),this.addType(c().NurbsTextureCoordinate),this.controlPoints=[]}Object.assign(Object.setPrototypeOf(Rt.prototype,h().prototype),{initialize(){h().prototype.initialize.call(this)},getControlPoints(e){const t=this._controlPoint.getValue(),i=this.controlPoints;for(let n=0,o=this._uDimension.getValue();n<o;++n){let s=i[n];s||(s=i[n]=[]);for(let i=0,r=this._vDimension.getValue();i<r;++i){const r=i*o+n,l=s[i]||new(R()),a=2*r;s[i]=l.set(t[a],t[a+1],0,e?e[r]:1)}}return i},isValid(){return!(this._uOrder.getValue()<2)&&(!(this._vOrder.getValue()<2)&&(!(this._uDimension.getValue()<this._uOrder.getValue())&&(!(this._vDimension.getValue()<this._vOrder.getValue())&&this._controlPoint.length===this._uDimension.getValue()*this._vDimension.getValue())))}}),Object.defineProperties(Rt,{typeName:{value:"NurbsTextureCoordinate",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:1}),enumerable:!0},containerField:{value:"texCoord",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"controlPoint",new(o().MFVec2f))]),enumerable:!0}});const xt=Rt;f().add("NurbsTextureCoordinate",xt);const kt=xt;function At(e){ot.call(this,e),this.addType(c().NurbsTrimmedSurface),this.trimmingContourNodes=[]}function Xt(e,t){const i=new Set(t);return e.filter((e=>!i.has(e)))}Object.assign(Object.setPrototypeOf(At.prototype,ot.prototype),{initialize(){ot.prototype.initialize.call(this),this._addTrimmingContour.addInterest("set_addTrimmingContour__",this),this._removeTrimmingContour.addInterest("set_removeTrimmingContour__",this),this._trimmingContour.addInterest("set_trimmingContour__",this),this.set_trimmingContour__()},set_addTrimmingContour__(){this._addTrimmingContour.setTainted(!0),this._addTrimmingContour.assign(Xt(this._addTrimmingContour,this._trimmingContour),this._addTrimmingContour.length);for(const e of this._addTrimmingContour)this._trimmingContour.push(e);this._addTrimmingContour.length=0,this._addTrimmingContour.setTainted(!1)},set_removeTrimmingContour__(){this._removeTrimmingContour.setTainted(!0),this._trimmingContour.assign(Xt(this._trimmingContour,this._removeTrimmingContour)),this._removeTrimmingContour.length=0,this._removeTrimmingContour.setTainted(!1)},set_trimmingContour__(){const e=this.trimmingContourNodes;e.length=0;for(const t of this._trimmingContour){const i=_()(c().Contour2D,t);i&&e.push(i)}},getTrimmingContours(){const e=this.trimmingContourNodes,t=[];for(const i of e)i.addTrimmingContour(t);return t}}),Object.defineProperties(At,{typeName:{value:"NurbsTrimmedSurface",enumerable:!0},componentInfo:{value:Object.freeze({name:"NURBS",level:4}),enumerable:!0},containerField:{value:"geometry",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.0",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(a())([new(r())(c().inputOutput,"metadata",new(o().SFNode)),new(r())(c().inputOutput,"uTessellation",new(o().SFInt32)),new(r())(c().inputOutput,"vTessellation",new(o().SFInt32)),new(r())(c().initializeOnly,"solid",new(o().SFBool)(!0)),new(r())(c().initializeOnly,"uClosed",new(o().SFBool)),new(r())(c().initializeOnly,"vClosed",new(o().SFBool)),new(r())(c().initializeOnly,"uOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"vOrder",new(o().SFInt32)(3)),new(r())(c().initializeOnly,"uDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"vDimension",new(o().SFInt32)),new(r())(c().initializeOnly,"uKnot",new(o().MFDouble)),new(r())(c().initializeOnly,"vKnot",new(o().MFDouble)),new(r())(c().inputOutput,"weight",new(o().MFDouble)),new(r())(c().inputOutput,"texCoord",new(o().SFNode)),new(r())(c().inputOutput,"controlPoint",new(o().SFNode)),new(r())(c().inputOnly,"addTrimmingContour",new(o().MFNode)),new(r())(c().inputOnly,"removeTrimmingContour",new(o().MFNode)),new(r())(c().inputOutput,"trimmingContour",new(o().MFNode))]),enumerable:!0}});const Et=At;f().add("NurbsTrimmedSurface",Et);const Bt=Et;i().add({name:"NURBS",concreteNodes:[b,F,Ee,Me,He,lt,ct,vt,Pt,Vt,jt,kt,Bt],abstractNodes:[N,ot,E]});const Kt=void 0;f().add("NURBS",Kt)})();