/* X_ITE v9.1.6 */(()=>{"use strict";var e={n:t=>{var n=t&&t.__esModule?()=>t.default:()=>t;return e.d(n,{a:n}),n},d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)};const t=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components");var n=e.n(t);const o=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Texturing/PixelTexture");var r=e.n(o);const i=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Texturing/TextureProperties");var a=e.n(i);const s=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Fields");var l=e.n(s);const d=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Base/X3DFieldDefinition");var u=e.n(d);const h=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Base/FieldDefinitionArray");var c=e.n(h);const m=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Core/X3DNode");var p=e.n(m);const f=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Base/X3DConstants");var g=e.n(f);const _=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Namespace");var y=e.n(_);function S(e){p().call(this,e),this.addType(g().X3DVolumeRenderStyleNode),this.volumeDataNodes=new Set}Object.assign(Object.setPrototypeOf(S.prototype,p().prototype),{addShaderFields(e){},getUniformsText:()=>"",getFunctionsText:()=>"",getVolumeData(){return this.volumeDataNodes},addVolumeData(e){this.volumeDataNodes.add(e)},removeVolumeData(e){this.volumeDataNodes.delete(e)},getNormalText(e){let t="";return e?(t+="uniform sampler3D surfaceNormals_"+this.getId()+";\n",t+="\n",t+="vec4\n",t+="getNormal_"+this.getId()+" (in vec3 texCoord)\n",t+="{\n",t+="   vec3 n = texture (surfaceNormals_"+this.getId()+", texCoord) .xyz * 2.0 - 1.0;\n",t+="\n",t+="   return vec4 (normalize (x3d_TextureNormalMatrix * n), length (n));\n",t+="}\n"):(t+="\n",t+="vec4\n",t+="getNormal_"+this.getId()+" (in vec3 texCoord)\n",t+="{\n",t+="   vec4  offset = vec4 (1.0 / vec3 (textureSize (x3d_Texture3D [0], 0)), 0.0);\n",t+="   float i0     = texture (x3d_Texture3D [0], texCoord + offset .xww) .r;\n",t+="   float i1     = texture (x3d_Texture3D [0], texCoord - offset .xww) .r;\n",t+="   float i2     = texture (x3d_Texture3D [0], texCoord + offset .wyw) .r;\n",t+="   float i3     = texture (x3d_Texture3D [0], texCoord - offset .wyw) .r;\n",t+="   float i4     = texture (x3d_Texture3D [0], texCoord + offset .wwz) .r;\n",t+="   float i5     = texture (x3d_Texture3D [0], texCoord - offset .wwz) .r;\n",t+="   vec3  n      = vec3 (i1 - i0, i3 - i2, i5 - i4);\n",t+="\n",t+="   return vec4 (normalize (x3d_TextureNormalMatrix * n), length (n));\n",t+="}\n"),t}}),Object.defineProperties(S,{typeName:{value:"X3DVolumeRenderStyleNode",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:1}),enumerable:!0}});const x=S;y().add("X3DVolumeRenderStyleNode","x_ite/Components/VolumeRendering/X3DVolumeRenderStyleNode",x);const N=x;function v(e){N.call(this,e),this.addType(g().X3DComposableVolumeRenderStyleNode)}Object.setPrototypeOf(v.prototype,N.prototype),Object.defineProperties(v,{typeName:{value:"X3DComposableVolumeRenderStyleNode",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:1}),enumerable:!0}});const w=v;y().add("X3DComposableVolumeRenderStyleNode","x_ite/Components/VolumeRendering/X3DComposableVolumeRenderStyleNode",w);const b=w,C=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Base/X3DCast");var F=e.n(C);function I(e){b.call(this,e),this.addType(g().OpacityMapVolumeStyle)}Object.assign(Object.setPrototypeOf(I.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._transferFunction.addInterest("set_transferFunction__",this),this.set_transferFunction__())},set_transferFunction__(){this.transferFunctionNode=F()(g().X3DTexture2DNode,this._transferFunction),this.transferFunctionNode||(this.transferFunctionNode=F()(g().X3DTexture3DNode,this._transferFunction)),this.transferFunctionNode||(this.transferFunctionNode=this.getBrowser().getDefaultTransferFunction())},addShaderFields(e){this._enabled.getValue()&&e.addUserDefinedField(g().inputOutput,"transferFunction_"+this.getId(),new(l().SFNode)(this.transferFunctionNode))},getUniformsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="// OpacityMapVolumeStyle\n",e+="\n",this.transferFunctionNode.getType().includes(g().X3DTexture2DNode)?(e+="uniform sampler2D transferFunction_"+this.getId()+";\n",e+="\n",e+="vec4\n",e+="getOpacityMapStyle_"+this.getId()+" (in vec4 originalColor)\n",e+="{\n",e+="   return texture (transferFunction_"+this.getId()+", originalColor .rg);\n",e+="}\n"):(e+="uniform sampler3D transferFunction_"+this.getId()+";\n",e+="\n",e+="vec4\n",e+="getOpacityMapStyle_"+this.getId()+" (in vec4 originalColor)\n",e+="{\n",e+="   return texture (transferFunction_"+this.getId()+", originalColor .rgb);\n",e+="}\n"),e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // OpacityMapVolumeStyle\n",e+="\n",e+="   textureColor = getOpacityMapStyle_"+this.getId()+" (textureColor);\n",e}}),Object.defineProperties(I,{typeName:{value:"OpacityMapVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:1}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"transferFunction",new(l().SFNode))]),enumerable:!0}});const O=I;y().add("OpacityMapVolumeStyle","x_ite/Components/VolumeRendering/OpacityMapVolumeStyle",O);const V=O,D=Symbol(),T=Symbol(),P=Symbol(),E=Symbol();function j(){}Object.assign(j.prototype,{getDefaultVoxels(){return this[D]=this.getPrivateScene().createNode("PixelTexture3D",!1),this[D]._image=[1,1,1,1,255],this[D].repeatS=!0,this[D].repeatT=!0,this[D].repeatR=!0,this[D].setPrivate(!0),this[D].setup(),this.getDefaultVoxels=function(){return this[D]},Object.defineProperty(this,"getDefaultVoxels",{enumerable:!1}),this[D]},getDefaultVolumeStyle(){return this[T]=new V(this.getPrivateScene()),this[T].setPrivate(!0),this[T].setup(),this.getDefaultVolumeStyle=function(){return this[T]},Object.defineProperty(this,"getDefaultVolumeStyle",{enumerable:!1}),this[T]},getDefaultBlendedVolumeStyle(){return this[P]=new V(this.getPrivateScene()),this[P].setPrivate(!0),this[P].setup(),this.getDefaultBlendedVolumeStyle=function(){return this[P]},Object.defineProperty(this,"getDefaultBlendedVolumeStyle",{enumerable:!1}),this[P]},getDefaultTransferFunction(){const e=new(a())(this.getPrivateScene());return e._boundaryModeS="CLAMP_TO_EDGE",e._boundaryModeT="REPEAT",e._magnificationFilter="DEFAULT",e._minificationFilter="DEFAULT",e._generateMipMaps=!0,e._textureCompression="DEFAULT",e.setPrivate(!0),e.setup(),this[E]=new(r())(this.getPrivateScene()),this[E]._textureProperties=e,this[E]._image.width=256,this[E]._image.height=1,this[E]._image.comp=2,this[E]._image.array=Array.from({length:256},((e,t)=>t<<8|t)),this[E].setPrivate(!0),this[E].setup(),this.getDefaultTransferFunction=function(){return this[E]},Object.defineProperty(this,"getDefaultTransferFunction",{enumerable:!1}),this[E]}});const M=j;y().add("X3DVolumeRenderingContext","x_ite/Browser/VolumeRendering/X3DVolumeRenderingContext",M);const z=M;function U(e){b.call(this,e),this.addType(g().BlendedVolumeStyle)}Object.assign(Object.setPrototypeOf(U.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._weightTransferFunction1.addInterest("set_weightTransferFunction1__",this),this._weightTransferFunction2.addInterest("set_weightTransferFunction2__",this),this._renderStyle.addInterest("set_renderStyle__",this),this._voxels.addInterest("set_voxels__",this),this.set_weightTransferFunction1__(),this.set_weightTransferFunction2__(),this.set_renderStyle__(),this.set_voxels__())},addVolumeData(e){b.prototype.addVolumeData.call(this,e),this.renderStyleNode&&this.renderStyleNode.addVolumeData(e)},removeVolumeData(e){b.prototype.removeVolumeData.call(this,e),this.renderStyleNode&&this.renderStyleNode.removeVolumeData(e)},set_weightTransferFunction1__(){this.weightTransferFunction1Node=F()(g().X3DTexture2DNode,this._weightTransferFunction1)},set_weightTransferFunction2__(){this.weightTransferFunction2Node=F()(g().X3DTexture2DNode,this._weightTransferFunction2)},set_renderStyle__(){if(this.renderStyleNode){this.renderStyleNode.removeInterest("addNodeEvent",this);for(const e of this.getVolumeData())this.renderStyleNode.removeVolumeData(e)}if(this.renderStyleNode=F()(g().X3DComposableVolumeRenderStyleNode,this._renderStyle),this.renderStyleNode){this.renderStyleNode.addInterest("addNodeEvent",this);for(const e of this.getVolumeData())this.renderStyleNode.addVolumeData(e)}},set_voxels__(){this.voxelsNode=F()(g().X3DTexture3DNode,this._voxels)},addShaderFields(e){this._enabled.getValue()&&(e.addUserDefinedField(g().inputOutput,"weightConstant1_"+this.getId(),this._weightConstant1.copy()),e.addUserDefinedField(g().inputOutput,"weightConstant2_"+this.getId(),this._weightConstant2.copy()),this.weightTransferFunction1Node&&e.addUserDefinedField(g().inputOutput,"weightTransferFunction1_"+this.getId(),new(l().SFNode)(this.weightTransferFunction1Node)),this.weightTransferFunction2Node&&e.addUserDefinedField(g().inputOutput,"weightTransferFunction2_"+this.getId(),new(l().SFNode)(this.weightTransferFunction2Node)),this.voxelsNode&&e.addUserDefinedField(g().inputOutput,"voxels_"+this.getId(),new(l().SFNode)(this.voxelsNode)),this.getBrowser().getDefaultBlendedVolumeStyle().addShaderFields(e),this.renderStyleNode&&this.renderStyleNode.addShaderFields(e))},getUniformsText(){if(!this._enabled.getValue())return"";if(!this.voxelsNode)return"";let e="";e+="\n",e+="// BlendedVolumeStyle\n",e+="\n",e+="uniform float     weightConstant1_"+this.getId()+";\n",e+="uniform float     weightConstant2_"+this.getId()+";\n",this.weightTransferFunction1Node&&(e+="uniform sampler2D weightTransferFunction1_"+this.getId()+";\n"),this.weightTransferFunction2Node&&(e+="uniform sampler2D weightTransferFunction2_"+this.getId()+";\n"),e+="uniform sampler3D voxels_"+this.getId()+";\n";let t=this.getBrowser().getDefaultBlendedVolumeStyle().getUniformsText();this.renderStyleNode&&(t+=this.renderStyleNode.getUniformsText()),t=t.replace(/x3d_Texture3D\s*\[0\]/g,"voxels_"+this.getId()),e+="\n",e+=t,e+="\n",e+="vec4\n",e+="getBlendedStyle_"+this.getId()+" (in vec4 originalColor, in vec3 texCoord)\n",e+="{\n",e+="   vec4 blendColor_"+this.getId()+" = texture (voxels_"+this.getId()+", texCoord);";let n=this.getBrowser().getDefaultBlendedVolumeStyle().getFunctionsText();switch(this.renderStyleNode&&(n+=this.renderStyleNode.getFunctionsText()),n=n.replace(/textureColor/g,"blendColor_"+this.getId()),e+="\n",e+=n,this._weightFunction1.getValue()){default:e+="   float w1_"+this.getId()+" = weightConstant1_"+this.getId()+";\n";break;case"ALPHA0":e+="   float w1_"+this.getId()+" = originalColor .a;\n";break;case"ALPHA1":e+="   float w1_"+this.getId()+" = blendColor_ "+this.getId()+" .a;\n";break;case"ONE_MINUS_ALPHA0":e+="   float w1_"+this.getId()+" = 1.0 - originalColor .a;\n";break;case"ONE_MINUS_ALPHA1":e+="   float w1_"+this.getId()+" = 1.0 - blendColor_ "+this.getId()+" .a;\n";break;case"TABLE":this.weightTransferFunction1Node?e+="   float w1_"+this.getId()+" = texture (weightTransferFunction1_"+this.getId()+", vec2 (originalColor .a, blendColor_"+this.getId()+" .a)) .r;\n":e+="   float w1_"+this.getId()+" = weightConstant1_"+this.getId()+";\n"}switch(this._weightFunction2.getValue()){default:e+="   float w2_"+this.getId()+" = weightConstant2_"+this.getId()+";\n";break;case"ALPHA0":e+="   float w2_"+this.getId()+" = originalColor .a;\n";break;case"ALPHA1":e+="   float w2_"+this.getId()+" = blendColor_ "+this.getId()+" .a;\n";break;case"ONE_MINUS_ALPHA0":e+="   float w2_"+this.getId()+" = 1.0 - originalColor .a;\n";break;case"ONE_MINUS_ALPHA1":e+="   float w2_"+this.getId()+" = 1.0 - blendColor_ "+this.getId()+" .a;\n";break;case"TABLE":this.weightTransferFunction2Node?e+="   float w2_"+this.getId()+" = texture (weightTransferFunction2_"+this.getId()+", vec2 (originalColor .a, blendColor_"+this.getId()+" .a)) .r;\n":e+="   float w2_"+this.getId()+" = weightConstant2_"+this.getId()+";\n"}return e+="\n",e+="   return clamp (originalColor * w1_"+this.getId()+" + blendColor_"+this.getId()+" * w2_"+this.getId()+", 0.0, 1.0);\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";if(!this.voxelsNode)return"";let e="";return e+="\n",e+="   // BlendedVolumeStyle\n",e+="\n",e+="   textureColor = getBlendedStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(U,{typeName:{value:"BlendedVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:3}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"weightConstant1",new(l().SFFloat)(.5)),new(u())(g().inputOutput,"weightConstant2",new(l().SFFloat)(.5)),new(u())(g().inputOutput,"weightFunction1",new(l().SFString)("CONSTANT")),new(u())(g().inputOutput,"weightFunction2",new(l().SFString)("CONSTANT")),new(u())(g().inputOutput,"weightTransferFunction1",new(l().SFNode)),new(u())(g().inputOutput,"weightTransferFunction2",new(l().SFNode)),new(u())(g().inputOutput,"renderStyle",new(l().SFNode)),new(u())(g().inputOutput,"voxels",new(l().SFNode))]),enumerable:!0}});const R=U;y().add("BlendedVolumeStyle","x_ite/Components/VolumeRendering/BlendedVolumeStyle",R);const B=R;function X(e){b.call(this,e),this.addType(g().BoundaryEnhancementVolumeStyle)}Object.assign(Object.setPrototypeOf(X.prototype,b.prototype),{addShaderFields(e){this._enabled.getValue()&&(e.addUserDefinedField(g().inputOutput,"retainedOpacity_"+this.getId(),this._retainedOpacity.copy()),e.addUserDefinedField(g().inputOutput,"boundaryOpacity_"+this.getId(),this._boundaryOpacity.copy()),e.addUserDefinedField(g().inputOutput,"opacityFactor_"+this.getId(),this._opacityFactor.copy()))},getUniformsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="// BoundaryEnhancementVolumeStyle\n",e+="\n",e+="uniform float retainedOpacity_"+this.getId()+";\n",e+="uniform float boundaryOpacity_"+this.getId()+";\n",e+="uniform float opacityFactor_"+this.getId()+";\n",e+="\n",e+="vec4\n",e+="getBoundaryEnhancementStyle_"+this.getId()+" (in vec4 originalColor, in vec3 texCoord)\n",e+="{\n",e+="   float f0 = texture (x3d_Texture3D [0], texCoord) .r;\n",e+="   float f1 = texture (x3d_Texture3D [0], texCoord + vec3 (0.0, 0.0, 1.0 / float (textureSize (x3d_Texture3D [0], 0) .z))) .r;\n",e+="   float f  = abs (f0 - f1);\n",e+="\n",e+="   float retainedOpacity = retainedOpacity_"+this.getId()+";\n",e+="   float boundaryOpacity = boundaryOpacity_"+this.getId()+";\n",e+="   float opacityFactor   = opacityFactor_"+this.getId()+";\n",e+="\n",e+="   return vec4 (originalColor .rgb, originalColor .a * (retainedOpacity + boundaryOpacity * pow (f, opacityFactor)));\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // BoundaryEnhancementVolumeStyle\n",e+="\n",e+="   textureColor = getBoundaryEnhancementStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(X,{typeName:{value:"BoundaryEnhancementVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:2}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"retainedOpacity",new(l().SFFloat)(.2)),new(u())(g().inputOutput,"boundaryOpacity",new(l().SFFloat)(.9)),new(u())(g().inputOutput,"opacityFactor",new(l().SFFloat)(2))]),enumerable:!0}});const L=X;y().add("BoundaryEnhancementVolumeStyle","x_ite/Components/VolumeRendering/BoundaryEnhancementVolumeStyle",L);const A=L;function G(e){b.call(this,e),this.addType(g().CartoonVolumeStyle)}Object.assign(Object.setPrototypeOf(G.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._surfaceNormals.addInterest("set_surfaceNormals__",this),this.set_surfaceNormals__())},set_surfaceNormals__(){this.surfaceNormalsNode=F()(g().X3DTexture3DNode,this._surfaceNormals)},addShaderFields(e){this._enabled.getValue()&&(e.addUserDefinedField(g().inputOutput,"colorSteps_"+this.getId(),this._colorSteps.copy()),e.addUserDefinedField(g().inputOutput,"orthogonalColor_"+this.getId(),this._orthogonalColor.copy()),e.addUserDefinedField(g().inputOutput,"parallelColor_"+this.getId(),this._parallelColor.copy()),this.surfaceNormalsNode&&e.addUserDefinedField(g().inputOutput,"surfaceNormals_"+this.getId(),new(l().SFNode)(this.surfaceNormalsNode)))},getUniformsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="// CartoonVolumeStyle\n",e+="\n",e+="uniform int  colorSteps_"+this.getId()+";\n",e+="uniform vec4 orthogonalColor_"+this.getId()+";\n",e+="uniform vec4 parallelColor_"+this.getId()+";\n",e+=this.getNormalText(this.surfaceNormalsNode),e+="\n",e+="vec3\n",e+="rgb2hsv_"+this.getId()+" (in vec3 color)\n",e+="{\n",e+="   float h = 0.0;\n",e+="   float s = 0.0;\n",e+="   float v = 0.0;\n",e+="\n",e+="   float min = min (min (color .r, color .g), color .b);\n",e+="   float max = max (max (color .r, color .g), color .b);\n",e+="   v = max; // value\n",e+="\n",e+="   float delta = max - min;\n",e+="\n",e+="   if (max != 0.0 && delta != 0.0)\n",e+="   {\n",e+="      s = delta / max; // s\n",e+="\n",e+="      if (color .r == max)\n",e+="         h =     (color .g - color .b) / delta;  // between yellow & magenta\n",e+="      else if (color .g == max)\n",e+="         h = 2.0 + (color .b - color .r) / delta;  // between cyan & yellow\n",e+="      else\n",e+="         h = 4.0 + (color .r - color .g) / delta;  // between magenta & cyan\n",e+="\n",e+="      h *= M_PI / 3.0;  // radiants\n",e+="      if (h < 0.0)\n",e+="         h += M_PI * 2.0;\n",e+="   }\n",e+="   else\n",e+="      s = h = 0.0;         // s = 0, h is undefined\n",e+="\n",e+="   return vec3 (h, s, v);\n",e+="}\n",e+="\n",e+="vec3\n",e+="hsv2rgb_"+this.getId()+" (in vec3 hsv)\n",e+="{\n",e+="   float h = hsv [0];\n",e+="   float s = clamp (hsv [1], 0.0, 1.0);\n",e+="   float v = clamp (hsv [2], 0.0, 1.0);\n",e+="\n",e+="   // H is given on [0, 2 * Pi]. S and V are given on [0, 1].\n",e+="   // RGB are each returned on [0, 1].\n",e+="\n",e+="   if (s == 0.0)\n",e+="   {\n",e+="      // achromatic (grey)\n",e+="      return vec3 (v, v, v);\n",e+="   }\n",e+="   else\n",e+="   {\n",e+="      float w = (h * (180.0 / M_PI)) / 60.0;     // sector 0 to 5\n",e+="\n",e+="      float i = floor (w);\n",e+="      float f = w - i;                      // factorial part of h\n",e+="      float p = v * ( 1.0 - s );\n",e+="      float q = v * ( 1.0 - s * f );\n",e+="      float t = v * ( 1.0 - s * ( 1.0 - f ) );\n",e+="\n",e+="      switch (int (i) % 6)\n",e+="      {\n",e+="         case 0:  return vec3 (v, t, p);\n",e+="         case 1:  return vec3 (q, v, p);\n",e+="         case 2:  return vec3 (p, v, t);\n",e+="         case 3:  return vec3 (p, q, v);\n",e+="         case 4:  return vec3 (t, p, v);\n",e+="         default: return vec3 (v, p, q);\n",e+="      }\n",e+="   }\n",e+="\n",e+="   return vec3 (0.0);\n",e+="}\n",e+="\n",e+="vec3\n",e+="mix_hsv_"+this.getId()+" (in vec3 a, in vec3 b, in float t)\n",e+="{\n",e+="   // Linearely interpolate in HSV space between source color @a a and destination color @a b by an amount of @a t.\n",e+="   // Source and destination color must be in HSV space.\n",e+="\n",e+="   float ha = a [0];\n",e+="   float sa = a [1];\n",e+="   float va = a [2];\n",e+="\n",e+="   float hb = b [0];\n",e+="   float sb = b [1];\n",e+="   float vb = b [2];\n",e+="\n",e+="   if (sa == 0.0)\n",e+="      ha = hb;\n",e+="\n",e+="   if (sb == 0.0)\n",e+="      hb = ha;\n",e+="\n",e+="   float range = abs (hb - ha);\n",e+="\n",e+="   if (range <= M_PI)\n",e+="   {\n",e+="      float h = ha + t * (hb - ha);\n",e+="      float s = sa + t * (sb - sa);\n",e+="      float v = va + t * (vb - va);\n",e+="      return vec3 (h, s, v);\n",e+="   }\n",e+="\n",e+="   float PI2  = M_PI * 2.0;\n",e+="   float step = (PI2 - range) * t;\n",e+="   float h    = ha < hb ? ha - step : ha + step;\n",e+="\n",e+="   if (h < 0.0)\n",e+="      h += PI2;\n",e+="\n",e+="   else if (h > PI2)\n",e+="      h -= PI2;\n",e+="\n",e+="   float s = sa + t * (sb - sa);\n",e+="   float v = va + t * (vb - va);\n",e+="   return vec3 (h, s, v);\n",e+="}\n",e+="\n",e+="vec4\n",e+="getCartoonStyle_"+this.getId()+" (in vec4 originalColor, vec3 texCoord)\n",e+="{\n",e+="   vec4 surfaceNormal = getNormal_"+this.getId()+" (texCoord);\n",e+="\n",e+="   if (surfaceNormal .w == 0.0)\n",e+="      return vec4 (0.0);\n",e+="\n",e+="   vec4 orthogonalColor = orthogonalColor_"+this.getId()+";\n",e+="   vec4 parallelColor   = parallelColor_"+this.getId()+";\n",e+="   int  colorSteps      = colorSteps_"+this.getId()+";\n",e+="\n",e+="   float steps    = clamp (float (colorSteps), 1.0, 64.0);\n",e+="   float step     = M_PI / 2.0 / steps;\n",e+="   float cosTheta = min (dot (surfaceNormal .xyz, normalize (vertex)), 1.0);\n",e+="\n",e+="   if (cosTheta < 0.0)\n",e+="      return vec4 (0.0);\n",e+="\n",e+="   float t             = cos (min (floor (acos (cosTheta) / step) * (steps > 1.0 ? steps / (steps - 1.0) : 1.0), steps) * step);\n",e+="   vec3  orthogonalHSV = rgb2hsv_"+this.getId()+" (orthogonalColor .rgb);\n",e+="   vec3  parallelHSV   = rgb2hsv_"+this.getId()+" (parallelColor .rgb);\n",e+="\n",e+="   return vec4 (hsv2rgb_"+this.getId()+" (mix_hsv_"+this.getId()+" (orthogonalHSV, parallelHSV, t)), originalColor .a);\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // CartoonVolumeStyle\n",e+="\n",e+="   textureColor = getCartoonStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(G,{typeName:{value:"CartoonVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:3}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"colorSteps",new(l().SFInt32)(4)),new(u())(g().inputOutput,"orthogonalColor",new(l().SFColorRGBA)(1,1,1,1)),new(u())(g().inputOutput,"parallelColor",new(l().SFColorRGBA)(0,0,0,1)),new(u())(g().inputOutput,"surfaceNormals",new(l().SFNode))]),enumerable:!0}});const q=G;y().add("CartoonVolumeStyle","x_ite/Components/VolumeRendering/CartoonVolumeStyle",q);const H=q;function k(e){b.call(this,e),this.addType(g().ComposedVolumeStyle),this.renderStyleNodes=[]}Object.assign(Object.setPrototypeOf(k.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._renderStyle.addInterest("set_renderStyle__",this),this.set_renderStyle__())},addVolumeData(e){b.prototype.addVolumeData.call(this,e);for(const t of this.renderStyleNodes)t.addVolumeData(e)},removeVolumeData(e){b.prototype.removeVolumeData.call(this,e);for(const t of this.renderStyleNodes)t.removeVolumeData(e)},set_renderStyle__(){const e=this.renderStyleNodes;for(const t of e){t.removeInterest("addNodeEvent",this);for(const e of this.getVolumeData())t.removeVolumeData(e)}e.length=0;for(const t of this._renderStyle){const n=F()(g().X3DComposableVolumeRenderStyleNode,t);n&&e.push(n)}for(const t of e){t.addInterest("addNodeEvent",this);for(const e of this.getVolumeData())t.addVolumeData(e)}},addShaderFields(e){if(this._enabled.getValue())for(const t of this.renderStyleNodes)t.addShaderFields(e)},getUniformsText(){if(!this._enabled.getValue())return"";let e="";for(const t of this.renderStyleNodes)e+=t.getUniformsText();e+="\n",e+="vec4\n",e+="getComposedStyle_"+this.getId()+" (in vec4 textureColor, in vec3 texCoord)\n",e+="{\n";for(const t of this.renderStyleNodes)e+=t.getFunctionsText();return e+="\n",e+="   return textureColor;\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // ComposedVolumeStyle\n",e+="\n",e+="   textureColor = getComposedStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(k,{typeName:{value:"ComposedVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:3}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"renderStyle",new(l().MFNode))]),enumerable:!0}});const Y=k;y().add("ComposedVolumeStyle","x_ite/Components/VolumeRendering/ComposedVolumeStyle",Y);const W=Y;function Q(e){b.call(this,e),this.addType(g().EdgeEnhancementVolumeStyle)}Object.assign(Object.setPrototypeOf(Q.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._surfaceNormals.addInterest("set_surfaceNormals__",this),this.set_surfaceNormals__())},set_surfaceNormals__(){this.surfaceNormalsNode=F()(g().X3DTexture3DNode,this._surfaceNormals)},addShaderFields(e){this._enabled.getValue()&&(e.addUserDefinedField(g().inputOutput,"edgeColor_"+this.getId(),this._edgeColor.copy()),e.addUserDefinedField(g().inputOutput,"gradientThreshold_"+this.getId(),this._gradientThreshold.copy()),this.surfaceNormalsNode&&e.addUserDefinedField(g().inputOutput,"surfaceNormals_"+this.getId(),new(l().SFNode)(this.surfaceNormalsNode)))},getUniformsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="// EdgeEnhancementVolumeStyle\n",e+="\n",e+="uniform vec4  edgeColor_"+this.getId()+";\n",e+="uniform float gradientThreshold_"+this.getId()+";\n",e+=this.getNormalText(this.surfaceNormalsNode),e+="\n",e+="vec4\n",e+="getEdgeEnhacementStyle_"+this.getId()+" (in vec4 originalColor, in vec3 texCoord)\n",e+="{\n",e+="   vec4 surfaceNormal = getNormal_"+this.getId()+" (texCoord);\n",e+="\n",e+="   if (surfaceNormal .w == 0.0)\n",e+="      return vec4 (0.0);\n",e+="\n",e+="   vec4  edgeColor         = edgeColor_"+this.getId()+";\n",e+="   float gradientThreshold = gradientThreshold_"+this.getId()+";\n",e+="\n",e+="   float angle = abs (dot (surfaceNormal .xyz, normalize (vertex)));\n",e+="\n",e+="   if (angle >= cos (gradientThreshold))\n",e+="      return originalColor;\n",e+="   else\n",e+="      return vec4 (mix (edgeColor .rgb, originalColor.rgb, angle), originalColor .a);\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // EdgeEnhancementVolumeStyle\n",e+="\n",e+="   textureColor = getEdgeEnhacementStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(Q,{typeName:{value:"EdgeEnhancementVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:2}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"edgeColor",new(l().SFColorRGBA)(0,0,0,1)),new(u())(g().inputOutput,"gradientThreshold",new(l().SFFloat)(.4)),new(u())(g().inputOutput,"surfaceNormals",new(l().SFNode))]),enumerable:!0}});const K=Q;y().add("EdgeEnhancementVolumeStyle","x_ite/Components/VolumeRendering/EdgeEnhancementVolumeStyle",K);const $=K,Z=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Core/X3DChildNode");var J=e.n(Z);const ee=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Grouping/X3DBoundedObject");var te=e.n(ee);const ne=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Browser/Core/TextureQuality");var oe=e.n(ne);const re=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Shape/UnlitMaterial");var ie=e.n(re);const ae="#version 300 es\nprecision highp float;precision highp int;uniform mat4 x3d_ProjectionMatrix;uniform mat4 x3d_ModelViewMatrix;uniform mat4 x3d_TextureMatrix[1];in vec4 x3d_TexCoord0;in vec4 x3d_Vertex;out vec3 vertex;out vec4 texCoord;void main(){vec4 position=x3d_ModelViewMatrix*x3d_Vertex;vertex=position.xyz;texCoord=x3d_TextureMatrix[0]*x3d_TexCoord0;gl_Position=x3d_ProjectionMatrix*position;}";y().add("VolumeStyle.vs","x_ite/Browser/VolumeRendering/VolumeStyle.vs",ae);const se=ae,le='#version 300 es\nprecision highp float;precision highp int;precision highp sampler3D;in vec3 vertex;in vec4 texCoord;uniform sampler3D x3d_Texture3D[1];uniform mat3 x3d_TextureNormalMatrix;uniform x3d_LightSourceParameters x3d_LightSource[x3d_MaxLights];const float M_PI=3.14159265359;\n#pragma X3D include "includes/ClipPlanes.glsl"\n#pragma X3D include "includes/Fog.glsl"\n__VOLUME_STYLES_UNIFORMS__ out vec4 x3d_FragColor;vec4 getTextureColor(in vec3 texCoord){if(any(greaterThan(abs(texCoord-0.5),vec3(0.5))))discard;vec4 textureColor=texture(x3d_Texture3D[0],texCoord);__VOLUME_STYLES_FUNCTIONS__ return textureColor;}void main(){\n#if defined(X3D_CLIP_PLANES)\nclip();\n#endif\nvec4 finalColor=getTextureColor(texCoord.stp/texCoord.q);\n#if defined(X3D_FOG)\nfinalColor.rgb=getFogColor(finalColor.rgb);\n#endif\nx3d_FragColor=finalColor;}';y().add("VolumeStyle.fs","x_ite/Browser/VolumeRendering/VolumeStyle.fs",le);const de=le;function ue(e,t){ie().call(this,e),this.volumeDataNode=t,this.volumeShaderNodes=new Map}Object.assign(Object.setPrototypeOf(ue.prototype,ie().prototype),{getVolumeShaders(){return this.volumeShaderNodes},getShader(e,t){const{fogNode:n,objectsKeys:o}=t;let r="";return r+=n?.getFogType()??0,r+=".",r+=o.sort().join(""),this.volumeShaderNodes.get(r)??this.createShader(r,e,t)},createShader(e,t,n){const o=this.getBrowser(),r=[],{fogNode:i,objectsKeys:a}=n;switch(i?.getFogType()){case 1:r.push("X3D_FOG","X3D_FOG_LINEAR");break;case 2:r.push("X3D_FOG","X3D_FOG_EXPONENTIAL")}const s=a.reduce(((e,t)=>e+(0===t)),0),l=a.reduce(((e,t)=>e+(1===t)),0);a.reduce(((e,t)=>e+(2===t)),0),a.reduce(((e,t)=>e+(3===t)),0);s&&(r.push("X3D_CLIP_PLANES"),r.push(`X3D_NUM_CLIP_PLANES ${Math.min(s,o.getMaxClipPlanes())}`)),l&&(r.push("X3D_LIGHTING"),r.push(`X3D_NUM_LIGHTS ${Math.min(l,o.getMaxLights())}`));const d=this.volumeDataNode.createShader(r,se,de);return this.volumeShaderNodes.set(e,d),d},setShaderUniforms(e,t,n,o,r){this.volumeDataNode.setShaderUniforms(e,t)}}),Object.defineProperties(ue,{typeName:{value:"VolumeMaterial",enumerable:!0},componentInfo:{value:Object.freeze({name:"Shape",level:1}),enumerable:!0},containerField:{value:"material",enumerable:!0},fieldDefinitions:{value:ie().fieldDefinitions}});const he=ue;y().add("VolumeMaterial","x_ite/Browser/VolumeRendering/VolumeMaterial",he);const ce=he,me=window[Symbol.for("X_ITE.X3D-9.1.6")].require("standard/Math/Numbers/Vector3");var pe=e.n(me);const fe=window[Symbol.for("X_ITE.X3D-9.1.6")].require("standard/Math/Numbers/Matrix4");var ge=e.n(fe);function _e(e){J().call(this,e),te().call(this,e),this.addType(g().X3DVolumeDataNode);const t=this.getBrowser();this.proximitySensorNode=t.getPrivateScene().createNode("ProximitySensor",!1),this.transformNode=t.getPrivateScene().createNode("Transform",!1),this.shapeNode=t.getPrivateScene().createNode("Shape",!1),this.appearanceNode=t.getPrivateScene().createNode("Appearance",!1),this.textureTransformNode=t.getPrivateScene().createNode("TextureTransform3D",!1),this.geometryNode=t.getPrivateScene().createNode("QuadSet",!1),this.textureCoordinateNode=t.getPrivateScene().createNode("TextureCoordinate3D",!1),this.coordinateNode=t.getPrivateScene().createNode("Coordinate",!1),this.volumeMaterialNode=new ce(t.getPrivateScene(),this),this.textureNormalMatrixArray=new Float32Array(9),this.setCameraObject(!0)}Object.assign(Object.setPrototypeOf(_e.prototype,J().prototype),te().prototype,{initialize(){J().prototype.initialize.call(this),te().prototype.initialize.call(this);const e=this.getBrowser(),t=e.getContext();e.getBrowserOptions()._TextureQuality.addInterest("set_dimensions__",this),t.getVersion()>=2&&(this._dimensions.addInterest("set_dimensions__",this),this.set_dimensions__()),this._bboxDisplay.addFieldInterest(this.transformNode._bboxDisplay),this.proximitySensorNode._size=new(l().SFVec3f)(-1,-1,-1),this.transformNode._children=new(l().MFNode)(this.shapeNode),this.shapeNode._appearance=this.appearanceNode,this.shapeNode._geometry=this.geometryNode,this.appearanceNode._alphaMode="BLEND",this.appearanceNode._material=this.volumeMaterialNode,this.appearanceNode._textureTransform=this.textureTransformNode,this.textureTransformNode._translation=new(l().SFVec3f)(.5,.5,.5),this.textureTransformNode._center=new(l().SFVec3f)(-.5,-.5,-.5),this.geometryNode._texCoord=this.textureCoordinateNode,this.geometryNode._coord=this.coordinateNode,this.coordinateNode.setPrivate(!0),this.textureCoordinateNode.setPrivate(!0),this.geometryNode.setPrivate(!0),this.textureTransformNode.setPrivate(!0),this.volumeMaterialNode.setPrivate(!0),this.appearanceNode.setPrivate(!0),this.shapeNode.setPrivate(!0),this.transformNode.setPrivate(!0),this.proximitySensorNode.setPrivate(!0),this.coordinateNode.setup(),this.textureCoordinateNode.setup(),this.geometryNode.setup(),this.textureTransformNode.setup(),this.volumeMaterialNode.setup(),this.appearanceNode.setup(),this.shapeNode.setup(),this.transformNode.setup(),this.proximitySensorNode.setup(),this.proximitySensorNode._orientation_changed.addFieldInterest(this.transformNode._rotation),this.proximitySensorNode._orientation_changed.addFieldInterest(this.textureTransformNode._rotation),this.textureTransformNode.addInterest("set_textureTransform__",this),this.set_textureTransform__()},getBBox(e,t){return this._bboxSize.getValue().equals(this.getDefaultBBoxSize())?e.set(this._dimensions.getValue(),pe().Zero):e.set(this._bboxSize.getValue(),this._bboxCenter.getValue())},getAppearance(){return this.appearanceNode},updateShader(){this.volumeMaterialNode.getVolumeShaders().clear()},addShaderUniformNames(e){e.push("x3d_TextureNormalMatrix")},getNumPlanes(){switch(this.getBrowser().getBrowserOptions().getTextureQuality()){case oe().LOW:return 200;case oe().MEDIUM:return 400;case oe().HIGH:return 600}return 200},set_dimensions__(){const e=this.getNumPlanes(),t=this._dimensions.getValue().magnitude(),n=t/2,o=[];this.coordinateNode._point.length=0;for(let r=0;r<e;++r){const i=r/(e-1)-.5;o.push(n,n,t*i,-n,n,t*i,-n,-n,t*i,n,-n,t*i)}this.coordinateNode._point=o,this.textureCoordinateNode._point=o,this.textureTransformNode._scale=new(l().SFVec3f)(1/this._dimensions.x,1/this._dimensions.y,1/this._dimensions.z)},set_textureTransform__(){this.textureNormalMatrixArray.set(new(ge())(...this.textureTransformNode.getMatrix()).submatrix.inverse())},traverse(e,t){this.proximitySensorNode.traverse(e,t),this.transformNode.traverse(e,t)},setShaderUniforms(e,t){e.uniformMatrix3fv(t.x3d_TextureNormalMatrix,!0,this.textureNormalMatrixArray)},dispose(){te().prototype.dispose.call(this),J().prototype.dispose.call(this)}}),Object.defineProperties(_e,{typeName:{value:"X3DVolumeDataNode",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:1}),enumerable:!0}});const ye=_e;y().add("X3DVolumeDataNode","x_ite/Components/VolumeRendering/X3DVolumeDataNode",ye);const Se=ye,xe=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Shaders/ComposedShader");var Ne=e.n(xe);const ve=window[Symbol.for("X_ITE.X3D-9.1.6")].require("x_ite/Components/Shaders/ShaderPart");var we=e.n(ve);function be(e){Se.call(this,e),this.addType(g().IsoSurfaceVolumeData),this.renderStyleNodes=[]}Object.assign(Object.setPrototypeOf(be.prototype,Se.prototype),{initialize(){Se.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._gradients.addInterest("set_gradients__",this),this._renderStyle.addInterest("set_renderStyle__",this),this._contourStepSize.addInterest("updateShader",this),this._surfaceValues.addInterest("updateShader",this),this._surfaceTolerance.addInterest("updateShader",this),this._renderStyle.addInterest("updateShader",this),this.set_gradients__(),this.set_renderStyle__(),this.set_voxels__(),this.updateShader())},set_gradients__(){this.gradientsNode=F()(g().X3DTexture3DNode,this._gradients)},set_renderStyle__(){const e=this.renderStyleNodes;for(const t of e)t.removeInterest("updateShader",this),t.removeVolumeData(this);e.length=0;for(const t of this._renderStyle){const n=F()(g().X3DComposableVolumeRenderStyleNode,t);n&&e.push(n)}for(const t of e)t.addInterest("updateShader",this),t.addVolumeData(this)},set_voxels__(){this.voxelsNode=F()(g().X3DTexture3DNode,this._voxels),this.voxelsNode?this.getAppearance()._texture=this._voxels:this.getAppearance()._texture=this.getBrowser().getDefaultVoxels()},createShader(e,t,n){const o=this.getBrowser().getDefaultVolumeStyle();let r=o.getUniformsText(),i=o.getFunctionsText();r+="\n",r+="uniform float surfaceValues ["+this._surfaceValues.length+"];\n",r+="uniform float surfaceTolerance;\n";for(const e of this.renderStyleNodes)r+=e.getUniformsText();if(i+="\n",i+="   // IsoSurfaceVolumeData\n",i+="\n",this.gradientsNode?(r+="\n",r+="uniform sampler3D gradients;\n",i+="   if (length (texture (gradients, texCoord) .xyz * 2.0 - 1.0) < surfaceTolerance)\n",i+="      discard;\n"):(r+="\n",r+="vec4\n",r+="getNormal (in vec3 texCoord)\n",r+="{\n",r+="   vec4  offset = vec4 (1.0 / vec3 (textureSize (x3d_Texture3D [0], 0)), 0.0);\n",r+="   float i0     = texture (x3d_Texture3D [0], texCoord + offset .xww) .r;\n",r+="   float i1     = texture (x3d_Texture3D [0], texCoord - offset .xww) .r;\n",r+="   float i2     = texture (x3d_Texture3D [0], texCoord + offset .wyw) .r;\n",r+="   float i3     = texture (x3d_Texture3D [0], texCoord - offset .wyw) .r;\n",r+="   float i4     = texture (x3d_Texture3D [0], texCoord + offset .wwz) .r;\n",r+="   float i5     = texture (x3d_Texture3D [0], texCoord - offset .wwz) .r;\n",r+="   vec3  n      = vec3 (i1 - i0, i3 - i2, i5 - i4);\n",r+="\n",r+="   return vec4 (normalize (x3d_TextureNormalMatrix * n), length (n));\n",r+="}\n",i+="   if (getNormal (texCoord) .w < surfaceTolerance)\n",i+="      discard;\n"),i+="\n",i+="   float intensity = textureColor .r;\n",i+="\n",1===this._surfaceValues.length){const e=Math.abs(this._contourStepSize.getValue());if(0===e)i+="   if (intensity > surfaceValues [0])\n",i+="   {\n",i+="      textureColor = vec4 (vec3 (surfaceValues [0]), 1.0);\n",this.renderStyleNodes.length&&(i+=this.renderStyleNodes[0].getFunctionsText()),i+="   }\n",i+="   else\n",i+="   {\n",i+="      discard;\n",i+="   }\n",i+="\n";else{const t=[];for(let n=this._surfaceValues[0]-e;n>0;n-=e)t.unshift(n);t.push(this._surfaceValues[0]);for(let n=this._surfaceValues[0]+e;n<1;n+=e)t.push(n);i+="   if (false)\n",i+="   { }\n";for(let e=this._surfaceValues.length-1;e>=0;--e)i+="   else if (intensity > "+t[e]+")\n",i+="   {\n",i+="      textureColor = vec4 (vec3 ("+t[e]+"), 1.0);\n",this.renderStyleNodes.length&&(i+=this.renderStyleNodes[0].getFunctionsText()),i+="   }\n";i+="   else\n",i+="   {\n",i+="      discard;\n",i+="   }\n",i+="\n"}}else{i+="   if (false)\n",i+="   { }\n";for(let e=this._surfaceValues.length-1;e>=0;--e){if(i+="   else if (intensity > surfaceValues ["+e+"])\n",i+="   {\n",i+="      textureColor = vec4 (vec3 (surfaceValues ["+e+"]), 1.0);\n",this.renderStyleNodes.length){const t=Math.min(e,this.renderStyleNodes.length-1);i+=this.renderStyleNodes[t].getFunctionsText()}i+="   }\n"}i+="   else\n",i+="   {\n",i+="      discard;\n",i+="   }\n",i+="\n"}n=n.replace(/__VOLUME_STYLES_UNIFORMS__/,r).replace(/__VOLUME_STYLES_FUNCTIONS__/,i);const a=new(we())(this.getExecutionContext());a._url.push(encodeURI("data:x-shader/x-vertex,"+t)),a.setPrivate(!0),a.setName("VolumeDataVertexShader"),a.setOptions(e),a.setup();const s=new(we())(this.getExecutionContext());s._type="FRAGMENT",s._url.push(encodeURI("data:x-shader/x-fragment,"+n)),s.setPrivate(!0),s.setName("VolumeDataFragmentShader"),s.setOptions(e),s.setup();const d=new(Ne())(this.getExecutionContext());d._language="GLSL",d._parts.push(a),d._parts.push(s),d.setPrivate(!0),d.setName("VolumeDataShader"),d.addUserDefinedField(g().inputOutput,"surfaceValues",this._surfaceValues.copy()),d.addUserDefinedField(g().inputOutput,"surfaceTolerance",this._surfaceTolerance.copy()),this.gradientsNode&&d.addUserDefinedField(g().inputOutput,"gradients",new(l().SFNode)(this.gradientsNode)),o.addShaderFields(d);for(const e of this.renderStyleNodes)e.addShaderFields(d);const u=[];return this.addShaderUniformNames(u),d.setUniformNames(u),d.setup(),d}}),Object.defineProperties(be,{typeName:{value:"IsoSurfaceVolumeData",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:2}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"dimensions",new(l().SFVec3f)(1,1,1)),new(u())(g().inputOutput,"contourStepSize",new(l().SFFloat)(0)),new(u())(g().inputOutput,"surfaceValues",new(l().MFFloat)),new(u())(g().inputOutput,"surfaceTolerance",new(l().SFFloat)(0)),new(u())(g().inputOutput,"visible",new(l().SFBool)(!0)),new(u())(g().inputOutput,"bboxDisplay",new(l().SFBool)),new(u())(g().initializeOnly,"bboxSize",new(l().SFVec3f)(-1,-1,-1)),new(u())(g().initializeOnly,"bboxCenter",new(l().SFVec3f)(0,0,0)),new(u())(g().inputOutput,"renderStyle",new(l().MFNode)),new(u())(g().inputOutput,"gradients",new(l().SFNode)),new(u())(g().inputOutput,"voxels",new(l().SFNode))]),enumerable:!0}});const Ce=be;y().add("IsoSurfaceVolumeData","x_ite/Components/VolumeRendering/IsoSurfaceVolumeData",Ce);const Fe=Ce;function Ie(e){N.call(this,e),this.addType(g().ProjectionVolumeStyle)}Object.assign(Object.setPrototypeOf(Ie.prototype,N.prototype),{addShaderFields(e){this._enabled.getValue()&&e.addUserDefinedField(g().inputOutput,"intensityThreshold_"+this.getId(),this._intensityThreshold.copy())},getUniformsText(){if(!this._enabled.getValue())return"";let e="";switch(e+="\n",e+="// ProjectionVolumeStyle\n",e+="\n",e+="uniform float intensityThreshold_"+this.getId()+";\n",e+="\n",e+="vec4\n",e+="getProjectionStyle_"+this.getId()+"(in vec4 originalColor, in vec3 texCoord)\n",e+="{\n",this._type.getValue()){default:case"MAX":case"AVERAGE":e+="   float projectionColor = 0.0;\n";break;case"MIN":e+="   float projectionColor = 1.0;\n"}switch(e+="   const int samples     = 32;\n",e+="   vec3  step            = normalize (x3d_TextureNormalMatrix * vec3 (0.0, 0.0, 1.0)) / float (samples);\n",e+="   vec3  ray             = texCoord - step * float (samples) * 0.5;\n",e+="   bool  first           = false;\n",e+="\n",e+="   for (int i = 0; i < samples; ++ i, ray += step)\n",e+="   {\n",e+="      if (ray .s < 0.0 || ray .s > 1.0)\n",e+="         continue;\n",e+="\n",e+="      if (ray .t < 0.0 || ray .t > 1.0)\n",e+="         continue;\n",e+="\n",e+="      if (ray .p < 0.0 || ray .p > 1.0)\n",e+="         continue;\n",e+="\n",e+="      float intensity = texture (x3d_Texture3D [0], ray) .r;\n",e+="\n",this._type.getValue()){default:case"MAX":e+="      if (intensity < intensityThreshold_"+this.getId()+")\n",e+="         continue;\n",e+="\n",e+="      if (intensityThreshold_"+this.getId()+" > 0.0 && first)\n",e+="         break;\n",e+="\n",e+="      if (intensity <= projectionColor)\n",e+="      {\n",e+="         first = true;\n",e+="         continue;\n",e+="      }\n",e+="\n",e+="      projectionColor = intensity;\n";break;case"MIN":e+="      if (intensity < intensityThreshold_"+this.getId()+")\n",e+="         continue;\n",e+="\n",e+="      if (intensityThreshold_"+this.getId()+" > 0.0 && first)\n",e+="         break;\n",e+="\n",e+="      if (intensity >= projectionColor)\n",e+="      {\n",e+="         first = true;\n",e+="         continue;\n",e+="      }\n",e+="\n",e+="      projectionColor = intensity;\n";break;case"AVERAGE":e+="      projectionColor += intensity;\n"}return e+="   }\n",e+="\n","AVERAGE"===this._type.getValue()&&(e+="   projectionColor /= float (samples);\n"),e+="   return vec4 (vec3 (projectionColor), originalColor .a);\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // ProjectionVolumeStyle\n",e+="\n",e+="   textureColor = getProjectionStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(Ie,{typeName:{value:"ProjectionVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:2}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"type",new(l().SFString)("MAX")),new(u())(g().inputOutput,"intensityThreshold",new(l().SFFloat)(0))]),enumerable:!0}});const Oe=Ie;y().add("ProjectionVolumeStyle","x_ite/Components/VolumeRendering/ProjectionVolumeStyle",Oe);const Ve=Oe;function De(e){Se.call(this,e),this.addType(g().SegmentedVolumeData),this.segmentIdentifiersNode=null,this.renderStyleNodes=[]}Object.assign(Object.setPrototypeOf(De.prototype,Se.prototype),{initialize(){Se.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._segmentIdentifiers.addInterest("set_segmentIdentifiers__",this),this._renderStyle.addInterest("set_renderStyle__",this),this._segmentEnabled.addInterest("updateShader",this),this._segmentIdentifiers.addInterest("updateShader",this),this._renderStyle.addInterest("updateShader",this),this.set_segmentIdentifiers__(),this.set_renderStyle__(),this.set_voxels__(),this.updateShader())},getSegmentEnabled(e){return!(e<this._segmentEnabled.length)||this._segmentEnabled[e]},set_segmentIdentifiers__(){this.segmentIdentifiersNode=F()(g().X3DTexture3DNode,this._segmentIdentifiers)},set_renderStyle__(){const e=this.renderStyleNodes;for(const t of e)t.removeInterest("updateShader",this),t.removeVolumeData(this);e.length=0;for(const t of this._renderStyle){const n=F()(g().X3DComposableVolumeRenderStyleNode,t);n&&e.push(n)}for(const t of e)t.addInterest("updateShader",this),t.addVolumeData(this)},set_voxels__(){this.voxelsNode=F()(g().X3DTexture3DNode,this._voxels),this.voxelsNode?this.getAppearance()._texture=this._voxels:this.getAppearance()._texture=this.getBrowser().getDefaultVoxels()},createShader(e,t,n){const o=this.getBrowser().getDefaultVolumeStyle();let r=o.getUniformsText(),i=o.getFunctionsText();if(this.segmentIdentifiersNode?(r+="\n",r+="uniform sampler3D segmentIdentifiers;\n",r+="\n",i+="\n",i+="   int segment = int (texture (segmentIdentifiers, texCoord) .r * 255.0);\n"):i+="   int segment = 0;\n",this.renderStyleNodes.length){i+="\n",i+="   switch (segment)\n",i+="   {\n";for(const[e,t]of this.renderStyleNodes.entries())i+="      case "+e+":\n",i+="      {\n",this.getSegmentEnabled(e)?(r+=t.getUniformsText(),i+=t.getFunctionsText(),i+="         break;\n"):i+="         discard;\n",i+="      }\n";i+="   }\n"}n=n.replace(/__VOLUME_STYLES_UNIFORMS__/,r).replace(/__VOLUME_STYLES_FUNCTIONS__/,i);const a=new(we())(this.getExecutionContext());a._url.push(encodeURI("data:x-shader/x-vertex,"+t)),a.setPrivate(!0),a.setName("SegmentedVolumeDataVertexShader"),a.setOptions(e),a.setup();const s=new(we())(this.getExecutionContext());s._type="FRAGMENT",s._url.push(encodeURI("data:x-shader/x-fragment,"+n)),s.setPrivate(!0),s.setName("SegmentedVolumeDataFragmentShader"),s.setOptions(e),s.setup();const d=new(Ne())(this.getExecutionContext());d._language="GLSL",d._parts.push(a),d._parts.push(s),d.setPrivate(!0),d.setName("SegmentedVolumeDataShader"),this.segmentIdentifiersNode&&d.addUserDefinedField(g().inputOutput,"segmentIdentifiers",new(l().SFNode)(this.segmentIdentifiersNode)),o.addShaderFields(d);for(const[e,t]of this.renderStyleNodes.entries())this.getSegmentEnabled(e)&&t.addShaderFields(d);const u=[];return this.addShaderUniformNames(u),d.setUniformNames(u),d.setup(),d}}),Object.defineProperties(De,{typeName:{value:"SegmentedVolumeData",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:2}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"dimensions",new(l().SFVec3f)(1,1,1)),new(u())(g().inputOutput,"segmentEnabled",new(l().MFBool)),new(u())(g().inputOutput,"visible",new(l().SFBool)(!0)),new(u())(g().inputOutput,"bboxDisplay",new(l().SFBool)),new(u())(g().initializeOnly,"bboxSize",new(l().SFVec3f)(-1,-1,-1)),new(u())(g().initializeOnly,"bboxCenter",new(l().SFVec3f)(0,0,0)),new(u())(g().inputOutput,"segmentIdentifiers",new(l().SFNode)),new(u())(g().inputOutput,"renderStyle",new(l().MFNode)),new(u())(g().inputOutput,"voxels",new(l().SFNode))]),enumerable:!0}});const Te=De;y().add("SegmentedVolumeData","x_ite/Components/VolumeRendering/SegmentedVolumeData",Te);const Pe=Te;function Ee(e){b.call(this,e),this.addType(g().ShadedVolumeStyle)}Object.assign(Object.setPrototypeOf(Ee.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._material.addInterest("set_material__",this),this._surfaceNormals.addInterest("set_surfaceNormals__",this),this.set_material__(),this.set_surfaceNormals__())},set_material__(){this.materialNode&&this.materialNode.removeInterest("addNodeEvent",this),this.materialNode=F()(g().X3DMaterialNode,this._material),this.materialNode&&this.materialNode.addInterest("addNodeEvent",this)},set_surfaceNormals__(){this.surfaceNormalsNode=F()(g().X3DTexture3DNode,this._surfaceNormals)},addShaderFields(e){this._enabled.getValue()&&(this.materialNode&&(e.addUserDefinedField(g().inputOutput,"ambientIntensity_"+this.getId(),this.materialNode._ambientIntensity.copy()),e.addUserDefinedField(g().inputOutput,"diffuseColor_"+this.getId(),this.materialNode._diffuseColor.copy()),e.addUserDefinedField(g().inputOutput,"specularColor_"+this.getId(),this.materialNode._specularColor.copy()),e.addUserDefinedField(g().inputOutput,"emissiveColor_"+this.getId(),this.materialNode._emissiveColor.copy()),e.addUserDefinedField(g().inputOutput,"shininess_"+this.getId(),this.materialNode._shininess.copy()),e.addUserDefinedField(g().inputOutput,"transparency_"+this.getId(),this.materialNode._transparency.copy())),this.surfaceNormalsNode&&e.addUserDefinedField(g().inputOutput,"surfaceNormals_"+this.getId(),new(l().SFNode)(this.surfaceNormalsNode)))},getUniformsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="// ShadedVolumeStyle\n",e+="\n",e+="uniform float ambientIntensity_"+this.getId()+";\n",e+="uniform vec3  diffuseColor_"+this.getId()+";\n",e+="uniform vec3  specularColor_"+this.getId()+";\n",e+="uniform vec3  emissiveColor_"+this.getId()+";\n",e+="uniform float shininess_"+this.getId()+";\n",e+="uniform float transparency_"+this.getId()+";\n",e+=this.getNormalText(this.surfaceNormalsNode),e+="\n",e+="float\n",e+="getSpotFactor_"+this.getId()+" (const in float cutOffAngle, const in float beamWidth, const in vec3 L, const in vec3 d)\n",e+="{\n",e+="   float spotAngle = acos (clamp (dot (-L, d), -1.0, 1.0));\n",e+="\n",e+="   if (spotAngle >= cutOffAngle)\n",e+="      return 0.0;\n",e+="   else if (spotAngle <= beamWidth)\n",e+="      return 1.0;\n",e+="\n",e+="   return (spotAngle - cutOffAngle) / (beamWidth - cutOffAngle);\n",e+="}\n",e+="\n",e+="vec4\n",e+="getShadedStyle_"+this.getId()+" (in vec4 originalColor, in vec3 texCoord)\n",e+="{\n",e+="   vec4 surfaceNormal = getNormal_"+this.getId()+" (texCoord);\n",e+="\n",e+="   if (surfaceNormal .w == 0.0)\n",e+="      return vec4 (0.0);\n",e+="\n",e+="   vec4 shadedColor   = vec4 (0.0);\n",this._lighting.getValue()?(this.materialNode?(e+="   vec3 diffuseFactor = diffuseColor_"+this.getId()+";\n",e+="   vec3 ambientTerm   = diffuseFactor * ambientIntensity_"+this.getId()+";\n",e+="\n",e+="   shadedColor .a = originalColor .a * (1.0 - transparency_"+this.getId()+");\n"):(e+="   vec3 diffuseFactor = originalColor .rgb;\n",e+="   vec3 ambientTerm   = vec3 (0.0);\n",e+="\n",e+="   shadedColor .a = originalColor .a;\n"),e+="\n",e+="   vec3 N = surfaceNormal .xyz;\n",e+="   vec3 V = normalize (-vertex); // normalized vector from point on geometry to viewer's position\n",e+="\n",e+="   for (int i = 0; i < X3D_NUM_LIGHTS; ++ i)\n",e+="   {\n",e+="      x3d_LightSourceParameters light = x3d_LightSource [i];\n",e+="\n",e+="      vec3  vL = light .location - vertex; // Light to fragment\n",e+="      float dL = length (light .matrix * vL);\n",e+="      bool  di = light .type == x3d_DirectionalLight;\n",e+="\n",e+="      if (di || dL <= light .radius)\n",e+="      {\n",e+="         vec3 d = light .direction;\n",e+="         vec3 c = light .attenuation;\n",e+="         vec3 L = di ? -d : normalize (vL);      // Normalized vector from point on geometry to light source i position.\n",e+="         vec3 H = normalize (L + V);             // Specular term\n",e+="\n",e+="         float lightAngle     = max (dot (N, L), 0.0);      // Angle between normal and light ray.\n",e+="         vec3  diffuseTerm    = diffuseFactor * lightAngle;\n",e+="         float specularFactor = shininess_"+this.getId()+" > 0.0 ? pow (max (dot (N, H), 0.0), shininess_"+this.getId()+" * 128.0) : 1.0;\n",e+="         vec3  specularTerm   = light .intensity * specularColor_"+this.getId()+" * specularFactor;\n",e+="\n",e+="         float attenuationFactor     = di ? 1.0 : 1.0 / max (dot (c, vec3 (1.0, dL, dL * dL)), 1.0);\n",e+="         float spotFactor            = light .type == x3d_SpotLight ? getSpotFactor_"+this.getId()+" (light .cutOffAngle, light .beamWidth, L, d) : 1.0;\n",e+="         float attenuationSpotFactor = attenuationFactor * spotFactor;\n",e+="         vec3  ambientColor          = light .ambientIntensity * ambientTerm;\n",e+="         vec3  diffuseSpecularColor  = light .intensity * (diffuseTerm + specularTerm);\n",e+="\n",e+="         shadedColor .rgb += attenuationSpotFactor * light .color * (ambientColor + diffuseSpecularColor);\n",e+="      }\n",e+="\n",e+="      shadedColor .rgb += emissiveColor_"+this.getId()+";\n",e+="   }\n"):this.materialNode?(e+="   shadedColor .rgb = diffuseColor_"+this.getId()+";\n",e+="   shadedColor .a   = originalColor .a * (1.0 - transparency_"+this.getId()+");\n"):e+="   shadedColor = originalColor;\n",e+="\n",e+="   return shadedColor;\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // ShadedVolumeStyle\n",e+="\n",e+="   textureColor = getShadedStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(Ee,{typeName:{value:"ShadedVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:3}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"lighting",new(l().SFBool)),new(u())(g().inputOutput,"shadows",new(l().SFBool)),new(u())(g().initializeOnly,"phaseFunction",new(l().SFString)("Henyey-Greenstein")),new(u())(g().inputOutput,"material",new(l().SFNode)),new(u())(g().inputOutput,"surfaceNormals",new(l().SFNode))]),enumerable:!0}});const je=Ee;y().add("ShadedVolumeStyle","x_ite/Components/VolumeRendering/ShadedVolumeStyle",je);const Me=je;function ze(e){b.call(this,e),this.addType(g().SilhouetteEnhancementVolumeStyle)}Object.assign(Object.setPrototypeOf(ze.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._surfaceNormals.addInterest("set_surfaceNormals__",this),this.set_surfaceNormals__())},set_surfaceNormals__(){this.surfaceNormalsNode=F()(g().X3DTexture3DNode,this._surfaceNormals)},addShaderFields(e){this._enabled.getValue()&&(e.addUserDefinedField(g().inputOutput,"silhouetteRetainedOpacity_"+this.getId(),this._silhouetteRetainedOpacity.copy()),e.addUserDefinedField(g().inputOutput,"silhouetteBoundaryOpacity_"+this.getId(),this._silhouetteBoundaryOpacity.copy()),e.addUserDefinedField(g().inputOutput,"silhouetteSharpness_"+this.getId(),this._silhouetteSharpness.copy()),this.surfaceNormalsNode&&e.addUserDefinedField(g().inputOutput,"surfaceNormals_"+this.getId(),new(l().SFNode)(this.surfaceNormalsNode)))},getUniformsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="// SilhouetteEnhancementVolumeStyle\n",e+="\n",e+="uniform float silhouetteRetainedOpacity_"+this.getId()+";\n",e+="uniform float silhouetteBoundaryOpacity_"+this.getId()+";\n",e+="uniform float silhouetteSharpness_"+this.getId()+";\n",e+=this.getNormalText(this.surfaceNormalsNode),e+="\n",e+="vec4\n",e+="getSilhouetteEnhancementStyle_"+this.getId()+" (in vec4 originalColor, in vec3 texCoord)\n",e+="{\n",e+="   vec4 surfaceNormal = getNormal_"+this.getId()+" (texCoord);\n",e+="\n",e+="   if (surfaceNormal .w == 0.0)\n",e+="      return vec4 (0.0);\n",e+="   \n",e+="   float silhouetteRetainedOpacity = silhouetteRetainedOpacity_"+this.getId()+";\n",e+="   float silhouetteBoundaryOpacity = silhouetteBoundaryOpacity_"+this.getId()+";\n",e+="   float silhouetteSharpness       = silhouetteSharpness_"+this.getId()+";\n",e+="\n",e+="   return vec4 (originalColor .rgb, originalColor .a * (silhouetteRetainedOpacity + silhouetteBoundaryOpacity * pow (1.0 - abs (dot (surfaceNormal .xyz, normalize (vertex))), silhouetteSharpness)));\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // SilhouetteEnhancementVolumeStyle\n",e+="\n",e+="   textureColor = getSilhouetteEnhancementStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(ze,{typeName:{value:"SilhouetteEnhancementVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:2}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"silhouetteRetainedOpacity",new(l().SFFloat)(1)),new(u())(g().inputOutput,"silhouetteBoundaryOpacity",new(l().SFFloat)(0)),new(u())(g().inputOutput,"silhouetteSharpness",new(l().SFFloat)(.5)),new(u())(g().inputOutput,"surfaceNormals",new(l().SFNode))]),enumerable:!0}});const Ue=ze;y().add("SilhouetteEnhancementVolumeStyle","x_ite/Components/VolumeRendering/SilhouetteEnhancementVolumeStyle",Ue);const Re=Ue;function Be(e){b.call(this,e),this.addType(g().ToneMappedVolumeStyle)}Object.assign(Object.setPrototypeOf(Be.prototype,b.prototype),{initialize(){b.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._surfaceNormals.addInterest("set_surfaceNormals__",this),this.set_surfaceNormals__())},set_surfaceNormals__(){this.surfaceNormalsNode=F()(g().X3DTexture3DNode,this._surfaceNormals)},addShaderFields(e){this._enabled.getValue()&&(e.addUserDefinedField(g().inputOutput,"coolColor_"+this.getId(),this._coolColor.copy()),e.addUserDefinedField(g().inputOutput,"warmColor_"+this.getId(),this._warmColor.copy()),this.surfaceNormalsNode&&e.addUserDefinedField(g().inputOutput,"surfaceNormals_"+this.getId(),new(l().SFNode)(this.surfaceNormalsNode)))},getUniformsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="// ToneMappedVolumeStyle\n",e+="\n",e+="uniform vec4 coolColor_"+this.getId()+";\n",e+="uniform vec4 warmColor_"+this.getId()+";\n",e+=this.getNormalText(this.surfaceNormalsNode),e+="\n",e+="vec4\n",e+="getToneMappedStyle_"+this.getId()+" (in vec4 originalColor, in vec3 texCoord)\n",e+="{\n",e+="   vec4 surfaceNormal = getNormal_"+this.getId()+" (texCoord);\n",e+="\n",e+="   if (surfaceNormal .w == 0.0)\n",e+="      return vec4 (0.0);\n",e+="\n",e+="   vec3 toneColor = vec3 (0.0);\n",e+="   vec3 coolColor = coolColor_"+this.getId()+" .rgb;\n",e+="   vec3 warmColor = warmColor_"+this.getId()+" .rgb;\n",e+="\n",e+="   for (int i = 0; i < X3D_NUM_LIGHTS; ++ i)\n",e+="   {\n",e+="      x3d_LightSourceParameters light = x3d_LightSource [i];\n",e+="\n",e+="      vec3  L           = light .type == x3d_DirectionalLight ? -light .direction : normalize (light .location - vertex);\n",e+="      float colorFactor = dot (L, surfaceNormal .xyz) * 0.5 + 0.5;\n",e+="\n",e+="      toneColor += mix (warmColor .rgb, coolColor .rgb, colorFactor);\n",e+="   }\n",e+="\n",e+="   return vec4 (toneColor, originalColor .a);\n",e+="}\n",e},getFunctionsText(){if(!this._enabled.getValue())return"";let e="";return e+="\n",e+="   // ToneMappedVolumeStyle\n",e+="\n",e+="   textureColor = getToneMappedStyle_"+this.getId()+" (textureColor, texCoord);\n",e}}),Object.defineProperties(Be,{typeName:{value:"ToneMappedVolumeStyle",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:2}),enumerable:!0},containerField:{value:"renderStyle",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"enabled",new(l().SFBool)(!0)),new(u())(g().inputOutput,"coolColor",new(l().SFColorRGBA)(0,0,1,0)),new(u())(g().inputOutput,"warmColor",new(l().SFColorRGBA)(1,1,0,0)),new(u())(g().inputOutput,"surfaceNormals",new(l().SFNode))]),enumerable:!0}});const Xe=Be;y().add("ToneMappedVolumeStyle","x_ite/Components/VolumeRendering/ToneMappedVolumeStyle",Xe);const Le=Xe;function Ae(e){Se.call(this,e),this.addType(g().VolumeData),this.renderStyleNode=null}Object.assign(Object.setPrototypeOf(Ae.prototype,Se.prototype),{initialize(){Se.prototype.initialize.call(this);this.getBrowser().getContext().getVersion()<2||(this._renderStyle.addInterest("set_renderStyle__",this),this._voxels.addInterest("set_voxels__",this),this._renderStyle.addInterest("updateShader",this),this.set_renderStyle__(),this.set_voxels__(),this.updateShader())},set_renderStyle__(){this.renderStyleNode&&(this.renderStyleNode.removeInterest("updateShader",this),this.renderStyleNode.removeVolumeData(this)),this.renderStyleNode=F()(g().X3DVolumeRenderStyleNode,this._renderStyle),this.renderStyleNode&&(this.renderStyleNode.addInterest("updateShader",this),this.renderStyleNode.addVolumeData(this))},set_voxels__(){this.voxelsNode=F()(g().X3DTexture3DNode,this._voxels),this.voxelsNode?this.getAppearance()._texture=this._voxels:this.getAppearance()._texture=this.getBrowser().getDefaultVoxels()},createShader(e,t,n){const o=this.getBrowser().getDefaultVolumeStyle();let r=o.getUniformsText(),i=o.getFunctionsText();this.renderStyleNode&&(r+=this.renderStyleNode.getUniformsText(),i+=this.renderStyleNode.getFunctionsText()),n=n.replace(/__VOLUME_STYLES_UNIFORMS__/,r).replace(/__VOLUME_STYLES_FUNCTIONS__/,i);const a=new(we())(this.getExecutionContext());a._url.push(encodeURI("data:x-shader/x-vertex,"+t)),a.setPrivate(!0),a.setName("VolumeDataVertexShader"),a.setOptions(e),a.setup();const s=new(we())(this.getExecutionContext());s._type="FRAGMENT",s._url.push(encodeURI("data:x-shader/x-fragment,"+n)),s.setPrivate(!0),s.setName("VolumeDataFragmentShader"),s.setOptions(e),s.setup();const l=new(Ne())(this.getExecutionContext());l._language="GLSL",l._parts.push(a),l._parts.push(s),l.setPrivate(!0),l.setName("VolumeDataShader"),o.addShaderFields(l),this.renderStyleNode&&this.renderStyleNode.addShaderFields(l);const d=[];return this.addShaderUniformNames(d),l.setUniformNames(d),l.setup(),l}}),Object.defineProperties(Ae,{typeName:{value:"VolumeData",enumerable:!0},componentInfo:{value:Object.freeze({name:"VolumeRendering",level:1}),enumerable:!0},containerField:{value:"children",enumerable:!0},specificationRange:{value:Object.freeze({from:"3.3",to:"Infinity"}),enumerable:!0},fieldDefinitions:{value:new(c())([new(u())(g().inputOutput,"metadata",new(l().SFNode)),new(u())(g().inputOutput,"dimensions",new(l().SFVec3f)(1,1,1)),new(u())(g().inputOutput,"visible",new(l().SFBool)(!0)),new(u())(g().inputOutput,"bboxDisplay",new(l().SFBool)),new(u())(g().initializeOnly,"bboxSize",new(l().SFVec3f)(-1,-1,-1)),new(u())(g().initializeOnly,"bboxCenter",new(l().SFVec3f)(0,0,0)),new(u())(g().inputOutput,"renderStyle",new(l().SFNode)),new(u())(g().inputOutput,"voxels",new(l().SFNode))]),enumerable:!0}});const Ge=Ae;y().add("VolumeData","x_ite/Components/VolumeRendering/VolumeData",Ge);const qe=Ge;n().add({name:"VolumeRendering",concreteNodes:[B,A,H,W,$,Fe,V,Ve,Pe,Me,Re,Le,qe],abstractNodes:[b,Se,N],browserContext:z});const He=void 0;y().add("VolumeRendering","assets/components/VolumeRendering",He)})();